%-Driver generated by the Component Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Component Wizard
%- If you change these lines, Component Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    30.09.2010
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%define! Description_SendSeparatedStrings Prints a string using an I/O function, formated for the 'help' command
%ifdef SerialLDD
  %ifdef @SerialLDD@OnBlockReceived
    %define! Description_%@SerialLDD@OnBlockReceived This event is called when the requested number of data is moved to the input buffer. The event services the event of the inherited component and eventually invokes other events.
  %endif %- @SerialLDD@OnBlockReceived
%endif %- SerialLDD
%ifdef SerialLDD
  %ifdef @SerialLDD@OnBlockSent
    %define! Description_%@SerialLDD@OnBlockSent This event is called after the last character from the output buffer is moved to the transmitter.  The event services the event of the inherited component and eventually invokes other events.
  %endif %- @SerialLDD@OnBlockSent
%endif %- SerialLDD
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\FSShellSettings.Inc
%define! Abstract Common\FSShellAbstract.Inc
%include Common\Header.h

%if (CPUfamily = "Kinetis")
#include "PE_LDD.h" /* hack for Processor Expert (e.g. in MCU10.3) and LDD: PE_LDD.h includes at the end all shared modules, causing a recursive header file include conflict */
%endif

%ifdef FS
#define %'ModuleName'%.FATFS   %@FS@'ModuleName'%.FATFS   /* alias to FATFS type */
#define %'ModuleName'%.DRESULT %@FS@'ModuleName'%.DRESULT /* alias to FATFS type */
#define %'ModuleName'%.FRESULT %@FS@'ModuleName'%.FRESULT /* alias to FATFS type */
%else
#define %'ModuleName'%.FATFS   /* dummy alias to FATFS type */
#define %'ModuleName'%.DRESULT /* dummy alias to FATFS type */
#define %'ModuleName'%.FRESULT /* dummy alias to FATFS type */
%endif

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited components */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"

#define %'ModuleName'_8_3_SIZE       sizeof("12345678.txt") /* length of a 8.3 file name (13 including the zero byte) */
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"
#include <stddef.h> /* for size_t */

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

#ifndef __BWUserType_%'ModuleName'_StdIO_OutErr_FctType
#define __BWUserType_%'ModuleName'_StdIO_OutErr_FctType
  typedef void (*%'ModuleName'%.StdIO_OutErr_FctType)(byte);     %>40/* Callback for an output or error I/O function */
#endif
#ifndef __BWUserType_%'ModuleName'_StdIO_In_FctType
#define __BWUserType_%'ModuleName'_StdIO_In_FctType
  typedef void (*%'ModuleName'%.StdIO_In_FctType)(byte *);       %>40/* Callback for an I/O input function. */
#endif
#ifndef __BWUserType_%'ModuleName'_StdIO_KeyPressed_FctType
#define __BWUserType_%'ModuleName'_StdIO_KeyPressed_FctType
  typedef bool (*%'ModuleName'%.StdIO_KeyPressed_FctType)(void); %>40/* Callback which returns true if a key has been pressed */
#endif
#ifndef __BWUserType_%'ModuleName'_StdIOType
#define __BWUserType_%'ModuleName'_StdIOType
  typedef struct {                                               %>40/* Record containing input, output and error callback (stdin, stdout, stderr). */
    %'ModuleName'_StdIO_In_FctType stdIn;                        %>40/* standard input */
    %'ModuleName'_StdIO_OutErr_FctType stdOut;                   %>40/* standard output */
    %'ModuleName'_StdIO_OutErr_FctType stdErr;                   %>40/* standard error */
    %'ModuleName'_StdIO_KeyPressed_FctType keyPressed;           %>40/* key pressed callback */
  } %'ModuleName'_StdIOType;
#endif
#ifndef __BWUserType_%'ModuleName'_ConstStdIOType
#define __BWUserType_%'ModuleName'_ConstStdIOType
  typedef const %'ModuleName'%.StdIOType %'ModuleName'%.ConstStdIOType;%>40/* constant StdIOType */
#endif
#ifndef __BWUserType_%'ModuleName'_ParseCommandCallback
#define __BWUserType_%'ModuleName'_ParseCommandCallback
  typedef byte (*%'ModuleName'%.ParseCommandCallback)(const byte *cmd, bool *handled, const %'ModuleName'%.StdIOType *io);%>40/* Callback for parsing a shell command */
#endif
#ifndef __BWUserType_%'ModuleName'_ConstStdIOTypePtr
#define __BWUserType_%'ModuleName'_ConstStdIOTypePtr
  typedef const %'ModuleName'%.ConstStdIOType *%'ModuleName'%.ConstStdIOTypePtr;%>40/* Pointer to constant standard I/O descriptor */
#endif

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-
#define %'ModuleName'%.DASH_LINE "--------------------------------------------------------------"
/* predefined commands */
#define %'ModuleName'%.CMD_HELP   "help"
#define %'ModuleName'%.CMD_STATUS "status"
%-BW_CUSTOM_USERTYPE_END


%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendStr
%ifdef SendStr
void %'ModuleName'%.%SendStr(const byte *str, %'ModuleName'_StdIO_OutErr_FctType io);
%define! Parstr
%define! Pario
%include Common\FSShellSendStr.Inc

%endif %- SendStr
%-BW_METHOD_END SendStr
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintDirectory
%ifdef PrintDirectory
byte %'ModuleName'%.%PrintDirectory(const byte *dirName, %'ModuleName'_ConstStdIOType *io);
%define! PardirName
%define! Pario
%define! RetVal
%include Common\FSShellPrintDirectory.Inc

%endif %- PrintDirectory
%-BW_METHOD_END PrintDirectory
%-************************************************************************************************************
%-BW_METHOD_BEGIN CopyFile
%ifdef CopyFile
byte %'ModuleName'%.%CopyFile(const byte *srcFileName, const byte *dstFileName, %'ModuleName'_ConstStdIOType *io);
%define! ParsrcFileName
%define! PardstFileName
%define! Pario
%define! RetVal
%include Common\FSShellCopyFile.Inc

%endif %- CopyFile
%-BW_METHOD_END CopyFile
%-************************************************************************************************************
%-BW_METHOD_BEGIN DeleteFile
%ifdef DeleteFile
byte %'ModuleName'%.%DeleteFile(const byte *fileName, %'ModuleName'_ConstStdIOType *io);
%define! ParfileName
%define! Pario
%define! RetVal
%include Common\FSShellDeleteFile.Inc

%endif %- DeleteFile
%-BW_METHOD_END DeleteFile
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintFile
%ifdef PrintFile
byte %'ModuleName'%.%PrintFile(const byte *fileName, %'ModuleName'_ConstStdIOType *io);
%define! ParfileName
%define! Pario
%define! RetVal
%include Common\FSShellPrintFile.Inc

%endif %- PrintFile
%-BW_METHOD_END PrintFile
%-************************************************************************************************************
%-BW_METHOD_BEGIN MakeDirectory
%ifdef MakeDirectory
byte %'ModuleName'%.%MakeDirectory(const byte *dirName, %'ModuleName'_ConstStdIOType *io);
%define! PardirName
%define! Pario
%define! RetVal
%include Common\FSShellMakeDirectory.Inc

%endif %- MakeDirectory
%-BW_METHOD_END MakeDirectory
%-************************************************************************************************************
%-BW_METHOD_BEGIN RenameFile
%ifdef RenameFile
byte %'ModuleName'%.%RenameFile(const byte *srcFileName, const byte *dstFileName, %'ModuleName'_ConstStdIOType *io);
%define! ParsrcFileName
%define! PardstFileName
%define! Pario
%define! RetVal
%include Common\FSShellRenameFile.Inc

%endif %- RenameFile
%-BW_METHOD_END RenameFile
%-************************************************************************************************************
%-BW_METHOD_BEGIN MountFileSystem
%ifdef MountFileSystem
byte %'ModuleName'%.%MountFileSystem(%'ModuleName'_FATFS *fileSystemObject, byte logicalDrive, %'ModuleName'_ConstStdIOType *io);
%define! ParlogicalDrive
%define! Pario
%define! ParfileSystemObject
%define! RetVal
%include Common\FSShellMountFileSystem.Inc

%endif %- MountFileSystem
%-BW_METHOD_END MountFileSystem
%-************************************************************************************************************
%-BW_METHOD_BEGIN UnMountFileSystem
%ifdef UnMountFileSystem
byte %'ModuleName'%.%UnMountFileSystem(byte logicalDrive, %'ModuleName'_ConstStdIOType *io);
%define! ParlogicalDrive
%define! Pario
%define! RetVal
%include Common\FSShellUnMountFileSystem.Inc

%endif %- UnMountFileSystem
%-BW_METHOD_END UnMountFileSystem
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintDiskInfo
%ifdef PrintDiskInfo
byte %'ModuleName'%.%PrintDiskInfo(byte drive, %'ModuleName'_ConstStdIOType *io);
%define! Pario
%define! Pardrive
%define! RetVal
%include Common\FSShellPrintDiskInfo.Inc

%endif %- PrintDiskInfo
%-BW_METHOD_END PrintDiskInfo
%-************************************************************************************************************
%-BW_METHOD_BEGIN ShellCmd
%ifdef ShellCmd
byte %'ModuleName'%.%ShellCmd(const unsigned char *cmd, bool *handled, %'ModuleName'_ConstStdIOType *io);
%define! Pario
%define! Parcmd
%define! Parhandled
%define! RetVal
%include Common\FSShellShellCmd.Inc

%endif %- ShellCmd
%-BW_METHOD_END ShellCmd
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintSector
%ifdef PrintSector
byte %'ModuleName'%.%PrintSector(byte drive, dword sectorNo, %'ModuleName'_ConstStdIOType *io);
%define! Pardrive
%define! Pario
%define! ParsectorNo
%define! RetVal
%include Common\FSShellPrintSector.Inc

%endif %- PrintSector
%-BW_METHOD_END PrintSector
%-************************************************************************************************************
%-BW_METHOD_BEGIN ChangeDirectory
%ifdef ChangeDirectory
byte %'ModuleName'%.%ChangeDirectory(const byte *dirName, %'ModuleName'_ConstStdIOType *io);
%define! PardirName
%define! Pario
%define! RetVal
%include Common\FSShellChangeDirectory.Inc

%endif %- ChangeDirectory
%-BW_METHOD_END ChangeDirectory
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum32s
%ifdef SendNum32s
void %'ModuleName'%.%SendNum32s(long val, %'ModuleName'_StdIO_OutErr_FctType io);
%define! Parval
%define! Pario
%include Common\FSShellSendNum32s.Inc

%endif %- SendNum32s
%-BW_METHOD_END SendNum32s
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum16s
%ifdef SendNum16s
void %'ModuleName'%.%SendNum16s(int16_t val, %'ModuleName'_StdIO_OutErr_FctType io);
%define! Parval
%define! Pario
%include Common\FSShellSendNum16s.Inc

%endif %- SendNum16s
%-BW_METHOD_END SendNum16s
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintPrompt
%ifdef PrintPrompt
void %'ModuleName'%.%PrintPrompt(%'ModuleName'_ConstStdIOType *io);
%define! Pario
%include Common\FSShellPrintPrompt.Inc

%endif %- PrintPrompt
%-BW_METHOD_END PrintPrompt
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadLine
%ifdef ReadLine
bool %'ModuleName'%.%ReadLine(byte *buf, size_t bufSize, %'ModuleName'_ConstStdIOType *io);
%define! Parbuf
%define! ParbufSize
%define! Pario
%define! RetVal
%include Common\FSShellReadLine.Inc

%endif %- ReadLine
%-BW_METHOD_END ReadLine
%-************************************************************************************************************
%-BW_METHOD_BEGIN Date
%ifdef Date
byte %'ModuleName'%.%Date(const unsigned char *cmd, %'ModuleName'_ConstStdIOType *io);
%define! Parcmd
%define! Pario
%define! RetVal
%include Common\FSShellDate.Inc

%endif %- Date
%-BW_METHOD_END Date
%-************************************************************************************************************
%-BW_METHOD_BEGIN Time
%ifdef Time
byte %'ModuleName'%.%Time(const unsigned char *cmd, %'ModuleName'_ConstStdIOType *io);
%define! Parcmd
%define! Pario
%define! RetVal
%include Common\FSShellTime.Inc

%endif %- Time
%-BW_METHOD_END Time
%-************************************************************************************************************
%-BW_METHOD_BEGIN CheckCardPresence
%ifdef CheckCardPresence
byte %'ModuleName'%.%CheckCardPresence(bool *cardMounted, byte drive, %'ModuleName'_FATFS *fileSystemObject, %'ModuleName'_ConstStdIOType *io);
%define! ParcardMounted
%define! Pardrive
%define! ParfileSystemObject
%define! Pario
%define! RetVal
%include Common\FSShellCheckCardPresence.Inc

%endif %- CheckCardPresence
%-BW_METHOD_END CheckCardPresence
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintStatus
%ifdef PrintStatus
byte %'ModuleName'%.%PrintStatus(%'ModuleName'_ConstStdIOType *io);
%define! Pario
%define! RetVal
%include Common\FSShellPrintStatus.Inc

%endif %- PrintStatus
%-BW_METHOD_END PrintStatus
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintCommandFailed
%ifdef PrintCommandFailed
void %'ModuleName'%.%PrintCommandFailed(const unsigned char *cmd, %'ModuleName'_ConstStdIOType *io);
%define! Pario
%define! Parcmd
%include Common\FSShellPrintCommandFailed.Inc

%endif %- PrintCommandFailed
%-BW_METHOD_END PrintCommandFailed
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseCommand
%ifdef ParseCommand
byte %'ModuleName'%.%ParseCommand(const unsigned char *cmd, %'ModuleName'_ConstStdIOType *io, %'ModuleName'_ParseCommandCallback parseCallback);
%define! Parcmd
%define! Pario
%define! ParparseCallback
%define! RetVal
%include Common\FSShellParseCommand.Inc

%endif %- ParseCommand
%-BW_METHOD_END ParseCommand
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetStdio
%ifdef GetStdio
%'ModuleName'_ConstStdIOTypePtr %'ModuleName'%.%GetStdio(void);
%define! RetVal
%include Common\FSShellGetStdio.Inc

%endif %- GetStdio
%-BW_METHOD_END GetStdio
%-************************************************************************************************************
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum32u
%ifdef SendNum32u
void %'ModuleName'%.%SendNum32u(dword val, %'ModuleName'_StdIO_OutErr_FctType io);
%define! Parval
%define! Pario
%include Common\FSShellSendNum32u.Inc

%endif %- SendNum32u
%-BW_METHOD_END SendNum32u
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum16u
%ifdef SendNum16u
void %'ModuleName'%.%SendNum16u(word val, %'ModuleName'_StdIO_OutErr_FctType io);
%define! Parval
%define! Pario
%include Common\FSShellSendNum16u.Inc

%endif %- SendNum16u
%-BW_METHOD_END SendNum16u
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum8u
%ifdef SendNum8u
void %'ModuleName'%.%SendNum8u(byte val, %'ModuleName'_StdIO_OutErr_FctType io);
%define! Parval
%define! Pario
%include Common\FSShellSendNum8u.Inc

%endif %- SendNum8u
%-BW_METHOD_END SendNum8u
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum8s
%ifdef SendNum8s
void %'ModuleName'%.%SendNum8s(signed char val, %'ModuleName'_StdIO_OutErr_FctType io);
%define! Parval
%define! Pario
%include Common\FSShellSendNum8s.Inc

%endif %- SendNum8s
%-BW_METHOD_END SendNum8s
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
void %'ModuleName'%.%Init(void);
%include Common\FSShellInit.Inc

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN RequestSerial
%ifdef RequestSerial
void %'ModuleName'%.%RequestSerial(void);
%include Common\FSShellRequestSerial.Inc

%endif %- RequestSerial
%-BW_METHOD_END RequestSerial
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReleaseSerial
%ifdef ReleaseSerial
void %'ModuleName'%.%ReleaseSerial(void);
%include Common\FSShellReleaseSerial.Inc

%endif %- ReleaseSerial
%-BW_METHOD_END ReleaseSerial
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendHelpStr
%ifdef SendHelpStr
void %'ModuleName'%.%SendHelpStr(const byte *strCmd, const byte *strHelp, %'ModuleName'_StdIO_OutErr_FctType io);
%define! ParstrCmd
%define! Pario
%define! ParstrHelp
%include Common\FSShellSendHelpStr.Inc

%endif %- SendHelpStr
%-BW_METHOD_END SendHelpStr
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendStatusStr
%ifdef SendStatusStr
void %'ModuleName'%.%SendStatusStr(const byte *strItem, const byte *strStatus, %'ModuleName'_StdIO_OutErr_FctType io);
%define! ParstrItem
%define! ParstrStatus
%define! Pario
%include Common\FSShellSendStatusStr.Inc

%endif %- SendStatusStr
%-BW_METHOD_END SendStatusStr
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadChar
%ifdef ReadChar
void %'ModuleName'%.%ReadChar(byte *c);
%define! Parc
%include Common\FSShellReadChar.Inc

%endif %- ReadChar
%-BW_METHOD_END ReadChar
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendChar
%ifdef SendChar
void %'ModuleName'%.%SendChar(byte ch);
%define! Parch
%include Common\FSShellSendChar.Inc

%endif %- SendChar
%-BW_METHOD_END SendChar
%-************************************************************************************************************
%-BW_METHOD_BEGIN KeyPressed
%ifdef KeyPressed
bool %'ModuleName'%.%KeyPressed(void);
%define! RetVal
%include Common\FSShellKeyPressed.Inc

%endif %- KeyPressed
%-BW_METHOD_END KeyPressed
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
void %'ModuleName'%.%Deinit(void);
%include Common\FSShellDeinit.Inc

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-INHERITED_EVENT_BEGIN SerialLDD OnBlockSent
%ifdef SerialLDD
%ifdef @SerialLDD@OnBlockSent
void %@SerialLDD@OnBlockSent(LDD_TUserData *UserDataPtr);
%- %define! ParUserDataPtr
%- %include Common\FSShellOnBlockSent.Inc

%endif %- @SerialLDD@OnBlockSent
%endif %-ifdef SerialLDD
%-INHERITED_EVENT_END SerialLDD OnBlockSent
%-************************************************************************************************************
%-INHERITED_EVENT_BEGIN SerialLDD OnBlockReceived
%ifdef SerialLDD
%ifdef @SerialLDD@OnBlockReceived
void %@SerialLDD@OnBlockReceived(LDD_TUserData *UserDataPtr);
%- %define! ParUserDataPtr
%- %include Common\FSShellOnBlockReceived.Inc

%endif %- @SerialLDD@OnBlockReceived
%endif
%-INHERITED_EVENT_END SerialLDD OnBlockReceived
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetSemaphore
%ifdef GetSemaphore
void* %'ModuleName'%.%GetSemaphore(void);
%define! RetVal
%include Common\FSShellGetSemaphore.Inc

%endif %- GetSemaphore
%-BW_METHOD_END GetSemaphore
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadAndParseLine
%ifdef ReadAndParseLine
byte %'ModuleName'%.%ReadAndParseLine(byte *cmdBuf, size_t cmdBufSize, %'ModuleName'_ConstStdIOType *io, %'ModuleName'_ParseCommandCallback parseCallback);
%define! ParcmdBuf
%define! ParcmdBufSize
%define! Pario
%define! ParparseCallback
%define! RetVal
%include Common\FSShellReadAndParseLine.Inc

%endif %- ReadAndParseLine
%-BW_METHOD_END ReadAndParseLine
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_METHOD_BEGIN OnRequestRTC
%ifdef OnRequestRTC
%INTERFACE OnRequestRTC
void %OnRequestRTC(void);
%include Common\FSShellOnRequestRTC.Inc

%endif %- OnRequestRTC
%-BW_METHOD_END OnRequestRTC
%-BW_METHOD_BEGIN OnReleaseRTC
%ifdef OnReleaseRTC
%INTERFACE OnReleaseRTC
void %OnReleaseRTC(void);
%include Common\FSShellOnReleaseRTC.Inc

%endif %- OnReleaseRTC
%-BW_METHOD_END OnReleaseRTC
%-BW_METHOD_BEGIN OnTimeSet
%ifdef OnTimeSet
%INTERFACE OnTimeSet
void %OnTimeSet(byte hour, byte minute, byte second, byte hSecond);
%define! Parhour
%define! Parminute
%define! Parsecond
%define! ParhSecond
%include Common\FSShellOnTimeSet.Inc

%endif %- OnTimeSet
%-BW_METHOD_END OnTimeSet
%-BW_METHOD_BEGIN OnBlockReceived
%ifdef OnBlockReceived
%INTERFACE OnBlockReceived
void %OnBlockReceived(LDD_TUserData *UserDataPtr);
%define! ParUserDataPtr
%include Common\FSShellOnBlockReceived.Inc

%endif %- OnBlockReceived
%-BW_METHOD_END OnBlockReceived
%-BW_METHOD_BEGIN OnBlockSent
%ifdef OnBlockSent
%INTERFACE OnBlockSent
void %OnBlockSent(LDD_TUserData *UserDataPtr);
%define! ParUserDataPtr
%include Common\FSShellOnBlockSent.Inc

%endif %- OnBlockSent
%-BW_METHOD_END OnBlockSent
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\FSShellSettings.Inc
%define! Abstract Common\FSShellAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%ifdef FS
#if %@FS@'ModuleName'%.USE_LFN == 0                              %>40 /* No LFN */
#define %'ModuleName'%.DEF_NAMEBUF(name)                         %>40 byte name[%'ModuleName'%.8_3_SIZE]
#define %'ModuleName'%.PTR_NAMEBUF(name)                         %>40 &name[0]
#define %'ModuleName'%.SIZE_NAMEBUF(name)                        %>40 sizeof(name)
#define %'ModuleName'%.INIT_NAMEBUF(name)
#define %'ModuleName'%.FREE_NAMEBUF(name)

#elif %@FS@'ModuleName'%.USE_LFN == 1                            %>40 /* LFN with static LFN working buffer */
static TCHAR %'ModuleName'%.FileName[%@FS@'ModuleName'%.MAX_LFN+1];
static TCHAR %'ModuleName'%.FileName2[%@FS@'ModuleName'%.MAX_LFN+1];
#define %'ModuleName'%.DEF_NAMEBUF(name)
#define %'ModuleName'%.PTR_NAMEBUF(name)                         %>40 &%'ModuleName'%.name[0]
#define %'ModuleName'%.SIZE_NAMEBUF(name)                        %>40 sizeof(%'ModuleName'%.name)
#define %'ModuleName'%.INIT_NAMEBUF(name)
#define %'ModuleName'%.FREE_NAMEBUF(name)

#elif %@FS@'ModuleName'%.USE_LFN == 2                            %>40 /* LFN with dynamic LFN working buffer on the stack */
#define %'ModuleName'%.DEF_NAMEBUF(name)                         %>40 byte name[%@FS@'ModuleName'%.MAX_LFN+1]
#define %'ModuleName'%.PTR_NAMEBUF(name)                         %>40 &name[0]
#define %'ModuleName'%.SIZE_NAMEBUF(name)                        %>40 sizeof(name)
#define %'ModuleName'%.INIT_NAMEBUF(name)
#define %'ModuleName'%.FREE_NAMEBUF(name)

#elif %@FS@'ModuleName'%.USE_LFN == 3                            %>40 /* LFN with dynamic LFN working buffer on the heap */
#define %'ModuleName'%.DEF_NAMEBUF(name)                         %>40 byte *name
#define %'ModuleName'%.PTR_NAMEBUF(name)                         %>40 name
#define %'ModuleName'%.SIZE_NAMEBUF(name)                        %>40 (%@FS@'ModuleName'%.MAX_LFN+1)
#define %'ModuleName'%.INIT_NAMEBUF(name)                        %>40 { name = ff_memalloc(%@FS@'ModuleName'%.MAX_LFN+1); \
                                                                 %>40   if (!name) { \
                                                                 %>40     %'ModuleName'%.%SendStr((unsigned char*)"ff_memalloc failed!", io->stdErr); \
                                                                 %>40     return ERR_FAILED; \
                                                                 %>40   } \
                                                                 %>40 }
#define %'ModuleName'%.FREE_NAMEBUF(name)                        %>40 ff_memfree(name)

#else
#error Wrong LFN configuration.
#endif
%endif %-ifdef FS

#include <stdio.h>
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
%----------------
%ifdef SerialLDD %- only need this for LDD for now
%if defined(OperatingSystemId)
%- Include RTOS adapter file so we can use RTOS functions (RTOSAdap_genCriticalSectionBegin(), RTOSAdap_genCriticalSectionEnd())
%include sw\RTOSAdaptor\%'OperatingSystemId'_RTOSAdaptor.prg
%endif
%endif
%---------- alternative implementation, but not elegant
%- %if defined(OperatingSystemId)
%-  %if defined(RTOS) & defined(@RTOS@IsClassicCW)
%-    %if %@RTOS@IsClassicCW='yes'
%-      %- do not include RTOS adapter file, as we are in classic
%-    %else
%-      %- Include RTOS adapter file so we can use RTOS functions (RTOSAdap_genCriticalSectionBegin(), RTOSAdap_genCriticalSectionEnd())
%-      %include sw\RTOSAdaptor\%'OperatingSystemId'_RTOSAdaptor.prg
%-    %endif
%-  %endif
%- %endif
%----------------
#ifdef __HC08__
  #pragma MESSAGE DISABLE C3303 /* implicit concatenation of strings */
#endif
%if defined(ConsoleSempahore) & %ConsoleSempahore='yes'
static xSemaphoreHandle ShellSem = NULL; /* Semaphore to protect shell SCI access */
%endif
%if defined(SerialLDD)
static LDD_TDeviceData *serialHandle = NULL; /* handle to device data */
static uint8_t charBuf; /* single character buffer for LDD ReceiveBlock() */
%if BlockingSend='yes'
static volatile uint8_t %'ModuleName'%.SentFlag = 0; /* this will be set to 1 once the block has been sent */
%endif
%endif
%ifdef FS
/* internal File System Routines */
static void FatFsFResultMsg(byte *msg, %'ModuleName'_FRESULT errNo, %'ModuleName'_ConstStdIOType *io)
{
  unsigned char buf[sizeof("1234")];

  %'ModuleName'%.%SendStr((unsigned char*)"ERROR: ", io->stdErr);
  %'ModuleName'%.%SendStr(msg, io->stdErr);
  %'ModuleName'%.%SendStr((unsigned char*)": (", io->stdErr);
  %@Utility@'ModuleName'%.Num16sToStr(buf, sizeof(buf), errNo);
  %'ModuleName'%.%SendStr(buf, io->stdErr);
  %'ModuleName'%.%SendStr((unsigned char*)") ", io->stdErr);
  %'ModuleName'%.%SendStr((unsigned char*)%@FS@'ModuleName'%.errFResultMsg(errNo), io->stdErr);
  %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdErr);
}

%ifdef PrintSector %- function blow only used by this method
static void FatFsDResultMsg(byte *msg, %'ModuleName'_DRESULT errNo, %'ModuleName'_ConstStdIOType *io)
{
  unsigned char buf[sizeof("1234")];

  %'ModuleName'%.%SendStr((unsigned char*)"ERROR: ", io->stdErr);
  %'ModuleName'%.%SendStr(msg, io->stdErr);
  %'ModuleName'%.%SendStr((unsigned char*)": (", io->stdErr);
  %@Utility@'ModuleName'%.Num16sToStr(buf, sizeof(buf), errNo);
  %'ModuleName'%.%SendStr(buf, io->stdErr);
  %'ModuleName'%.%SendStr((unsigned char*)") ", io->stdErr);
  %'ModuleName'%.%SendStr((unsigned char*)%@FS@'ModuleName'%.errDResultMsg(errNo), io->stdErr);
  %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdErr);
}

%endif
static void CmdUsageError(const unsigned char *cmd, byte *usage, %'ModuleName'_ConstStdIOType *io)
{
  %'ModuleName'%.%SendStr((unsigned char*)"*** error while reading command: ", io->stdErr);
  %'ModuleName'%.%SendStr(cmd, io->stdErr);
  %'ModuleName'%.%SendStr((unsigned char*)"\r\n*** Usage: ", io->stdErr);
  %'ModuleName'%.%SendStr((unsigned char*)usage, io->stdErr);
  %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdErr);
}

/*!
 * \brief Writes a directory listing of the given path
 * \param[in] dirPathPtr Pointer to a directory path string. Pass "\\" for the root directory
 * \param[in] io Callback to write directory output
 * \return Error code, otherwise ERR_OK
 */
static byte PrintDir(const byte *dirPathPtr, %'ModuleName'_ConstStdIOType *io)
{
  %@FS@'ModuleName'%.FILINFO fInfo;
  %@FS@'ModuleName'%.FRESULT fres;
  uint32_t p1;
  UINT s1, s2;
  %@FS@'ModuleName'%.DIR dir;  /* Directory object */
  byte buf[sizeof("yyyy-mm-dd hh:ss")+1];
#if !%@FS@'ModuleName'%.FS_READONLY
  %@FS@'ModuleName'%.FATFS *fs;
#endif
#if %@FS@'ModuleName'%.USE_LFN
  %'ModuleName'%.DEF_NAMEBUF(fileName);
#endif

  %'ModuleName'%.%SendStr((unsigned char*)"Directory of ", io->stdOut);
  %'ModuleName'%.%SendStr(dirPathPtr, io->stdOut);
  %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
  fres = %@FS@'ModuleName'%.opendir(&dir, (char*)dirPathPtr);
  if (fres != FR_OK) {
    FatFsFResultMsg((unsigned char*)"opendir failed", fres, io);
    return ERR_FAULT;
  }
  p1 = s1 = s2 = 0;
#if %@FS@'ModuleName'%.USE_LFN
  %'ModuleName'%.INIT_NAMEBUF(fileName);
  fInfo.lfname = (char*)fileName;
  fInfo.lfsize = %'ModuleName'%.SIZE_NAMEBUF(fileName);
#endif
  for(;;) {
    fres = %@FS@'ModuleName'%.readdir(&dir, &fInfo);
    if (fres != FR_OK) {
      FatFsFResultMsg((unsigned char*)"readdir failed", fres, io);
      break;
    }
    if (!fInfo.fname[0]) { /* end of directory list */
      break;
    }
    /* file attributes */
    if (fInfo.fattrib & AM_DIR) { /* directory */
      s2++;
      io->stdOut('D');
    } else {
      s1++;
      p1 += fInfo.fsize;
      io->stdOut('-');
    }
    if (fInfo.fattrib & AM_RDO) { /* read only */
      io->stdOut('R');
    } else {
      io->stdOut('-');
    }
    if (fInfo.fattrib & AM_HID) { /* hidden */
      io->stdOut('H');
    } else {
      io->stdOut('-');
    }
    if (fInfo.fattrib & AM_SYS) { /* system */
      io->stdOut('S');
    } else {
      io->stdOut('-');
    }
    if (fInfo.fattrib & AM_ARC) { /* archive */
      io->stdOut('A');
    } else {
      io->stdOut('-');
    }
    io->stdOut(' ');
    /* file date & time */
    buf[0] = '\0';
    %@Utility@'ModuleName'%.strcatNum16sFormatted(buf, sizeof(buf), (int16_t)((fInfo.fdate >> 9) + 1980), ' ', 4); /* year */
    %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)"-");
    %@Utility@'ModuleName'%.strcatNum16sFormatted(buf, sizeof(buf), (int16_t)((fInfo.fdate >> 5) & 15), '0', 2); /* month */
    %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)"-");
    %@Utility@'ModuleName'%.strcatNum16sFormatted(buf, sizeof(buf), (int16_t)(fInfo.fdate & 31), '0', 2); /* day */
    %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)" ");
    %@Utility@'ModuleName'%.strcatNum16sFormatted(buf, sizeof(buf), (int16_t)((fInfo.ftime >> 11)), '0', 2); /* hour */
    %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)":");
    %@Utility@'ModuleName'%.strcatNum16sFormatted(buf, sizeof(buf), (int16_t)((fInfo.ftime >> 5) & 63), '0', 2); /* minute */
    %'ModuleName'%.%SendStr(buf, io->stdOut);
    io->stdOut(' ');
    buf[0] = '\0';
    /* file size */
    %@Utility@'ModuleName'%.strcatNum32uFormatted(buf, sizeof(buf), fInfo.fsize, ' ', 10); /* size */
    %'ModuleName'%.%SendStr(buf, io->stdOut);
    /* file name */
    io->stdOut(' ');
    %'ModuleName'%.%SendStr((unsigned char*)fInfo.fname, io->stdOut);
#if FAT1_USE_LFN
    io->stdOut(' ');
    %'ModuleName'%.%SendStr((unsigned char*)fInfo.lfname, io->stdOut);
#endif
    io->stdOut('\r');
    io->stdOut('\n');
  }
  /* number of files and bytes used */
  buf[0] = '\0';
  %@Utility@'ModuleName'%.strcatNum16u(buf, sizeof(buf), (uint16_t)s1);
  %'ModuleName'%.%SendStr(buf, io->stdOut);
  %'ModuleName'%.%SendStr((unsigned char*)" File(s), ", io->stdOut);
  buf[0] = '\0';
  %@Utility@'ModuleName'%.strcatNum32u(buf, sizeof(buf), p1);
  %'ModuleName'%.%SendStr(buf, io->stdOut);
  %'ModuleName'%.%SendStr((unsigned char*)" bytes total\r\n", io->stdOut);
  /* number of directories and number of free bytes */
  buf[0] = '\0';
  %@Utility@'ModuleName'%.strcatNum16u(buf, sizeof(buf), (uint16_t)s2);
  %'ModuleName'%.%SendStr(buf, io->stdOut);
  %'ModuleName'%.%SendStr((unsigned char*)" Dir(s)", io->stdOut);
#if !%@FS@'ModuleName'%.FS_READONLY
  /* number of free bytes */
  fres = %@FS@'ModuleName'%.getfree((char*)dirPathPtr, &p1, &fs);
  if (fres != FR_OK) {
    FatFsFResultMsg((unsigned char*)"getfree failed", fres, io);
  } else {
    io->stdOut(',');
    io->stdOut(' ');
    buf[0] = '\0';
    %@Utility@'ModuleName'%.strcatNum32s(buf, sizeof(buf), (long)(p1*fs->csize/2));
    %'ModuleName'%.%SendStr(buf, io->stdOut);
    %'ModuleName'%.%SendStr((unsigned char*)" KBytes free", io->stdOut);
  }
#endif
  io->stdOut('\r');
  io->stdOut('\n');
#if %@FS@'ModuleName'%.USE_LFN
  %'ModuleName'%.FREE_NAMEBUF(fileName);
#endif
  return ERR_OK;
}

%ifdef PrintDirectory
static byte DirCmd(const unsigned char *cmd, %'ModuleName'_ConstStdIOType *io)
{
  /* precondition: cmd starts with "dir" */
  byte res = ERR_OK;
  %'ModuleName'%.DEF_NAMEBUF(fileName);

  %'ModuleName'%.INIT_NAMEBUF(fileName);
  if (*(cmd+sizeof("dir")-1)== ' ') { /* space after "dir": read name */
    if (%@Utility@'ModuleName'%.ReadEscapedName(cmd+sizeof("dir"), %'ModuleName'%.PTR_NAMEBUF(fileName),
          %'ModuleName'%.SIZE_NAMEBUF(fileName), NULL, NULL, NULL)==ERR_OK
       )
    {
      /* ok, have now directory name */
    } else {
      %'ModuleName'%.%SendStr((unsigned char*)"reading directory name failed!\r\n", io->stdErr);
      res = ERR_FAILED;
    }
  } else { /* use current directory */
#if %@FS@'ModuleName'%.FS_RPATH >= 2
    %@FS@'ModuleName'%.FRESULT fres;
    fres = %@FS@'ModuleName'%.getcwd((char*)%'ModuleName'%.PTR_NAMEBUF(fileName), %'ModuleName'%.SIZE_NAMEBUF(fileName));
    if(fres!=FR_OK) {
      FatFsFResultMsg((unsigned char*)"getcwd failed", fres, io);
      res = ERR_FAILED;
    } else {
      /* ok, have now directory name */
    }
#else
    %@Utility@'ModuleName'%.strcpy(%'ModuleName'%.PTR_NAMEBUF(fileName), %'ModuleName'%.SIZE_NAMEBUF(fileName), (unsigned char*)"\\"); /* use root */
#endif
  }
  if (res == ERR_OK) {
    res = %'ModuleName'%.%PrintDirectory(%'ModuleName'%.PTR_NAMEBUF(fileName), io);
  }
  %'ModuleName'%.FREE_NAMEBUF(fileName);
  return res;
}

%endif
%ifdef CopyFile
static byte CopyCmd(const unsigned char *cmd, %'ModuleName'_ConstStdIOType *io)
{
  /* precondition: cmd starts with "copy" */
  byte res = ERR_OK;
  size_t lenRead;
  %'ModuleName'%.DEF_NAMEBUF(fileName);
  %'ModuleName'%.DEF_NAMEBUF(fileName2);

  %'ModuleName'%.INIT_NAMEBUF(fileName);
  %'ModuleName'%.INIT_NAMEBUF(fileName2);
  if (   (%@Utility@'ModuleName'%.ReadEscapedName(cmd+sizeof("copy"), %'ModuleName'%.PTR_NAMEBUF(fileName),
          %'ModuleName'%.SIZE_NAMEBUF(fileName), &lenRead, NULL, NULL)==ERR_OK)
      && *(cmd+sizeof("copy")+lenRead)==' '
      && (%@Utility@'ModuleName'%.ReadEscapedName(cmd+sizeof("copy")+lenRead+1, %'ModuleName'%.PTR_NAMEBUF(fileName2),
          %'ModuleName'%.SIZE_NAMEBUF(fileName2), NULL, NULL, NULL)==ERR_OK)
     )
  {
    res = %'ModuleName'%.%CopyFile(%'ModuleName'%.PTR_NAMEBUF(fileName), %'ModuleName'%.PTR_NAMEBUF(fileName2), io);
  } else {
    CmdUsageError(cmd, (unsigned char*)"copy srcFileName dstFileName", io);
    res = ERR_FAILED;
  }
  %'ModuleName'%.FREE_NAMEBUF(fileName);
  %'ModuleName'%.FREE_NAMEBUF(fileName2);
  return res;
}
%endif

%ifdef DeleteFile
static byte DeleteCmd(const unsigned char *cmd, %'ModuleName'_ConstStdIOType *io)
{
  /* precondition: cmd starts with "delete" */
  byte res = ERR_OK;
  %'ModuleName'%.DEF_NAMEBUF(fileName);

  %'ModuleName'%.INIT_NAMEBUF(fileName);
  if (%@Utility@'ModuleName'%.ReadEscapedName(cmd+sizeof("delete"), %'ModuleName'%.PTR_NAMEBUF(fileName),
        %'ModuleName'%.SIZE_NAMEBUF(fileName), NULL, NULL, NULL)==ERR_OK
     )
  {
    res = %'ModuleName'%.%DeleteFile(%'ModuleName'%.PTR_NAMEBUF(fileName), io);
  } else {
    CmdUsageError(cmd, (unsigned char*)"delete fileName", io);
    res = ERR_FAILED;
  }
  %'ModuleName'%.FREE_NAMEBUF(fileName);
  return res;
}

%endif
%ifdef MakeDirectory
static byte MkdirCmd(const unsigned char *cmd, %'ModuleName'_ConstStdIOType *io)
{
  /* precondition: cmd starts with "mkdir" */
  byte res = ERR_OK;
  %'ModuleName'%.DEF_NAMEBUF(fileName);

  %'ModuleName'%.INIT_NAMEBUF(fileName);
  if (%@Utility@'ModuleName'%.ReadEscapedName(cmd+sizeof("mkdir"), %'ModuleName'%.PTR_NAMEBUF(fileName),
        %'ModuleName'%.SIZE_NAMEBUF(fileName), NULL, NULL, NULL)==ERR_OK
     )
  {
    res = %'ModuleName'%.%MakeDirectory(%'ModuleName'%.PTR_NAMEBUF(fileName), io);
  } else {
    CmdUsageError(cmd, (unsigned char*)"mkdir directoryName", io);
    res = ERR_FAILED;
  }
  %'ModuleName'%.FREE_NAMEBUF(fileName);
  return res;
}

%endif
static byte RenameCmd(const unsigned char *cmd, %'ModuleName'_ConstStdIOType *io)
{
  /* precondition: cmd starts with "rename" */
  byte res = ERR_OK;
  size_t lenRead;
  %'ModuleName'%.DEF_NAMEBUF(fileName);
  %'ModuleName'%.DEF_NAMEBUF(fileName2);

  %'ModuleName'%.INIT_NAMEBUF(fileName);
  %'ModuleName'%.INIT_NAMEBUF(fileName2);
  if (   (%@Utility@'ModuleName'%.ReadEscapedName(cmd+sizeof("rename"), %'ModuleName'%.PTR_NAMEBUF(fileName),
          %'ModuleName'%.SIZE_NAMEBUF(fileName), &lenRead, NULL, NULL)==ERR_OK)
      && *(cmd+sizeof("rename")+lenRead)==' '
      && (%@Utility@'ModuleName'%.ReadEscapedName(cmd+sizeof("rename")+lenRead+1,
          %'ModuleName'%.PTR_NAMEBUF(fileName2),
          %'ModuleName'%.SIZE_NAMEBUF(fileName2), NULL, NULL, NULL)==ERR_OK)
     )
  {
    res = %'ModuleName'%.%RenameFile((unsigned char*)%'ModuleName'%.PTR_NAMEBUF(fileName), (unsigned char*)%'ModuleName'%.PTR_NAMEBUF(fileName2), io);
  } else {
    CmdUsageError(cmd, (unsigned char*)"rename srcFileName dstFileName", io);
    res = ERR_FAILED;
  }
  %'ModuleName'%.FREE_NAMEBUF(fileName);
  %'ModuleName'%.FREE_NAMEBUF(fileName2);
  return res;
}
%if defined(PrintSector)

static byte SectorCmd(const unsigned char *cmd, %'ModuleName'_ConstStdIOType *io)
{
  /* precondition: cmd starts with "sector" */
  uint8_t res;
  uint32_t sectorNo;
  const unsigned char *p = cmd+sizeof("sector");

  res = %@Utility@'ModuleName'%.ScanDecimal32uNumber(&p, &sectorNo);
  if (res == ERR_OK) { /* format fine */
    %'ModuleName'%.%PrintSector(0, sectorNo, io);
  } else {
    CmdUsageError(cmd, (unsigned char*)"sector <number>", io);
    return ERR_FAILED;
  }
  return ERR_OK;
}
%endif %-defined(PrintSector)
%if defined(PrintFile)

static byte PrintCmd(const unsigned char *cmd, %'ModuleName'_ConstStdIOType *io)
{
  /* precondition: cmd starts with "print" */
  byte res = ERR_OK;
  %'ModuleName'%.DEF_NAMEBUF(fileName);

  %'ModuleName'%.INIT_NAMEBUF(fileName);
  if (%@Utility@'ModuleName'%.ReadEscapedName(cmd+sizeof("print"), %'ModuleName'%.PTR_NAMEBUF(fileName),
        %'ModuleName'%.SIZE_NAMEBUF(fileName), NULL, NULL, NULL)==ERR_OK
     )
  {
    res = %'ModuleName'%.%PrintFile(%'ModuleName'%.PTR_NAMEBUF(fileName), io);
  } else {
    CmdUsageError(cmd, (unsigned char*)"print fileName", io);
    res = ERR_FAILED;
  }
  %'ModuleName'%.FREE_NAMEBUF(fileName);
  return res;
}
%endif %-defined(PrintFile)
%if defined(ChangeDirectory)

static byte CdCmd(const unsigned char *cmd, %'ModuleName'_ConstStdIOType *io)
{
  /* precondition: cmd starts with "cd" */
#if %@FS@'ModuleName'%.FS_RPATH > 0
  byte res = ERR_OK;
  %'ModuleName'%.DEF_NAMEBUF(fileName);

  %'ModuleName'%.INIT_NAMEBUF(fileName);
  if (*(cmd+sizeof("cd")-1)== ' ') { /* space after "cd": read name */
    if (%@Utility@'ModuleName'%.ReadEscapedName(cmd+sizeof("cd"), %'ModuleName'%.PTR_NAMEBUF(fileName),
          %'ModuleName'%.SIZE_NAMEBUF(fileName), NULL, NULL, NULL)==ERR_OK
       )
    {
      res = %'ModuleName'%.%ChangeDirectory(%'ModuleName'%.PTR_NAMEBUF(fileName), io);
    } else {
      %'ModuleName'%.%SendStr((unsigned char*)"reading directory name failed!\r\n", io->stdErr);
      res = ERR_FAILED;
    }
  } else { /* print current directory */
#if %@FS@'ModuleName'%.FS_RPATH >= 2
    %@FS@'ModuleName'%.FRESULT fres;

    fres = %@FS@'ModuleName'%.getcwd((char*)%'ModuleName'%.PTR_NAMEBUF(fileName), %'ModuleName'%.SIZE_NAMEBUF(fileName));
    if(fres!=FR_OK) {
      FatFsFResultMsg((unsigned char*)"getcwd failed", fres, io);
      res = ERR_FAILED;
    } else {
      %'ModuleName'%.%SendStr(%'ModuleName'%.PTR_NAMEBUF(fileName), io->stdOut);
      %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
    }
#else
    %@Utility@'ModuleName'%.strcpy(%'ModuleName'%.PTR_NAMEBUF(fileName), %'ModuleName'%.SIZE_NAMEBUF(fileName), (unsigned char*)"\\"); /* use root */
#endif
  }
  %'ModuleName'%.FREE_NAMEBUF(fileName);
  return res;
#else
  (void)cmd;
  #warning "relative directories not enabled in FatFS!"
  %'ModuleName'%.%SendStr((unsigned char*)"relative directories not available in file system\r\n", io->stdErr);
  return ERR_FAILED;
#endif
}

%endif %- defined(ChangeDirectory)
%endif %-FS
%if defined(HWRTC)

static byte AddHWRTCDate(byte *buf, word bufSize)
{
  TDATE tdate;
  byte res;

  %if defined(OnRequestRTC)
  %OnRequestRTC();
  %endif
  res = %@HWRTC@'ModuleName'%.GetDate(&tdate);
  %if defined(OnReleaseRTC)
  %OnReleaseRTC();
  %endif
  if (res!=ERR_OK) {
    return ERR_FAILED;
  }
  %@Utility@'ModuleName'%.strcatNum16uFormatted(buf, bufSize, tdate.day, '0', 2);
  %@Utility@'ModuleName'%.chcat(buf, bufSize, '.');
  %@Utility@'ModuleName'%.strcatNum16uFormatted(buf, bufSize, tdate.month, '0', 2);
  %@Utility@'ModuleName'%.chcat(buf, bufSize, '.');
  %@Utility@'ModuleName'%.strcatNum16u(buf, bufSize, (uint16_t)tdate.year+2000);
  return ERR_OK;
}

static byte AddHWRTCTime(byte *buf, word bufSize)
{
  TTIME ttime;
  byte res;

  %if defined(OnRequestRTC)
  %OnRequestRTC();
  %endif
  res = %@HWRTC@'ModuleName'%.GetTime(&ttime);
  %if defined(OnReleaseRTC)
  %OnReleaseRTC();
  %endif
  if (res!=ERR_OK) {
    return ERR_FAILED;
  }
  %@Utility@'ModuleName'%.strcatNum16sFormatted(buf, bufSize, ttime.hour, '0', 2);
  %@Utility@'ModuleName'%.chcat(buf, bufSize, ':');
  %@Utility@'ModuleName'%.strcatNum16sFormatted(buf, bufSize, ttime.min, '0', 2);
  %@Utility@'ModuleName'%.chcat(buf, bufSize, ':');
  %@Utility@'ModuleName'%.strcatNum16sFormatted(buf, bufSize, ttime.sec, '0', 2);
  return ERR_OK;
}
%endif %- defined(HWRTC)
%if defined(SWRTC)

static byte AddSWRTCDate(byte *buf, word bufSize)
{
  DATEREC date;

  if (%@SWRTC@'ModuleName'%.GetDate(&date)!=ERR_OK) {
    return ERR_FAILED;
  }
  %@Utility@'ModuleName'%.strcatNum16uFormatted(buf, bufSize, date.Day, '0', 2);
  %@Utility@'ModuleName'%.chcat(buf, bufSize, '.');
  %@Utility@'ModuleName'%.strcatNum16uFormatted(buf, bufSize, date.Month, '0', 2);
  %@Utility@'ModuleName'%.chcat(buf, bufSize, '.');
  %@Utility@'ModuleName'%.strcatNum16u(buf, bufSize, date.Year);
  return ERR_OK;
}

static byte AddSWRTCTime(byte *buf, word bufSize)
{
  TIMEREC time;

  if (%@SWRTC@'ModuleName'%.GetTime(&time)!=ERR_OK) {
    return ERR_FAILED;
  }
  %@Utility@'ModuleName'%.strcatNum16sFormatted(buf, bufSize, time.Hour, '0', 2);
  %@Utility@'ModuleName'%.chcat(buf, bufSize, ':');
  %@Utility@'ModuleName'%.strcatNum16sFormatted(buf, bufSize, time.Min, '0', 2);
  %@Utility@'ModuleName'%.chcat(buf, bufSize, ':');
  %@Utility@'ModuleName'%.strcatNum16sFormatted(buf, bufSize, time.Sec, '0', 2);
  %@Utility@'ModuleName'%.chcat(buf, bufSize, ',');
  %@Utility@'ModuleName'%.strcatNum16sFormatted(buf, bufSize, time.Sec100, '0', 2);
  return ERR_OK;
}

%endif

%-
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-UNLOCKED
/* Internal method prototypes */
%-INTERNAL_LOC_METHOD_BEG SendSeparatedStrings
static void SendSeparatedStrings(const byte *strA, const byte *strB, byte tabChar, byte tabPos, %'ModuleName'_StdIO_OutErr_FctType io);
%-INTERNAL_LOC_METHOD_END SendSeparatedStrings
%-

%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendStr
%ifdef SendStr
%define! Parstr
%define! Pario
%include Common\FSShellSendStr.Inc
/*!
 * \brief Prints a string using I/O callbacks
 * \param[in] str String (zero terminated) to be printed
 * \param[in] io I/O function to be used for printing
 */
void %'ModuleName'%.%SendStr(const byte *str, %'ModuleName'_StdIO_OutErr_FctType io)
{
  while(*str!='\0') {
    io(*str++);
  }
}

%endif %- SendStr
%-BW_METHOD_END SendStr
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum32s
%ifdef SendNum32s
%define! Parval
%define! Pario
%include Common\FSShellSendNum32s.Inc
void %'ModuleName'%.%SendNum32s(long val, %'ModuleName'_StdIO_OutErr_FctType io)
{
  unsigned char buf[sizeof("-1234567890")];

  %@Utility@'ModuleName'%.Num32sToStr(buf, sizeof(buf), val);
  %'ModuleName'%.%SendStr(buf, io);
}

%endif %- SendNum32s
%-BW_METHOD_END SendNum32s
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum32u
%ifdef SendNum32u
%define! Parval
%define! Pario
%include Common\FSShellSendNum32u.Inc
void %'ModuleName'%.%SendNum32u(dword val, %'ModuleName'_StdIO_OutErr_FctType io)
{
  unsigned char buf[sizeof("1234567890")];

  %@Utility@'ModuleName'%.Num32uToStr(buf, sizeof(buf), val);
  %'ModuleName'%.%SendStr(buf, io);
}

%endif %- SendNum32u
%-BW_METHOD_END SendNum32u
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum16s
%ifdef SendNum16s
%define! Parval
%define! Pario
%include Common\FSShellSendNum16s.Inc
void %'ModuleName'%.%SendNum16s(int16_t val, %'ModuleName'_StdIO_OutErr_FctType io)
{
  unsigned char buf[sizeof("-12345")];

  %@Utility@'ModuleName'%.Num16sToStr(buf, sizeof(buf), val);
  %'ModuleName'%.%SendStr(buf, io);
}

%endif %- SendNum16s
%-BW_METHOD_END SendNum16s
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum16u
%ifdef SendNum16u
%define! Parval
%define! Pario
%include Common\FSShellSendNum16u.Inc
void %'ModuleName'%.%SendNum16u(word val, %'ModuleName'_StdIO_OutErr_FctType io)
{
  unsigned char buf[sizeof("12345")];

  %@Utility@'ModuleName'%.Num16uToStr(buf, sizeof(buf), val);
  %'ModuleName'%.%SendStr(buf, io);
}

%endif %- SendNum16u
%-BW_METHOD_END SendNum16u
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum8u
%ifdef SendNum8u
%define! Parval
%define! Pario
%include Common\FSShellSendNum8u.Inc
void %'ModuleName'%.%SendNum8u(byte val, %'ModuleName'_StdIO_OutErr_FctType io)
{
  unsigned char buf[sizeof("123")];

  %@Utility@'ModuleName'%.Num8uToStr(buf, sizeof(buf), val);
  %'ModuleName'%.%SendStr(buf, io);
}

%endif %- SendNum8u
%-BW_METHOD_END SendNum8u
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum8s
%ifdef SendNum8s
%define! Parval
%define! Pario
%include Common\FSShellSendNum8s.Inc
void %'ModuleName'%.%SendNum8s(signed char val, %'ModuleName'_StdIO_OutErr_FctType io)
{
  unsigned char buf[sizeof("-123")];

  %@Utility@'ModuleName'%.Num8sToStr(buf, sizeof(buf), val);
  %'ModuleName'%.%SendStr(buf, io);
}

%endif %- SendNum8s
%-BW_METHOD_END SendNum8s
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintDirectory
%ifdef PrintDirectory
%define! PardirName
%define! Pario
%define! RetVal
%include Common\FSShellPrintDirectory.Inc
/*!
 * \brief Prints a directory listing
 * \param[in] dirName Directory to be used
 * \param[in] io IO handler for output
 * \return Error code, ERR_OK for success.
 */
byte %'ModuleName'%.%PrintDirectory(const byte *dirName, %'ModuleName'_ConstStdIOType *io)
{
  byte res;

  res = PrintDir(dirName, io);
  if (res != ERR_OK) {
    %'ModuleName'%.%SendStr((unsigned char*)"PrintDir failed\r\n", io->stdErr);
    return res;
  }
  return ERR_OK;
}

%endif %- PrintDirectory
%-BW_METHOD_END PrintDirectory
%-************************************************************************************************************
%-BW_METHOD_BEGIN CopyFile
%ifdef CopyFile
%define! ParsrcFileName
%define! PardstFileName
%define! Pario
%define! RetVal
%include Common\FSShellCopyFile.Inc
/*!
 * \brief Copy the source file to a destination file
 * \param[in] srcFileName Source file name
 * \param[in] dstFileName Destination file name
 * \param[in] io IO handler for output
 * \return Error code, ERR_OK for success.
 */
byte %'ModuleName'%.%CopyFile(const byte *srcFileName, const byte *dstFileName, %'ModuleName'_ConstStdIOType *io)
{
#if !%@FS@'ModuleName'%.FS_READONLY
  %@FS@'ModuleName'%.FIL fsrc, fdst;  /* file objects */
  %@FS@'ModuleName'%.FRESULT fres;
  uint8_t buffer[%FileCopyBufferSize];   /* copy buffer */
  UINT br, bw;          /* file read/write counters */
  byte res =  ERR_OK;

  if (%@FS@'ModuleName'%.isWriteProtected()) {
    %'ModuleName'%.%SendStr((unsigned char*)"disk is write protected!\r\n", io->stdErr);
    return ERR_FAILED;
  }
  /* open source file */
  fres = %@FS@'ModuleName'%.open(&fsrc, (char*)srcFileName, FA_OPEN_EXISTING | FA_READ);
  if (fres != FR_OK) {
    FatFsFResultMsg((unsigned char*)"open source file failed", fres, io);
    return ERR_FAILED;
  }
  /* create destination file */
  fres = %@FS@'ModuleName'%.open(&fdst, (char*)dstFileName, FA_CREATE_ALWAYS | FA_WRITE);
  if (fres != FR_OK) {
    FatFsFResultMsg((unsigned char*)"open destination file failed", fres, io);
    return ERR_FAILED;
  }
  /* now copy source to destination */
  for (;;) {
    fres = %@FS@'ModuleName'%.read(&fsrc, buffer, sizeof(buffer), &br);
    if (fres != FR_OK) {
      FatFsFResultMsg((unsigned char*)"reading source file failed", fres, io);
      res = ERR_FAILED;
      break;
    }
    if (br == 0) { /* EOF */
      break; /* get out of loop */
    }
    fres = %@FS@'ModuleName'%.write(&fdst, buffer, br, &bw);
    if (fres != ERR_OK) {
      FatFsFResultMsg((unsigned char*)"writing destination file failed", fres, io);
      res = ERR_FAILED;
      break;
    }
    if (bw < br) {
      %'ModuleName'%.%SendStr((unsigned char*)"failed writing destination file, or disk full\r\n", io->stdErr);
      res = ERR_FAILED;
      break;
    }
  } /* for */
  /* close all files */
  fres = %@FS@'ModuleName'%.close(&fsrc);
  if (fres != FR_OK) {
    FatFsFResultMsg((unsigned char*)"closing source file failed", fres, io);
    res = ERR_FAILED;
  }
  fres = %@FS@'ModuleName'%.close(&fdst);
  if (fres != FR_OK) {
    FatFsFResultMsg((unsigned char*)"closing destination file failed", fres, io);
    res = ERR_FAILED;
  }
  return res;
#else
  (void)srcFileName; /* unused argument */
  (void)dstFileName; /* unused argument */
  %'ModuleName'%.%SendStr((unsigned char*)"File System is in Read-Only mode\r\n", io->stdErr);
  return ERR_FAILED;
#endif
}

%endif %- CopyFile
%-BW_METHOD_END CopyFile
%-************************************************************************************************************
%-BW_METHOD_BEGIN DeleteFile
%ifdef DeleteFile
%define! ParfileName
%define! Pario
%define! RetVal
%include Common\FSShellDeleteFile.Inc
/*!
 * \brief Deletes a file
 * \param[in] fileName Name of file to be deleted
 * \param[in] io IO handler for output
 * \return Error code, ERR_OK for success.
 */
byte %'ModuleName'%.%DeleteFile(const byte *fileName, %'ModuleName'_ConstStdIOType *io)
{
  %@FS@'ModuleName'%.FRESULT fres;

  if (%@FS@'ModuleName'%.isWriteProtected()) {
    %'ModuleName'%.%SendStr((unsigned char*)"disk is write protected!\r\n", io->stdErr);
    return ERR_FAILED;
  }
  fres = %@FS@'ModuleName'%.unlink((char*)fileName);
  if (fres != FR_OK) {
    FatFsFResultMsg((unsigned char*)"unlink failed", fres, io);
    return ERR_FAILED;
  }
  return ERR_OK;
}

%endif %- DeleteFile
%-BW_METHOD_END DeleteFile
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintFile
%ifdef PrintFile
%define! ParfileName
%define! Pario
%define! RetVal
%include Common\FSShellPrintFile.Inc
/*!
 * \brief Print the content of a file
 * \param[in] fileName Name of file to be printed
 * \param[in] io IO handler for output
 * \return Error code, ERR_OK for success.
 */
byte %'ModuleName'%.%PrintFile(const byte *fileName, %'ModuleName'_ConstStdIOType *io)
{
  %@FS@'ModuleName'%.FIL file;
  %@FS@'ModuleName'%.FRESULT fres;
  UINT nofRead = 0;
  byte buf[%FilePrintBufferSize];
  byte res = ERR_OK;

  fres = %@FS@'ModuleName'%.open(&file, (const TCHAR *)fileName, FA_READ);
  if (fres == FR_OK) {
    do {
      nofRead = 0;
      fres=%@FS@'ModuleName'%.read(&file, buf, sizeof(buf)-1, &nofRead); /* read one byte less for zero byte */
      if (fres != FR_OK) {
        %'ModuleName'%.%SendStr((unsigned char*)"fread failed\r\n", io->stdErr);
        res = ERR_FAILED;
      } else {
        buf[nofRead] = '\0'; /* terminate buffer */
        %'ModuleName'%.%SendStr(buf, io->stdOut);
      }
    } while(nofRead>0 && fres==FR_OK);
    fres=%@FS@'ModuleName'%.close(&file);
    if (fres != FR_OK) {
      %'ModuleName'%.%SendStr((unsigned char*)"fclose failed\r\n", io->stdErr);
      res = ERR_FAILED;
    }
  } else {
    FatFsFResultMsg((unsigned char*)"open file failed", fres, io);
    res = ERR_FAILED;
  }
  %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
  return res;
}

%endif %- PrintFile
%-BW_METHOD_END PrintFile
%-************************************************************************************************************
%-BW_METHOD_BEGIN MakeDirectory
%ifdef MakeDirectory
%define! PardirName
%define! Pario
%define! RetVal
%include Common\FSShellMakeDirectory.Inc
/*!
 * \brief Creates a new directory
 * \param[in] dirName Name of the directory to be created
 * \param[in] io IO handler for output
 * \return Error code, ERR_OK for success.
 */
byte %'ModuleName'%.%MakeDirectory(const byte *dirName, %'ModuleName'_ConstStdIOType *io)
{
  %@FS@'ModuleName'%.FRESULT fres;

  if (%@FS@'ModuleName'%.isWriteProtected()) {
    %'ModuleName'%.%SendStr((unsigned char*)"disk is write protected!\r\n", io->stdErr);
    return ERR_FAILED;
  }
  fres = %@FS@'ModuleName'%.mkdir((char*)dirName);
  if(fres!=FR_OK) {
    FatFsFResultMsg((unsigned char*)"mkdir failed", fres, io);
    return ERR_FAILED;
  }
  return ERR_OK;
}

%endif %- MakeDirectory
%-BW_METHOD_END MakeDirectory
%-************************************************************************************************************
%-BW_METHOD_BEGIN RenameFile
%ifdef RenameFile
%define! ParsrcFileName
%define! PardstFileName
%define! Pario
%define! RetVal
%include Common\FSShellRenameFile.Inc
/*!
 * \brief Renames a file
 * \param[in] srcFileName Source/existing file name
 * \param[in] dstFileName Destination/new file name
 * \param[in] io IO handler for output
 * \return Error code, ERR_OK for success.
 */
byte %'ModuleName'%.%RenameFile(const byte *srcFileName, const byte *dstFileName, %'ModuleName'_ConstStdIOType *io)
{
  %@FS@'ModuleName'%.FRESULT fres;

  if (%@FS@'ModuleName'%.isWriteProtected()) {
    %'ModuleName'%.%SendStr((unsigned char*)"disk is write protected!\r\n", io->stdErr);
    return ERR_FAILED;
  }
  fres = %@FS@'ModuleName'%.rename((char*)srcFileName, (char*)dstFileName);
  if(fres!=FR_OK) {
    FatFsFResultMsg((unsigned char*)"rename failed", fres, io);
    return ERR_FAILED;
  }
  return ERR_OK;
}

%endif %- RenameFile
%-BW_METHOD_END RenameFile
%-************************************************************************************************************
%-BW_METHOD_BEGIN MountFileSystem
%ifdef MountFileSystem
%define! ParlogicalDrive
%define! Pario
%define! ParfileSystemObject
%define! RetVal
%include Common\FSShellMountFileSystem.Inc
/*!
 * \brief Mounts the file system for a drive
 * \param[in] fileSystemObject Pointer to the file system object
 * \param[in] logicalDrive The drive number to be used
 * \param[in] io IO handler for output
 * \return Error code, ERR_OK for success.
 */
byte %'ModuleName'%.%MountFileSystem(%'ModuleName'_FATFS *fileSystemObject, byte logicalDrive, %'ModuleName'_ConstStdIOType *io)
{
  %@FS@'ModuleName'%.FRESULT fres;

  fres = %@FS@'ModuleName'%.mount(logicalDrive, fileSystemObject);
  if (fres != FR_OK) {
    FatFsFResultMsg((unsigned char*)"mount failed", fres, io);
    return ERR_FAILED;
  }
  return ERR_OK;
}

%endif %- MountFileSystem
%-BW_METHOD_END MountFileSystem
%-************************************************************************************************************
%-BW_METHOD_BEGIN UnMountFileSystem
%ifdef UnMountFileSystem
%define! ParlogicalDrive
%define! Pario
%define! RetVal
%include Common\FSShellUnMountFileSystem.Inc
/*!
 * \brief Unmounts the file system for a drive
 * \param[in] logicalDrive The drive number to be used
 * \param[in] io IO handler for output
 * \return Error code, ERR_OK for success.
 */
byte %'ModuleName'%.%UnMountFileSystem(byte logicalDrive, %'ModuleName'_ConstStdIOType *io)
{
  %@FS@'ModuleName'%.FRESULT fres;

  fres = %@FS@'ModuleName'%.mount(logicalDrive, NULL);
  if (fres != FR_OK) {
    FatFsFResultMsg((unsigned char*)"unmount failed", fres, io);
    return ERR_FAILED;
  }
  return ERR_OK;
}

%endif %- UnMountFileSystem
%-BW_METHOD_END UnMountFileSystem
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintDiskInfo
%ifdef PrintDiskInfo
%define! Pario
%define! Pardrive
%define! RetVal
%include Common\FSShellPrintDiskInfo.Inc
/*!
 * \brief Prints information about the disk
 * \param[in] drive Disk drive number, starting with zero
 * \param[in] io IO handler for output
 * \return Error code, ERR_OK for success.
 */
byte %'ModuleName'%.%PrintDiskInfo(byte drive, %'ModuleName'_ConstStdIOType *io)
{
  /* see for details:
   * http://www.retroleum.co.uk/electronics-articles/basic-mmc-card-access/
   */
  uint8_t buf[8];
  int32_t val32;
  int16_t val16;
  int8_t val8;
  uint8_t buff[64];
  uint8_t driverVersion; /* 0: SPI, 1: SDHC_LDD */

  if ((disk_initialize(drive)&STA_NOINIT)!=0) {
    %'ModuleName'%.%SendStr((unsigned char*)"disk initialize failed\r\n", io->stdErr);
    return ERR_FAILED;
  }
  if (disk_ioctl(0, MMC_GET_DRIVER_VERSION, &driverVersion)!=RES_OK) {
    %'ModuleName'%.%SendStr((unsigned char*)"failed identification of driver version\r\n", io->stdErr);
    return ERR_FAILED;
  }
  %'ModuleName'%.%SendStatusStr((unsigned char*)"Card type", (unsigned char*)"", io->stdOut);
  if (disk_ioctl(0, MMC_GET_TYPE, &val8)==RES_OK) {
    if (val8&CT_SD1) {
      %'ModuleName'%.%SendStr((unsigned char*)"SD1 ", io->stdOut);
    }
    if (val8&CT_SD2) {
      %'ModuleName'%.%SendStr((unsigned char*)"SD2 ", io->stdOut);
    }
    if (val8&CT_BLOCK) {
      %'ModuleName'%.%SendStr((unsigned char*)"BLOCK ", io->stdOut);
    }
    if (val8&CT_MMC) {
      %'ModuleName'%.%SendStr((unsigned char*)"MMC ", io->stdOut);
    }
    if (val8&CT_SDC) {
      %'ModuleName'%.%SendStr((unsigned char*)"SDC ", io->stdOut);
    }
    if (val8&CT_ATA) {
      %'ModuleName'%.%SendStr((unsigned char*)"ATA ", io->stdOut);
    }
    %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
  } else {
    %'ModuleName'%.%SendStr((unsigned char*)"ERROR\r\n", io->stdOut);
  }
  if (driverVersion==0) { /* only SPI cards implement this */
    %'ModuleName'%.%SendStatusStr((unsigned char*)"SDC version", (unsigned char*)"", io->stdOut);
    if (disk_ioctl(0, MMC_GET_SDC_VERSION, &val8)==RES_OK) {
      if (val8==1) {
        %'ModuleName'%.%SendStr((unsigned char*)"SDC ver 1.XX or MMC\r\n", io->stdOut);
      } else if (val8==2) {
        %'ModuleName'%.%SendStr((unsigned char*)"SDC ver 2.00\r\n", io->stdOut);
      } else {
        %'ModuleName'%.%SendStr((unsigned char*)"unknown\r\n", io->stdOut);
      }
    } else {
      %'ModuleName'%.%SendStr((unsigned char*)"ERROR\r\n", io->stdOut);
    }
  }
  %'ModuleName'%.%SendStatusStr((unsigned char*)"Sector count", (unsigned char*)"", io->stdOut);
  if (disk_ioctl(0, GET_SECTOR_COUNT, &val32)==RES_OK) {
    %@Utility@'ModuleName'%.Num32sToStr(buf, sizeof(buf), val32);
    %'ModuleName'%.%SendStr(buf, io->stdOut);
    %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
  } else {
    %'ModuleName'%.%SendStr((unsigned char*)"ERROR\r\n", io->stdOut);
  }
  %'ModuleName'%.%SendStatusStr((unsigned char*)"Sector size", (unsigned char*)"", io->stdOut);
  if (disk_ioctl(0, GET_SECTOR_SIZE, &val16)==RES_OK) {
    %@Utility@'ModuleName'%.Num16sToStr(buf, sizeof(buf), val16);
    %'ModuleName'%.%SendStr(buf, io->stdOut);
    %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
  } else {
    %'ModuleName'%.%SendStr((unsigned char*)"ERROR\r\n", io->stdOut);
  }
  %'ModuleName'%.%SendStatusStr((unsigned char*)"READ_BL_LEN", (unsigned char*)"", io->stdOut);
  if (disk_ioctl(0, MMC_GET_READ_BL_LEN, &val16)==RES_OK) {
    %@Utility@'ModuleName'%.Num16sToStr(buf, sizeof(buf), val16);
    %'ModuleName'%.%SendStr(buf, io->stdOut);
    %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
  } else {
    %'ModuleName'%.%SendStr((unsigned char*)"ERROR\r\n", io->stdOut);
  }
  if (driverVersion==0) { /* only SPI cards implement this */
    %'ModuleName'%.%SendStatusStr((unsigned char*)"Block size", (unsigned char*)"", io->stdOut);
    if (disk_ioctl(0, GET_BLOCK_SIZE, &val32)==RES_OK) {
      %@Utility@'ModuleName'%.Num32sToStr(buf, sizeof(buf), val32);
      %'ModuleName'%.%SendStr(buf, io->stdOut);
      %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
    } else {
      %'ModuleName'%.%SendStr((unsigned char*)"ERROR\r\n", io->stdOut);
    }
    %'ModuleName'%.%SendStatusStr((unsigned char*)"CSD", (unsigned char*)"", io->stdOut);
    if (disk_ioctl(0, MMC_GET_CSD, &buff[0])==RES_OK) {
      for(val8=0; val8<16; val8++) {
        buf[0] = '\0';
        %@Utility@'ModuleName'%.strcatNum8Hex(buf, sizeof(buf), (uint8_t)buff[val8]);
        %'ModuleName'%.%SendStr(buf, io->stdOut);
        %'ModuleName'%.%SendStr((unsigned char*)" ", io->stdOut);
      }
      %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
    } else {
      %'ModuleName'%.%SendStr((unsigned char*)"ERROR\r\n", io->stdOut);
    }
    %'ModuleName'%.%SendStatusStr((unsigned char*)"CID", (unsigned char*)"", io->stdOut);
    if (disk_ioctl(0, MMC_GET_CID, &buff[0])==RES_OK) {
      for(val8=0; val8<16; val8++) {
        buf[0] = '\0';
        %@Utility@'ModuleName'%.strcatNum8Hex(buf, sizeof(buf), (uint8_t)buff[val8]);
        %'ModuleName'%.%SendStr(buf, io->stdOut);
        %'ModuleName'%.%SendStr((unsigned char*)" ", io->stdOut);
      }
      %'ModuleName'%.%SendStr((unsigned char*)"\r\n               Manufacturer ", io->stdOut);
      for(val8=3; val8<=8; val8++) {
        io->stdOut(buff[val8]);
      }
      %'ModuleName'%.%SendStr((unsigned char*)"\r\n               Serial Number ", io->stdOut);
      buf[0] = '\0';
      %@Utility@'ModuleName'%.strcatNum32Hex(buf, sizeof(buf), (uint32_t)((buff[0xa]<<24)|(buff[0xb]<<16)|(buff[0xc]<<8)|buff[0xd]));
      %'ModuleName'%.%SendStr(buf, io->stdOut);
      %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
    } else {
      %'ModuleName'%.%SendStr((unsigned char*)"ERROR\r\n", io->stdOut);
    }
    %'ModuleName'%.%SendStatusStr((unsigned char*)"OCR", (unsigned char*)"", io->stdOut);
    if (disk_ioctl(0, MMC_GET_OCR, &buff[0])==RES_OK) {
      for(val8=0; val8<4; val8++) {
        buf[0] = '\0';
        %@Utility@'ModuleName'%.strcatNum8Hex(buf, sizeof(buf), (uint8_t)buff[val8]);
        %'ModuleName'%.%SendStr(buf, io->stdOut);
        %'ModuleName'%.%SendStr((unsigned char*)" ", io->stdOut);
      }
      %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
    } else {
      %'ModuleName'%.%SendStr((unsigned char*)"ERROR\r\n", io->stdOut);
    }
    %'ModuleName'%.%SendStatusStr((unsigned char*)"SD Status", (unsigned char*)"", io->stdOut);
    if (disk_ioctl(0, MMC_GET_SDSTAT, &buff[0])==RES_OK) {
      for(val8=0; val8<64; val8++) {
        buf[0] = '\0';
        if (val8!=0 && (val8%%16)==0) { /* new line to make things readable */
          %'ModuleName'%.%SendStr((unsigned char*)"\r\n               ", io->stdOut);
        }
        %@Utility@'ModuleName'%.strcatNum8Hex(buf, sizeof(buf), (uint8_t)buff[val8]);
       %'ModuleName'%.%SendStr(buf, io->stdOut);
       %'ModuleName'%.%SendStr((unsigned char*)" ", io->stdOut);
      }
      %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
    } else {
      %'ModuleName'%.%SendStr((unsigned char*)"ERROR\r\n", io->stdOut);
    }
  }
  if (driverVersion==1) { /* only LLD_SDHD cards implement this */
    buff[1] = sizeof(buf)-2; /* size of buffer */
    buff[0] = MMC_GET_LLD_CMD_HIGH_CAPACITY; /* cmd */
    if (disk_ioctl(0, MMC_GET_LLD_INFO, &buff[0])==RES_OK) {
      %'ModuleName'%.%SendStatusStr((unsigned char*)"High capacity", (unsigned char*)(buff[2]!=0?"yes\r\n":"no\r\n"), io->stdOut);
    }
    buff[0] = MMC_GET_LLD_CMD_HIGH_SPEED; /* cmd */
    if (disk_ioctl(0, MMC_GET_LLD_INFO, &buff[0])==RES_OK) {
      %'ModuleName'%.%SendStatusStr((unsigned char*)"High speed", (unsigned char*)(buff[2]!=0?"yes\r\n":"no\r\n"), io->stdOut);
    }
    buff[0] = MMC_GET_LLD_CMD_LOW_VOLTAGE; /* cmd */
    if (disk_ioctl(0, MMC_GET_LLD_INFO, &buff[0])==RES_OK) {
      %'ModuleName'%.%SendStatusStr((unsigned char*)"Low voltage", (unsigned char*)(buff[2]!=0?"yes\r\n":"no\r\n"), io->stdOut);
    }
    buff[0] = MMC_GET_LLD_CMD_DATA_WIDTHS; /* cmd */
    if (disk_ioctl(0, MMC_GET_LLD_INFO, &buff[0])==RES_OK) {
      %'ModuleName'%.%SendStatusStr((unsigned char*)"Data widths", (unsigned char*)"", io->stdOut);
      if (buff[2]&0x1) {
        %'ModuleName'%.%SendStr((unsigned char*)"1 ", io->stdOut);
      }
      if (buff[2]&0x2) {
        %'ModuleName'%.%SendStr((unsigned char*)"4 ", io->stdOut);
      }
      if (buff[2]&0x4) {
        %'ModuleName'%.%SendStr((unsigned char*)"8 ", io->stdOut);
      }
      %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
    }
    buff[0] = MMC_GET_LLD_CMD_OPERATIONS; /* cmd */
    if (disk_ioctl(0, MMC_GET_LLD_INFO, &buff[0])==RES_OK) {
      %'ModuleName'%.%SendStatusStr((unsigned char*)"Operations", (unsigned char*)"", io->stdOut);
      if (buff[2]&0x1) {
        %'ModuleName'%.%SendStr((unsigned char*)"BlockRead ", io->stdOut);
      }
      if (buff[2]&0x2) {
        %'ModuleName'%.%SendStr((unsigned char*)"BlockWrite ", io->stdOut);
      }
      if (buff[2]&0x4) {
        %'ModuleName'%.%SendStr((unsigned char*)"BlockErase ", io->stdOut);
      }
      if (buff[2]&0x8) {
        %'ModuleName'%.%SendStr((unsigned char*)"WriteProtect ", io->stdOut);
      }
      if (buff[2]&0x10) {
        %'ModuleName'%.%SendStr((unsigned char*)"I/O ", io->stdOut);
      }
      %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
    }
  }
  return ERR_OK;
}

%endif %- PrintDiskInfo
%-BW_METHOD_END PrintDiskInfo
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintSector
%ifdef PrintSector
%define! Pardrive
%define! Pario
%define! ParsectorNo
%define! RetVal
%include Common\FSShellPrintSector.Inc
%if defined(UseRTOSDynamicMemory) & %UseRTOSDynamicMemory='yes'
#define PRINT_BUF_SIZE   %@FS@'ModuleName'%.MAX_SS
%else
static byte print_buf[%@FS@'ModuleName'%.MAX_SS];
#define PRINT_BUF_SIZE   sizeof(print_buf)
%endif
byte %'ModuleName'%.%PrintSector(byte drive, dword sectorNo, %'ModuleName'_ConstStdIOType *io)
{
  word i;
  unsigned char buf[8];
  %@FS@'ModuleName'%.DRESULT dres;
%if defined(UseRTOSDynamicMemory) & %UseRTOSDynamicMemory='yes'
#if FRTOS_MEMORY_SCHEME==1 /* this scheme does not allow deallocation of memory */
  static unsigned char *print_buf=NULL; /* use global buffer pointer, allocated only once, and not deallocated! */
#else
  unsigned char *print_buf;
#endif
%endif

  if ((disk_initialize(drive)&STA_NOINIT)!=RES_OK) {
    %'ModuleName'%.%SendStr((unsigned char*)"disk initialize failed\r\n", io->stdErr);
    return ERR_FAILED;
  }
%if defined(UseRTOSDynamicMemory) & %UseRTOSDynamicMemory='yes'
#if FRTOS_MEMORY_SCHEME==1 /* this scheme does not allow deallocation of memory */
  if (print_buf!=NULL) { /* only if not allocated yet */
    print_buf = %@RTOS@'ModuleName'%.pvPortMalloc(PRINT_BUF_SIZE);
  }
#else
  print_buf = %@RTOS@'ModuleName'%.pvPortMalloc(PRINT_BUF_SIZE);
#endif
  if (print_buf == NULL) {
    %'ModuleName'%.%SendStr((unsigned char*)"allocating memory failed\r\n", io->stdErr);
    return ERR_FAILED;
  }
%endif
  dres = disk_read(drive, &print_buf[0], sectorNo, 1);
  if (dres==RES_OK) { /* read one sector */
    %'ModuleName'%.%SendStr((unsigned char*)"dumping disk sector: 0x", io->stdOut);
    buf[0] = '\0';
    %@Utility@'ModuleName'%.strcatNum32Hex(buf, PRINT_BUF_SIZE, sectorNo);
    %'ModuleName'%.%SendStr(buf, io->stdOut);
    for(i=0; i<PRINT_BUF_SIZE; i++) {
      if ((i%%16)==0) { /* new line to make things readable */
        %'ModuleName'%.%SendStr((unsigned char*)"\r\n0x", io->stdOut);
        buf[0] = '\0';
        %@Utility@'ModuleName'%.strcatNum16Hex(buf, PRINT_BUF_SIZE, i);
        %'ModuleName'%.%SendStr(buf, io->stdOut);
        %'ModuleName'%.%SendStr((unsigned char*)": ", io->stdOut);
      }
      buf[0] = '\0';
      %@Utility@'ModuleName'%.strcatNum8Hex(buf, PRINT_BUF_SIZE, (uint8_t)print_buf[i]);
      %'ModuleName'%.%SendStr(buf, io->stdOut);
      %'ModuleName'%.%SendStr((unsigned char*)" ", io->stdOut);
    }
    %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
  } else {
    FatFsDResultMsg((unsigned char*)"disk_read failed", dres, io);
  }
%if defined(UseRTOSDynamicMemory) & %UseRTOSDynamicMemory='yes'
#if FRTOS_MEMORY_SCHEME!=1 /* this scheme does not allow deallocation of memory */
  %@RTOS@'ModuleName'%.vPortFree(print_buf);
#endif
%endif
  if (dres==RES_OK) {
    return ERR_OK;
  } else {
    return ERR_FAILED;
  }
}

%endif %- PrintSector
%-BW_METHOD_END PrintSector
%-************************************************************************************************************
%-BW_METHOD_BEGIN ChangeDirectory
%ifdef ChangeDirectory
%define! PardirName
%define! Pario
%define! RetVal
%include Common\FSShellChangeDirectory.Inc
byte %'ModuleName'%.%ChangeDirectory(const byte *dirName, %'ModuleName'_ConstStdIOType *io)
{
#if %@FS@'ModuleName'%.FS_RPATH > 0
  %@FS@'ModuleName'%.FRESULT fres;

  if ((fres=%@FS@'ModuleName'%.chdir((char*)dirName)) != FR_OK) {
    FatFsFResultMsg((unsigned char*)"chdir failed", fres, io);
    return ERR_FAILED;
  }
  return ERR_OK;
#else
  (void)dirName;
  #warning "relative directories not enabled in FatFS!"
  %'ModuleName'%.%SendStr((unsigned char*)"cd command not available as relative directories not enable in file system\r\n", io->stdErr);
  return ERR_FAILED;
#endif
}

%endif %- ChangeDirectory
%-BW_METHOD_END ChangeDirectory
%-************************************************************************************************************
%-BW_METHOD_BEGIN Date
%ifdef Date
%if defined(SWRTC) | defined(HWRTC)
%define! Parcmd
%define! Pario
%define! RetVal
%include Common\FSShellDate.Inc
byte %'ModuleName'%.%Date(const unsigned char *cmd, %'ModuleName'_ConstStdIOType *io)
{
  /* precondition: cmd points to "date" */
  byte day, month;
  word year;
  const unsigned char *p;
  byte res = ERR_OK;

  p = cmd + sizeof("date")-1;
  if (*p==' ') { /* ok, have an argument */
    if (%@Utility@'ModuleName'%.ScanDate(&p, &day, &month, &year) == ERR_OK) { /* ok, format fine */
      %if defined(SWRTC)
      if (%@SWRTC@'ModuleName'%.SetDate(year, month, day) != ERR_OK) {
        %'ModuleName'%.%SendStr((unsigned char*)"***Failed to set date\r\n", io->stdErr);
        res = ERR_FAILED;
      } else {
      %endif
      %if defined(HWRTC)
        /* update real time clock */
        TDATE tdate;

        tdate.year = (byte)(year-2000);
        tdate.month = (byte)month;
        tdate.day = (byte)day;
        tdate.dayofweek = %@Utility@'ModuleName'%.WeekDay((word)year, (byte)month, (byte)day);
        %if defined(OnRequestRTC)
        %OnRequestRTC();
        %endif
        res = %@HWRTC@'ModuleName'%.SetDate(&tdate);
        %if defined(OnReleaseRTC)
        %OnReleaseRTC();
        %endif
        if (res != ERR_OK) {
          %'ModuleName'%.%SendStr((unsigned char*)"*** Failure setting RTC\r\n", io->stdErr);
          res = ERR_FAILED;
        }
      %endif
      %if defined(SWRTC)
      }
      %endif
    } else {
      %'ModuleName'%.%SendStr((unsigned char*)"*** error while reading command! ***", io->stdErr);
      %'ModuleName'%.%SendStr((void *)cmd, io->stdErr);
      %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdErr);
      res = ERR_FAILED;
    }
  } /* has an argument */
  /* print now current date */
  if (res==ERR_OK) {
    unsigned char buf[sizeof("SW date dd:mm:yyyy\\r\\n")];

%if defined(SWRTC)
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (unsigned char*)"SW date ");
    if (AddSWRTCDate(buf, sizeof(buf))!=ERR_OK) {
      %'ModuleName'%.%SendStr((unsigned char*)"***Failed to get SW RTC date\r\n", io->stdErr);
      res = ERR_FAILED;
    } else {
      %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)"\r\n");
      %'ModuleName'%.%SendStr(buf, io->stdOut);
    }
%endif
%if defined(HWRTC)
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (unsigned char*)"HW date ");
    if (AddHWRTCDate(buf, sizeof(buf))!=ERR_OK) {
      %'ModuleName'%.%SendStr((unsigned char*)"***Failed to get HW RTC date\r\n", io->stdErr);
      res = ERR_FAILED;
    } else {
      %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)"\r\n");
      %'ModuleName'%.%SendStr(buf, io->stdOut);
    }
%endif
  }
  return res;
}
%endif

%endif %- Date
%-BW_METHOD_END Date
%-************************************************************************************************************
%-BW_METHOD_BEGIN Time
%ifdef Time
%if defined(SWRTC) | defined(HWRTC)
%define! Parcmd
%define! Pario
%define! RetVal
%include Common\FSShellTime.Inc
byte %'ModuleName'%.%Time(const unsigned char *cmd, %'ModuleName'_ConstStdIOType *io)
{
  byte hour, minute, second, hSecond;
  const unsigned char *p;
  byte res = ERR_OK;
%if defined(HWRTC)
  TTIME ttime;
%endif

  p = cmd + sizeof("time")-1;
  if (*p==' ') { /* has an argument */
    if (%@Utility@'ModuleName'%.ScanTime(&p, &hour, &minute, &second, &hSecond)==ERR_OK) { /* format fine */
      %if defined(OnTimeSet)
      %OnTimeSet(hour, minute, second, hSecond); /* call user event */
      %endif
    %if defined(SWRTC)
      /* set SW RTC time */
      if (%@SWRTC@'ModuleName'%.SetTime((byte)hour, (byte)minute, (byte)second, hSecond) != ERR_OK) {
        %'ModuleName'%.%SendStr((unsigned char*)"***Failed to set SW RTC time\r\n", io->stdErr);
        res = ERR_FAILED;
      }
    %endif
    %if defined(HWRTC)
      /* set HW RTC time */
      ttime.hour = (byte)hour;
      ttime.min = (byte)minute;
      ttime.sec = (byte)second;
      ttime.mode = 1; /* 24h format */
      ttime.am_pm = 0;
      %if defined(OnRequestRTC)
      %OnRequestRTC();
      %endif
      res = %@HWRTC@'ModuleName'%.SetTime(&ttime);
      %if defined(OnReleaseRTC)
      %OnReleaseRTC();
      %endif
      if (res != ERR_OK) {
        %'ModuleName'%.%SendStr((unsigned char*)"*** Failure setting HW RTC time\r\n", io->stdErr);
        res = ERR_FAILED;
      }
    %endif
    } else {
      %'ModuleName'%.%SendStr((unsigned char*)"*** error while reading command: ", io->stdErr);
      %'ModuleName'%.%SendStr(cmd, io->stdErr);
      %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdErr);
      res = ERR_FAILED;
    }
  }
  /* print now current time */
  if (res==ERR_OK) {
    unsigned char buf[sizeof("SW time hh:mm:ss.hh\\r\\n")];

  %if defined(SWRTC)
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (unsigned char*)"SW time ");
    if (AddSWRTCTime(buf, sizeof(buf))!=ERR_OK) {
      %'ModuleName'%.%SendStr((unsigned char*)"***Failed to get SW RTC time\r\n", io->stdErr);
      res = ERR_FAILED;
    } else {
      %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)"\r\n");
      %'ModuleName'%.%SendStr(buf, io->stdOut);
    }
  %endif
  %if defined(HWRTC)
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (unsigned char*)"HW time ");
    if (AddHWRTCTime(buf, sizeof(buf))!=ERR_OK) {
      %'ModuleName'%.%SendStr((unsigned char*)"***Failed to get HW RTC time\r\n", io->stdErr);
      res = ERR_FAILED;
    } else {
      %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)"\r\n");
      %'ModuleName'%.%SendStr(buf, io->stdOut);
    }
  %endif
  }
  return res;
}
%endif

%endif %- Time
%-BW_METHOD_END Time
%-************************************************************************************************************
%-BW_METHOD_BEGIN ShellCmd
%ifdef ShellCmd
%define! Pario
%define! Parcmd
%define! Parhandled
%define! RetVal
%include Common\FSShellShellCmd.Inc
byte %'ModuleName'%.%ShellCmd(const unsigned char *cmd, bool *handled, %'ModuleName'_ConstStdIOType *io)
{
  if (%@Utility@'ModuleName'%.strcmp((char*)cmd, %'ModuleName'%.CMD_HELP)==0 || %@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' help")==0) {
    %'ModuleName'%.%SendStr((unsigned char*)%'ModuleName'%.DASH_LINE, io->stdOut);
    %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
    %'ModuleName'%.%SendStr((unsigned char*)"%ProjectNameStr", io->stdOut);
    %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
    %'ModuleName'%.%SendStr((unsigned char*)%'ModuleName'%.DASH_LINE, io->stdOut);
    %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
    %'ModuleName'%.%SendHelpStr((unsigned char*)"%'ModuleName'", (const unsigned char*)"Group of %'ModuleName' commands\r\n", io->stdOut);
%if defined(PrintStatus)
    %'ModuleName'%.%SendHelpStr((unsigned char*)"  help|status", (const unsigned char*)"Print help or status information\r\n", io->stdOut);
%else %- only help
    %'ModuleName'%.%SendHelpStr((unsigned char*)"  help", (const unsigned char*)"Prints help\r\n", io->stdOut);
%endif
%if defined(ChangeDirectory)
    %'ModuleName'%.%SendHelpStr((unsigned char*)"  cd [<directoryName>]", (const unsigned char*)"Change the current directory or display the name of the current directory\r\n", io->stdOut);
%endif
%if defined(PrintDirectory)
    %'ModuleName'%.%SendHelpStr((unsigned char*)"  dir [<directoryName>]", (const unsigned char*)"Prints a directory\r\n", io->stdOut);
%endif
%if defined(CopyFile)
    %'ModuleName'%.%SendHelpStr((unsigned char*)"  copy <src> <dst>", (const unsigned char*)"Copy a file\r\n", io->stdOut);
%endif
%if defined(DeleteFile)
    %'ModuleName'%.%SendHelpStr((unsigned char*)"  delete <filename>", (const unsigned char*)"Delete a file\r\n", io->stdOut);
%endif
%if defined(MakeDirectory)
    %'ModuleName'%.%SendHelpStr((unsigned char*)"  mkdir <directory>", (const unsigned char*)"Create a directory\r\n", io->stdOut);
%endif
%if defined(RenameFile)
    %'ModuleName'%.%SendHelpStr((unsigned char*)"  rename <src> <dst>", (const unsigned char*)"Rename a file\r\n", io->stdOut);
%endif
%if defined(PrintFile)
    %'ModuleName'%.%SendHelpStr((unsigned char*)"  print <filename>", (const unsigned char*)"Print a file\r\n", io->stdOut);
%endif
%if defined(PrintSector)
    %'ModuleName'%.%SendHelpStr((unsigned char*)"  sector <number>", (const unsigned char*)"Prints a disk sector\r\n", io->stdOut);
%endif
%if defined(PrintDiskInfo)
    %'ModuleName'%.%SendHelpStr((unsigned char*)"  diskinfo", (const unsigned char*)"Prints disk information\r\n", io->stdOut);
%endif
%if (defined(SWRTC) | defined(HWRTC)) & defined(Time)
    %'ModuleName'%.%SendHelpStr((unsigned char*)"  time [hh:mm:ss[,z]]", (const unsigned char*)"Set the current time. Prints the current time if no argument\r\n", io->stdOut);
%endif
%if defined(SWRTC) | defined(HWRTC) & defined(Date)
    %'ModuleName'%.%SendHelpStr((unsigned char*)"  date [dd.mm.yyyy]", (const unsigned char*)"Set the current date. Prints the current date if no argument\r\n", io->stdOut);
%endif
    *handled = TRUE;
    return ERR_OK;
%if defined(ChangeDirectory)
  } else if (%@Utility@'ModuleName'%.strncmp((char*)cmd, "cd", sizeof("cd")-1)==0) {
    *handled = TRUE;
    return CdCmd(cmd, io);
%endif
%if defined(PrintDirectory)
  } else if (%@Utility@'ModuleName'%.strncmp((char*)cmd, "dir", sizeof("dir")-1)==0) {
    *handled = TRUE;
    return DirCmd(cmd, io);
%endif
%if defined(CopyFile)
  } else if (%@Utility@'ModuleName'%.strncmp((char*)cmd, "copy", sizeof("copy")-1)==0) {
    *handled = TRUE;
    return CopyCmd(cmd, io);
%endif
%if defined(DeleteFile)
  } else if (%@Utility@'ModuleName'%.strncmp((char*)cmd, "delete", sizeof("delete")-1)==0) {
    *handled = TRUE;
    return DeleteCmd(cmd, io);
%endif
%if defined(MakeDirectory)
  } else if (%@Utility@'ModuleName'%.strncmp((char*)cmd, "mkdir", sizeof("mkdir")-1)==0) {
    *handled = TRUE;
    return MkdirCmd(cmd, io);
%endif
%if defined(RenameFile)
  } else if (%@Utility@'ModuleName'%.strncmp((char*)cmd, "rename", sizeof("rename")-1)==0) {
    *handled = TRUE;
    return RenameCmd(cmd, io);
%endif
%if defined(PrintFile)
  } else if (%@Utility@'ModuleName'%.strncmp((char*)cmd, "print", sizeof("print")-1)==0) {
    *handled = TRUE;
    return PrintCmd(cmd, io);
%endif
%if defined(PrintStatus)
  } else if ((%@Utility@'ModuleName'%.strcmp((char*)cmd, %'ModuleName'%.CMD_STATUS)==0) || (%@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' status")==0)) {
    *handled = TRUE;
    return %'ModuleName'%.%PrintStatus(io);
%endif
%if defined(PrintDiskInfo)
  } else if (%@Utility@'ModuleName'%.strcmp((char*)cmd, "diskinfo")==0) {
    *handled = TRUE;
    return %'ModuleName'%.%PrintDiskInfo(0, io);
%endif
%if defined(PrintSector)
  } else if (%@Utility@'ModuleName'%.strncmp((char*)cmd, "sector", sizeof("sector")-1)==0) {
    *handled = TRUE;
    return SectorCmd(cmd, io);
%endif
%if defined(SWRTC) | defined(HWRTC) & defined(Date)
  } else if (%@Utility@'ModuleName'%.strncmp((char*)cmd, "date", sizeof("date")-1)==0) {
    *handled = TRUE;
    return %'ModuleName'%.%Date(cmd, io);
%endif
%if defined(SWRTC) | defined(HWRTC) & defined(Time)
  } else if (%@Utility@'ModuleName'%.strncmp((char*)cmd, "time", sizeof("time")-1)==0) {
    *handled = TRUE;
    return %'ModuleName'%.%Time(cmd, io);
%endif
  }
  return ERR_OK; /* no error */
}

%endif %- ShellCmd
%-BW_METHOD_END ShellCmd
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintPrompt
%ifdef PrintPrompt
%define! Pario
%include Common\FSShellPrintPrompt.Inc
void %'ModuleName'%.%PrintPrompt(%'ModuleName'_ConstStdIOType *io)
{
  %'ModuleName'%.%SendStr((unsigned char*)%Prompt, io->stdOut);
}

%endif %- PrintPrompt
%-BW_METHOD_END PrintPrompt
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadLine
%ifdef ReadLine
%define! Parbuf
%define! ParbufSize
%define! Pario
%define! RetVal
%include Common\FSShellReadLine.Inc
bool %'ModuleName'%.%ReadLine(byte *buf, size_t bufSize, %'ModuleName'_ConstStdIOType *io)
{
  byte c;

  if (io->keyPressed()) {
    for(;;) {                                                    %>40/* while not '\r' or '\n' */
      c = '\0';                                                  %>40/* initialize character */
      io->stdIn(&c);                                             %>40/* read character */
      *buf = (byte)c;                                            %>40/* append character to the string */
      if (c=='\0') { /* nothing in rx buffer? */
        break; /* get out of loop */
      }
%if %EchoEnabled='yes'
      io->stdOut(c);                                             %>40/* echo character */
%endif
      buf++;
      bufSize--;
      if ((c=='\r') || (c=='\n')) {
        break;
      }
      if (bufSize <= 1) {                                        %>40/* buffer full */
        break;
      }
    } /* for */
    *buf = '\0';                                                 %>40/* zero terminate string */
    return TRUE;
  } else {
    return FALSE;
  }
}

%endif %- ReadLine
%-BW_METHOD_END ReadLine
%-************************************************************************************************************
%-BW_METHOD_BEGIN CheckCardPresence
%ifdef CheckCardPresence
%define! ParcardMounted
%define! Pardrive
%define! ParfileSystemObject
%define! Pario
%define! RetVal
%include Common\FSShellCheckCardPresence.Inc
byte %'ModuleName'%.%CheckCardPresence(bool *cardMounted, byte drive, %'ModuleName'_FATFS *fileSystemObject, %'ModuleName'_ConstStdIOType *io)
{
  if (!(*cardMounted) && %@FS@'ModuleName'%.isDiskPresent()) {
    /* card inserted */
    if (%'ModuleName'%.MountFileSystem(fileSystemObject, drive, io)==ERR_OK) {
      *cardMounted = TRUE;
      if (io!=NULL) {
        %'ModuleName'%.%SendStr((unsigned char*)"File System mounted\r\n", io->stdOut);
      }
    } else {
      return ERR_FAILED;
    }
  } else if (*cardMounted && !%@FS@'ModuleName'%.isDiskPresent()) {
    /* card removed */
    if (%'ModuleName'%.UnMountFileSystem(drive, io)==ERR_OK) {
      *cardMounted = FALSE;
      if (io!=NULL) {
        %'ModuleName'%.%SendStr((unsigned char*)"File System unmounted\r\n", io->stdOut);
      }
    } else {
      return ERR_FAILED;
    }
  }
  return ERR_OK;
}

%endif %- CheckCardPresence
%-BW_METHOD_END CheckCardPresence
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintStatus
%ifdef PrintStatus
%define! Pario
%define! RetVal
%include Common\FSShellPrintStatus.Inc
byte %'ModuleName'%.%PrintStatus(%'ModuleName'_ConstStdIOType *io)
{
  byte res = ERR_OK;
%if defined(SWRTC) | defined(HWRTC) | defined(RTOS)
  byte buf[16];
%endif
%if defined(RTOS)
#if configUSE_TRACE_FACILITY || configGENERATE_RUN_TIME_STATS /* FreeRTOS trace feature enabled */
#if FRTOS_MEMORY_SCHEME==1 /* this scheme does not allow deallocation of memory */
  static unsigned char *taskListBufferP=NULL; /* allocated only once, never deallocated! */
#else
  unsigned char *taskListBufferP;
#endif
  size_t bufSize;
#endif
%endif

  %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
  %'ModuleName'%.%SendStr((unsigned char*)%'ModuleName'%.DASH_LINE, io->stdOut);
  %'ModuleName'%.%SendStr((unsigned char*)"\r\nSYSTEM STATUS\r\n", io->stdOut);
  %'ModuleName'%.%SendStr((unsigned char*)%'ModuleName'%.DASH_LINE, io->stdOut);
  %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
%if defined(RTOS)
#if configUSE_TRACE_FACILITY /* FreeRTOS trace feature enabled */
  %'ModuleName'%.%SendStr((unsigned char*)"TASK LIST:\r\nName\t\tStatus\tPrio\tStack\tTCB#\r\n", io->stdOut);
  %'ModuleName'%.%SendStr((unsigned char*)%'ModuleName'%.DASH_LINE, io->stdOut);
  /* task list and status */
  bufSize = 40*uxTaskGetNumberOfTasks();  /* about 40 bytes for a task should be enough */
#if FRTOS_MEMORY_SCHEME==1 /* this scheme does not allow deallocation of memory */
  if (taskListBufferP==NULL) { /* only if not allocated yet */
    taskListBufferP = %@RTOS@'ModuleName'%.pvPortMalloc(bufSize); /* about 40 bytes for a task should be enough */
  }
#else
  taskListBufferP = %@RTOS@'ModuleName'%.pvPortMalloc(bufSize); /* about 40 bytes for a task should be enough */
#endif
  if (taskListBufferP != NULL) {
    %@RTOS@'ModuleName'%.vTaskList(taskListBufferP, bufSize);
    %'ModuleName'%.%SendStr(taskListBufferP, io->stdOut);
#if FRTOS_MEMORY_SCHEME!=1 /* this scheme does not allow deallocation of memory */
    %@RTOS@'ModuleName'%.vPortFree(taskListBufferP);
#endif
  } else {
    %'ModuleName'%.%SendStr((unsigned char*)"\r\n*** out of heap! ***\r\n", io->stdErr);
  }
#endif
#if configGENERATE_RUN_TIME_STATS
  %'ModuleName'%.%SendStr((unsigned char*)%'ModuleName'%.DASH_LINE, io->stdOut);
  %'ModuleName'%.%SendStr((unsigned char*)"\r\nRTOS RUN-TIME STATISTICS:\r\nName\tTime (ms)\t%%Time\r\n", io->stdOut);
  %'ModuleName'%.%SendStr((unsigned char*)%'ModuleName'%.DASH_LINE, io->stdOut);
  /* task list and status */
  bufSize = 40*uxTaskGetNumberOfTasks();  /* about 40 bytes for a task should be enough */
#if FRTOS_MEMORY_SCHEME==1 /* this scheme does not allow deallocation of memory */
  if (taskListBufferP==NULL) { /* only if not allocated yet */
    taskListBufferP = %@RTOS@'ModuleName'%.pvPortMalloc(bufSize);
  }
#else
  taskListBufferP = %@RTOS@'ModuleName'%.pvPortMalloc(bufSize);
#endif
  if (taskListBufferP != NULL) {
    %@RTOS@'ModuleName'%.vTaskGetRunTimeStats(taskListBufferP, bufSize);
    %'ModuleName'%.%SendStr(taskListBufferP, io->stdOut);
#if FRTOS_MEMORY_SCHEME!=1 /* this scheme does not allow deallocation of memory */
    %@RTOS@'ModuleName'%.vPortFree(taskListBufferP);
#endif
  }
#endif
  %'ModuleName'%.%SendStatusStr((unsigned char*)"RTOS ticks", (const unsigned char*)"", io->stdOut);
  %@Utility@'ModuleName'%.Num16sToStr(buf, sizeof(buf), configTICK_RATE_HZ);
  %'ModuleName'%.%SendStr(buf, io->stdOut);
  %'ModuleName'%.%SendStr((unsigned char*)" Hz, ", io->stdOut);
  %@Utility@'ModuleName'%.Num16sToStr(buf, sizeof(buf), 1000/configTICK_RATE_HZ);
  %'ModuleName'%.%SendStr(buf, io->stdOut);
  %'ModuleName'%.%SendStr((unsigned char*)" ms\r\n", io->stdOut);
  %'ModuleName'%.%SendStatusStr((unsigned char*)"Free heap", (const unsigned char*)"", io->stdOut);
  %@Utility@'ModuleName'%.Num32uToStr(buf, sizeof(buf), %@RTOS@'ModuleName'%.xPortGetFreeHeapSize());
  %'ModuleName'%.%SendStr(buf, io->stdOut);
  %'ModuleName'%.%SendStr((unsigned char*)" bytes\r\n", io->stdOut);
%endif %-defined(RTOS)
  %'ModuleName'%.%SendStatusStr((const unsigned char*)"Firmware", (const unsigned char*)__DATE__, io->stdOut);
  %'ModuleName'%.%SendStr((unsigned char*)" ", io->stdOut);
  %'ModuleName'%.%SendStr((unsigned char*)__TIME__, io->stdOut);
  %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
%if defined(SWRTC)
  %'ModuleName'%.%SendStatusStr((unsigned char*)"SW RTC", (const unsigned char*)"", io->stdOut);
  buf[0] = '\0';
  if (AddSWRTCDate(buf, sizeof(buf))!=ERR_OK) {
    %'ModuleName'%.%SendStr((unsigned char*)"***Failed to get SW RTC date! ", io->stdErr);
    res = ERR_FAILED;
  } else {
    %'ModuleName'%.%SendStr(buf, io->stdOut);
  }
  %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (unsigned char*)" ");
  if (AddSWRTCTime(buf, sizeof(buf))!=ERR_OK) {
    %'ModuleName'%.%SendStr((unsigned char*)"***Failed to get SW RTC time! ", io->stdErr);
  } else {
    %'ModuleName'%.%SendStr(buf, io->stdOut);
  }
  %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
%endif
%if defined(HWRTC)
  %'ModuleName'%.%SendStatusStr((unsigned char*)"HW RTC", (const unsigned char*)"", io->stdOut);
  buf[0] = '\0';
  if (AddHWRTCDate(buf, sizeof(buf))!=ERR_OK) {
    %'ModuleName'%.%SendStr((unsigned char*)"***Failed to get HW RTC date! ", io->stdErr);
  } else {
    %'ModuleName'%.%SendStr(buf, io->stdOut);
  }
  %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (unsigned char*)" ");
  if (AddHWRTCTime(buf, sizeof(buf))!=ERR_OK) {
    %'ModuleName'%.%SendStr((unsigned char*)"***Failed to get HW RTC time! ", io->stdErr);
  } else {
    %'ModuleName'%.%SendStr(buf, io->stdOut);
  }
  %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
%endif
%if defined(FS)
  if (%@FS@'ModuleName'%.isDiskPresent()) {
    %'ModuleName'%.%SendStatusStr((unsigned char*)"SD present", (unsigned char*)"yes\r\n", io->stdOut);
  } else {
    %'ModuleName'%.%SendStatusStr((unsigned char*)"SD present", (unsigned char*)"no\r\n", io->stdOut);
  }
  if (%@FS@'ModuleName'%.isWriteProtected()) {
    %'ModuleName'%.%SendStatusStr((unsigned char*)"SD protected", (unsigned char*)"yes\r\n", io->stdOut);
  } else {
    %'ModuleName'%.%SendStatusStr((unsigned char*)"SD protected", (unsigned char*)"no\r\n", io->stdOut);
  }
%endif
  return res;
}

%endif %- PrintStatus
%-BW_METHOD_END PrintStatus
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintCommandFailed
%ifdef PrintCommandFailed
%define! Pario
%define! Parcmd
%include Common\FSShellPrintCommandFailed.Inc
void %'ModuleName'%.%PrintCommandFailed(const unsigned char *cmd, %'ModuleName'_ConstStdIOType *io)
{
  %'ModuleName'%.%SendStr((unsigned char*)"*** Failed or unknown command: ", io->stdErr);
  %'ModuleName'%.%SendStr(cmd, io->stdErr);
  %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdErr);
  %'ModuleName'%.%SendStr((unsigned char*)"*** Type ", io->stdErr);
  %'ModuleName'%.%SendStr((unsigned char*)%'ModuleName'%.CMD_HELP, io->stdErr);
  %'ModuleName'%.%SendStr((unsigned char*)" to get a list of available commands\r\n", io->stdErr);
}

%endif %- PrintCommandFailed
%-BW_METHOD_END PrintCommandFailed
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseCommand
%ifdef ParseCommand
%define! Parcmd
%define! Pario
%define! ParparseCallback
%define! RetVal
%include Common\FSShellParseCommand.Inc
byte %'ModuleName'%.%ParseCommand(const unsigned char *cmd, %'ModuleName'_ConstStdIOType *io, %'ModuleName'_ParseCommandCallback parseCallback)
{
  byte res = ERR_OK;
  bool handled;
%if %SilentModePrefixChar<>''
  bool silent;
%endif
%if %MultiCommandEnabled='yes'
  byte buf[%MaxSubCommandStringSize];
  uint8_t i;
  bool parseBuffer, finished;
%endif

  if (*cmd=='\0') { /* empty command */
    return ERR_OK;
  }
  /* parse first shell commands */
  handled = FALSE;
%if %SilentModePrefixChar<>''
  silent = (bool)(*cmd=='%SilentModePrefixChar');
  if (silent) {
    cmd++; /* skip '#' */
  }
%endif
%if %MultiCommandEnabled='yes'
  parseBuffer = FALSE;
  finished = FALSE;
  i = 0;
  for(;;) { /* breaks */
    if (i>sizeof(buf)-2) {
      res = ERR_FAILED;
      break; /* buffer overflow */
    }
    buf[i] = *cmd;
    cmd++; i++;
    if (buf[i-1] == '%MultiCmdSeparationChar') { /* found separator */
      buf[i-1] = '\0';
      parseBuffer = TRUE;
    } else if (buf[i-1]=='\0') {
      parseBuffer = TRUE;
      finished = TRUE;
    }
    if (parseBuffer) {
      if (%'ModuleName'%.ShellCmd(buf, &handled, io)!=ERR_OK) {
        return ERR_FAILED;
      }
      /* parse application commands */
      if ((parseCallback!=NULL && parseCallback(buf, &handled, io)!=ERR_OK) || !handled) { /* call other handlers */
        %'ModuleName'%.PrintCommandFailed(buf, io);
        res = ERR_FAILED;
      }
      parseBuffer = FALSE;
      i = 0; /* restart */
    }
    if (finished) {
      break; /* get out of loop */
    }
  } /* for */
%else
  if (%'ModuleName'%.ShellCmd(cmd, &handled, io)!=ERR_OK) {
    return ERR_FAILED;
  }
  /* parse application commands */
  if ((parseCallback!=NULL && parseCallback(cmd, &handled, io)!=ERR_OK) || !handled) { /* call other handlers */
    %'ModuleName'%.PrintCommandFailed(cmd, io);
    res = ERR_FAILED;
  }
%endif
%if %SilentModePrefixChar<>''
  if (!silent) {
    %'ModuleName'%.PrintPrompt(io);
  }
%else
  %'ModuleName'%.PrintPrompt(io);
%endif
  return res;
}

%endif %- ParseCommand
%-BW_METHOD_END ParseCommand
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetStdio
%ifdef GetStdio
%define! RetVal
%include Common\FSShellGetStdio.Inc
%'ModuleName'_ConstStdIOTypePtr %'ModuleName'%.%GetStdio(void)
{
  static %'ModuleName'_ConstStdIOType %'ModuleName'%.stdio =
  {
    (%'ModuleName'_StdIO_In_FctType)%'ModuleName'_ReadChar, /* stdin */
    (%'ModuleName'_StdIO_OutErr_FctType)%'ModuleName'_SendChar, /* stdout */
    (%'ModuleName'_StdIO_OutErr_FctType)%'ModuleName'_SendChar, /* stderr */
    %'ModuleName'_KeyPressed /* if input is not empty */
  };

  return &%'ModuleName'%.stdio;
}

%endif %- GetStdio
%-BW_METHOD_END GetStdio
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadAndParseLine
%ifdef ReadAndParseLine
%define! ParcmdBuf
%define! ParcmdBufSize
%define! Pario
%define! ParparseCallback
%define! RetVal
%include Common\FSShellReadAndParseLine.Inc
byte %'ModuleName'%.%ReadAndParseLine(byte *cmdBuf, size_t cmdBufSize, %'ModuleName'_ConstStdIOType *io, %'ModuleName'_ParseCommandCallback parseCallback)
{
  byte res = ERR_OK;
  size_t len;

  /* IMPORTANT NOTE: this function *appends* to the buffer, so the buffer needs to be initialized first! */
  len = %@Utility@'ModuleName'%.strlen((const char*)cmdBuf);
  if (%'ModuleName'%.ReadLine(cmdBuf+len, cmdBufSize-len, io)) {
    len = %@Utility@'ModuleName'%.strlen((const char*)cmdBuf);   %>40/* length of buffer string */
    if (len==0) { /* error case */
      return ERR_FAILED;
    } else if (len==1 && (cmdBuf[0]=='\n' || cmdBuf[0]=='\r')) { %>40/* eat preceding newline characters */
      cmdBuf[0] = '\0';
    }
    if (len>=cmdBufSize-1) {                                     %>40/* buffer overflow? Parse what we have, will be likely return an error */
      res = %'ModuleName'%.%ParseCommand(cmdBuf, io, parseCallback);
      cmdBuf[0] = '\0'; /* start again */
      res = ERR_OVERFLOW;
    } else if (cmdBuf[len-1]=='\n' || cmdBuf[len-1]=='\r') {     %>40/* line end: parse command */
      cmdBuf[len-1] = '\0';                                      %>40/* remove line end character for parser */
      res = %'ModuleName'%.%ParseCommand(cmdBuf, io, parseCallback);
      cmdBuf[0] = '\0';                                          %>40/* start again */
    } else {
      /* continue to append to buffer */
    }
  }
  return res;
}

%endif %- ReadAndParseLine
%-BW_METHOD_END ReadAndParseLine
%-************************************************************************************************************
%-BW_METHOD_BEGIN RequestSerial
%ifdef RequestSerial
%include Common\FSShellRequestSerial.Inc
void %'ModuleName'%.%RequestSerial(void)
{
%if defined(ConsoleSempahore) & %ConsoleSempahore='yes'
  (void)%@RTOS@'ModuleName'%.xSemaphoreTakeRecursive(ShellSem, portMAX_DELAY);
%endif
}

%endif %- RequestSerial
%-BW_METHOD_END RequestSerial
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReleaseSerial
%ifdef ReleaseSerial
%include Common\FSShellReleaseSerial.Inc
void %'ModuleName'%.%ReleaseSerial(void)
{
%if defined(ConsoleSempahore) & %ConsoleSempahore='yes'
  (void)%@RTOS@'ModuleName'%.xSemaphoreGiveRecursive(ShellSem);
%endif
}

%endif %- ReleaseSerial
%-BW_METHOD_END ReleaseSerial
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetSemaphore
%ifdef GetSemaphore
%define! RetVal
%include Common\FSShellGetSemaphore.Inc
void* %'ModuleName'%.%GetSemaphore(void)
{
%if defined(ConsoleSempahore) & %ConsoleSempahore='yes'
  return ShellSem;
%else
  return NULL;
%endif
}

%endif %- GetSemaphore
%-BW_METHOD_END GetSemaphore
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG SendSeparatedStrings
%define! ParstrA
%define! ParstrB
%define! PartabChar
%define! PartabPos
%define! Pario
%include Common\GeneralInternalGlobal.inc (SendSeparatedStrings)
static void SendSeparatedStrings(const byte *strA, const byte *strB, byte tabChar, byte tabPos, %'ModuleName'_StdIO_OutErr_FctType io)
{
  /* write command part */
  while(*strA!='\0' && tabPos>0) {
    io(*strA++);
    tabPos--;
  }
  /* fill up until ';' */
  while(tabPos>0) {
    io(' ');
    tabPos--;
  }
  /* write separator */
  io(tabChar);
  io(' ');
  /* write help text */
  %'ModuleName'%.%SendStr(strB, io);
}

%-INTERNAL_METHOD_END SendSeparatedStrings
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendHelpStr
%ifdef SendHelpStr
%define! ParstrCmd
%define! Pario
%define! ParstrHelp
%include Common\FSShellSendHelpStr.Inc
void %'ModuleName'%.%SendHelpStr(const byte *strCmd, const byte *strHelp, %'ModuleName'_StdIO_OutErr_FctType io)
{
  #define HELP_SEMICOLON_POS  %HelpSemicolonPos /* position of the ';' after the command string */
  SendSeparatedStrings(strCmd, strHelp, ';', HELP_SEMICOLON_POS, io);
}

%endif %- SendHelpStr
%-BW_METHOD_END SendHelpStr
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendStatusStr
%ifdef SendStatusStr
%define! ParstrItem
%define! ParstrStatus
%define! Pario
%include Common\FSShellSendStatusStr.Inc
void %'ModuleName'%.%SendStatusStr(const byte *strItem, const byte *strStatus, %'ModuleName'_StdIO_OutErr_FctType io)
{
  #define STATUS_COLON_POS  %StatusColonPos /* position of the ':' after the item string */
  SendSeparatedStrings(strItem, strStatus, ':', STATUS_COLON_POS, io);
}

%endif %- SendStatusStr
%-BW_METHOD_END SendStatusStr
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadChar
%ifdef ReadChar
%define! Parc
%include Common\FSShellReadChar.Inc
void %'ModuleName'%.%ReadChar(byte *c)
{
%if defined(Serial) | defined(SerialLDD) | defined(USBCDC)
%if defined(ConsoleSempahore) & %ConsoleSempahore='yes'
  (void)%@RTOS@'ModuleName'%.xSemaphoreTakeRecursive(ShellSem, portMAX_DELAY);
%endif
%if defined(Serial)
  if (%@Serial@'ModuleName'%.RecvChar((uint8_t *)c) != ERR_OK) {
    /* failed to receive character: return a zero character */
    *c = '\0';
  }
%elif defined(USBCDC)
  if (%@USBCDC@'ModuleName'%.RecvChar((uint8_t *)c) != ERR_OK) {
    /* failed to receive character: return a zero character */
    *c = '\0';
  }
%elif defined(SerialLDD)
  %- %inclSUB RTOSAdap_genCriticalSectionBegin(no)
  if (%@RxBuffer@'ModuleName'%.Get(c)!=ERR_OK) {
    /* failed to receive character: return a zero character */
    *c = '\0';
  }
  %- %inclSUB RTOSAdap_genCriticalSectionEnd(no)
%endif
%if defined(ConsoleSempahore) & %ConsoleSempahore='yes'
  (void)%@RTOS@'ModuleName'%.xSemaphoreGiveRecursive(ShellSem);
%endif
%else
  *c = '\0';
  return; /* no serial component set up in properties */
%endif
}

%endif %- ReadChar
%-BW_METHOD_END ReadChar
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendChar
%ifdef SendChar
%define! Parch
%include Common\FSShellSendChar.Inc
void %'ModuleName'%.%SendChar(byte ch)
{
%if defined(Serial) | defined(SerialLDD) | defined(USBCDC)
%if defined(ConsoleSempahore) & %ConsoleSempahore='yes'
  (void)%@RTOS@'ModuleName'%.xSemaphoreTakeRecursive(ShellSem, portMAX_DELAY);
%endif
 %if defined(Serial)
  %if BlockingSend='yes'
  while (%@Serial@'ModuleName'%.SendChar((uint8_t)ch)==ERR_TXFULL){}%>40/* Send char */
  %else
  (void)%@Serial@'ModuleName'%.SendChar((uint8_t)ch);            %>40/* non blocking send */
  %endif
 %elif defined(USBCDC)
  %if BlockingSend='yes'
  while (%@USBCDC@'ModuleName'%.SendChar((uint8_t)ch)==ERR_TXFULL){}%>40/* Send char */
  %else
  (void)%@USBCDC@'ModuleName'%.SendChar((uint8_t)ch);            %>40/* non blocking send */
  %endif
 %elif defined(SerialLDD)
  %if BlockingSend='yes'
  %'ModuleName'%.SentFlag = 0;                                   %>40/* this will be set to 1 once the block has been sent */
  while(%@SerialLDD@'ModuleName'%.SendBlock(serialHandle, (LDD_TData*)&ch, 1)!=ERR_OK) {}%>40/* Send char */
  while(%'ModuleName'%.SentFlag==0) {}                           %>40/* wait until we get the green flag from the TX interrupt */
  %else
  %@SerialLDD@'ModuleName'%.SendBlock(serialHandle, (LDD_TData*)&ch, 1);%>40/* non blocking send */
  %endif
 %endif
%if defined(ConsoleSempahore) & %ConsoleSempahore='yes'
  (void)%@RTOS@'ModuleName'%.xSemaphoreGiveRecursive(ShellSem);
%endif
%else
  (void)ch;                                                      %>40/* avoid compiler warning about unused argument */
  return;                                                        %>40/* no serial component set up in properties */
%endif
}

%endif %- SendChar
%-BW_METHOD_END SendChar
%-************************************************************************************************************
%-BW_METHOD_BEGIN KeyPressed
%ifdef KeyPressed
%define! RetVal
%include Common\FSShellKeyPressed.Inc
bool %'ModuleName'%.%KeyPressed(void)
{
%if defined(Serial) | defined(SerialLDD) | defined(USBCDC)
  bool res;

%if defined(ConsoleSempahore) & %ConsoleSempahore='yes'
  (void)%@RTOS@'ModuleName'%.xSemaphoreTakeRecursive(ShellSem, portMAX_DELAY);
%endif
%if defined(Serial)
  res = (bool)((%@Serial@'ModuleName'%.GetCharsInRxBuf()==0U) ? FALSE : TRUE); /* Result number of chars in receive buffer */
%elif defined(USBCDC)
  res = (bool)((%@USBCDC@'ModuleName'%.GetCharsInRxBuf()==0U) ? FALSE : TRUE); /* Result number of chars in receive buffer */
%elif defined(SerialLDD)
  %- %inclSUB RTOSAdap_genCriticalSectionBegin(no)
  res = %@RxBuffer@'ModuleName'%.NofElements()!=0;
  %- %inclSUB RTOSAdap_genCriticalSectionEnd(no)
%endif
%if defined(ConsoleSempahore) & %ConsoleSempahore='yes'
  (void)%@RTOS@'ModuleName'%.xSemaphoreGiveRecursive(ShellSem);
%endif
  return res;
%else
  return FALSE; /* no serial component set up in properties */
%endif
}

%endif %- KeyPressed
%-BW_METHOD_END KeyPressed
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%include Common\FSShellInit.Inc
void %'ModuleName'%.%Init(void)
{
%if defined(ConsoleSempahore) & %ConsoleSempahore='yes'
  ShellSem = %@RTOS@'ModuleName'%.xSemaphoreCreateRecursiveMutex();
  if (ShellSem==NULL) { /* semaphore creation failed */
    for(;;) {} /* error, not enough memory? */
  }
%endif
%if defined(SerialLDD)
  /* initialize logical device driver */
  serialHandle = %@SerialLDD@'ModuleName'%.Init(NULL);
  /* set up to receive RX into input buffer */
  %@RxBuffer@'ModuleName'%.Init(); /* initialize RX buffer */
  /* Set up ReceiveBlock() with a single byte buffer. We will be called in OnBlockReceived() event. */
  charBuf = '\0'; /* initialize buffer character */
  while(%@SerialLDD@'ModuleName'%.ReceiveBlock(serialHandle, (LDD_TData *)&charBuf, sizeof(charBuf))!=ERR_OK) {}
%endif
%if defined(FS)
  %@FS@'ModuleName'%.Init();
%endif
}

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
%include Common\FSShellDeinit.Inc
void %'ModuleName'%.%Deinit(void)
{
%if defined(ConsoleSempahore) & %ConsoleSempahore='yes'
  %@RTOS@'ModuleName'%.vSemaphoreDelete(ShellSem);
%endif
%if defined(FS)
  %@FS@'ModuleName'%.Deinit();
%endif
%if defined(SerialLDD)
  /* de-initialize logical device driver */
  %@SerialLDD@'ModuleName'%.Deinit(serialHandle);
%endif
}

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-INHERITED_EVENT_BEGIN SerialLDD OnBlockReceived
%ifdef SerialLDD
%ifdef @SerialLDD@OnBlockReceived
%include Common\GeneralInternal.inc (OnBlockReceived)
void %@SerialLDD@OnBlockReceived(LDD_TUserData *UserDataPtr)
{
  (void)UserDataPtr; /* argument not used */
%ifdef OnBlockReceived
  %OnBlockReceived(UserDataPtr);
%endif OnBlockReceived
  %- %inclSUB RTOSAdap_genCriticalSectionBegin(no)
  (void)%@RxBuffer@'ModuleName'%.Put(charBuf); /* but received character into buffer */
  %- %inclSUB RTOSAdap_genCriticalSectionEnd(no)
  (void)%@SerialLDD@'ModuleName'%.ReceiveBlock(serialHandle, (LDD_TData *)&charBuf, sizeof(charBuf));
}

%endif %- @SerialLDD@OnBlockReceived
%endif
%-INHERITED_EVENT_END SerialLDD OnBlockReceived
%-INHERITED_EVENT_BEGIN SerialLDD OnBlockSent
%ifdef SerialLDD
%ifdef @SerialLDD@OnBlockSent
%include Common\GeneralInternal.inc (OnBlockSent)
void %@SerialLDD@OnBlockSent(LDD_TUserData *UserDataPtr)
{
  (void)UserDataPtr; /* unused argument */
%if BlockingSend='yes'
  %'ModuleName'%.SentFlag = 1; /* set flag so sender knows we have finished */
%endif
%ifdef OnBlockSent
  /* Calling inherited event */
  %OnBlockSent(UserDataPtr);
%endif OnBlockSent
}

%endif %- @SerialLDD@OnBlockSent
%endif %-ifdef SerialLDD
%-INHERITED_EVENT_END SerialLDD OnBlockSent
%-************************************************************************************************************
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_METHOD_BEGIN OnRequestRTC
%ifdef OnRequestRTC
%IMPLEMENTATION OnRequestRTC
%include Common\FSShellOnRequestRTC.Inc
void %OnRequestRTC(void)
{
  /* Write your code here ... */
}

%endif %- OnRequestRTC
%-BW_METHOD_END OnRequestRTC
%-BW_METHOD_BEGIN OnReleaseRTC
%ifdef OnReleaseRTC
%IMPLEMENTATION OnReleaseRTC
%include Common\FSShellOnReleaseRTC.Inc
void %OnReleaseRTC(void)
{
  /* Write your code here ... */
}

%endif %- OnReleaseRTC
%-BW_METHOD_END OnReleaseRTC
%-BW_METHOD_BEGIN OnTimeSet
%ifdef OnTimeSet
%IMPLEMENTATION OnTimeSet
%define! Parhour
%define! Parminute
%define! Parsecond
%define! ParhSecond
%include Common\FSShellOnTimeSet.Inc
void %OnTimeSet(byte hour, byte minute, byte second, byte hSecond)
{
  /* Write your code here ... */
}

%endif %- OnTimeSet
%-BW_METHOD_END OnTimeSet
%-BW_METHOD_BEGIN OnBlockReceived
%ifdef OnBlockReceived
%IMPLEMENTATION OnBlockReceived
%define! ParUserDataPtr
%include Common\FSShellOnBlockReceived.Inc
void %OnBlockReceived(LDD_TUserData *UserDataPtr)
{
  /* Write your code here ... */
}

%endif %- OnBlockReceived
%-BW_METHOD_END OnBlockReceived
%-BW_METHOD_BEGIN OnBlockSent
%ifdef OnBlockSent
%IMPLEMENTATION OnBlockSent
%define! ParUserDataPtr
%include Common\FSShellOnBlockSent.Inc
void %OnBlockSent(LDD_TUserData *UserDataPtr)
{
  /* Write your code here ... */
}

%endif %- OnBlockSent
%-BW_METHOD_END OnBlockSent
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
%CODE_BEGIN
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This component is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
