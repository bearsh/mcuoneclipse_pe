%-Driver generated by the Bean Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Bean Wizard
%- If you change these lines, Bean Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Erich Styger
%define DriverVersion 01.00
%define DriverDate    04.07.2008
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%define! Description_Init
%ifdef IRQ
  %ifdef @IRQ@OnInterrupt
    %define! Description_%@IRQ@OnInterrupt This event is called when an active signal edge/level has occurred. The event services the event of the inherited component and eventually invokes other events.
  %endif %- @IRQ@OnInterrupt
%endif %- IRQ
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\MC13192Settings.Inc
%define! Abstract Common\MC13192Abstract.Inc
%include Common\Header.h

%if (CPUfamily = "Kinetis")
%- #include "PE_LDD.h" /* hack for Processor Expert (e.g. in MCU10.3) and LDD: PE_LDD.h includes at the end all shared modules, causing a recursive header file include conflict */
%endif

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited beans */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"
%include sw\CommonSupport.prg
%-
%define INLINE_ME
%-

/*! defines the variable to be received by the SMAC */
typedef struct {
  byte u8MaxDataLength;   %>%CTAB /*!< maximum packet size to accept If greater packet is dropped */
  byte u8DataLength;      %>%CTAB /*!< length in bytes of the received packet */
  byte *pu8Data;          %>%CTAB /*!< where the application would like to have the received data copied into */
  byte u8Status;          %>%CTAB /*!< determine if the data indication is due to a received packet or a timeout */
} tRxPacket;

/*! variable to be transmitted by the SMAC */
typedef struct {
  byte u8DataLength; %>%CTAB /*!< number of bytes to transmit */
  byte *pu8Data;     %>%CTAB /*!< pointer to the data buffer to transmit */
} tTxPacket;

/* Modes defined for the transceiver */
#define %'ModuleName'%.IDLE_MODE               0x00    %>%CTAB /*!< Idle mode */
#define %'ModuleName'%.RX_MODE                 0x02    %>%CTAB /*!< Receive mode */
#define %'ModuleName'%.TX_MODE                 0x03    %>%CTAB /*!< Transmit mode */
#define %'ModuleName'%.PULSE_TX_MODE           0x43    %>%CTAB /*!< Pulse transmit mode */
#define %'ModuleName'%.CCA_MODE                0x01    %>%CTAB /*!< CCA mode */
#define %'ModuleName'%.RX_MODE_WTO             0x80    %>%CTAB /*!< Receive mode wto */
#define %'ModuleName'%.HIBERNATE_MODE          0x81    %>%CTAB /*!< Hibernate mode */
#define %'ModuleName'%.DOZE_MODE               0x82    %>%CTAB /*!< Doze mode */
#define %'ModuleName'%.IDLE_MODE_DOZE          0x83    %>%CTAB /*!< Idle mode doze */
#define %'ModuleName'%.IDLE_MODE_ATTN          0x84    %>%CTAB /*!< Idle mode attenuation */
#define %'ModuleName'%.TIMEOUT                 0x85    %>%CTAB /*!< Timeout */
#define %'ModuleName'%.SYSTEM_RESET_MODE       0x86    %>%CTAB /*!< Not implemented */
#define %'ModuleName'%.MC13192_RESET_MODE      0x87    %>%CTAB /*!< Not implemented */
#define %'ModuleName'%.MC13192_CONFIG_MODE     0x88    %>%CTAB /*!< Not implemented */
#define %'ModuleName'%.RESET_DELAY             0x89    %>%CTAB /*!< Set to 100ms    */

/* Test modes defined for the transceiver */
#define %'ModuleName'%.PULSE_TX_PRBS9          0x01    %>%CTAB /*!< Continuously transmit a PRBS9 pattern */
#define %'ModuleName'%.FORCE_IDLE              0x02    %>%CTAB /*!< Back to idle mode */
#define %'ModuleName'%.CONTINUOUS_RX           0x03    %>%CTAB /*!< continuous receive mode */
#define %'ModuleName'%.CONTINUOUS_TX_MOD       0x04    %>%CTAB /*!< continuously transmit a 10101010 pattern */
#define %'ModuleName'%.CONTINUOUS_TX_NOMOD     0x05    %>%CTAB /*!< continuously transmit an unmodulated CW */

#define %'ModuleName'%.MAXPACKETSIZE   126             %>%CTAB /*!< Max packet size */

#define %'ModuleName'%.MAX_POWER       100             %>%CTAB /*!< Numbers chosen arbitrarily but > 16 */
#define %'ModuleName'%.NOMINAL_POWER   0x0B            %>%CTAB /*!< Nominal power */
#define %'ModuleName'%.MIN_POWER       50              %>%CTAB /*!< Numbers chosen arbitrarily but > 16 */

#define %'ModuleName'%.SCAN_MODE_ED   0x0020
#define %'ModuleName'%.SCAN_MODE_CCA  0x0010

#define %'ModuleName'%.OVERFLOW          1             %>%CTAB /*!< Overflow */
#define %'ModuleName'%.SUCCESS         0x77            %>%CTAB /*!< Success */
#define %'ModuleName'%.INITIAL_VALUE   0x0             %>%CTAB /*!< Initial value */

extern volatile byte %'ModuleName'%.gu8RTxMode;  %>%CTAB /*!< Application can read this variable. This variable reflects the current state of the transceiver. */
extern tRxPacket *%'ModuleName'%.psDrvRxPacket;   %>%CTAB /*!< Where the packet received will be stored */

/*! Transceiver soft reset */
#define %'ModuleName'%.RESET                   0x00    %>%CTAB /*!< Reset */

/* Packet RAM */
#define %'ModuleName'%.RX_PKT                  0x01    %>%CTAB /*!< RX Packet RAM */
#define %'ModuleName'%.RX_PKT_LEN              0x2D    %>%CTAB /*!< RX Packet RAM Length [6:0] */
#define %'ModuleName'%.TX_PKT                  0x02    %>%CTAB /*!< TX Packet RAM */
#define %'ModuleName'%.TX_PKT_LEN              0x03    %>%CTAB /*!< TX Packet RAM Length */
#define %'ModuleName'%.TX_PKT_LEN_MASK         0x007F  %>%CTAB /*!< TX Packet RAM Length Mask */

/* IRQ Status Register */
#define %'ModuleName'%.IRQ_MASK                0x05    %>%CTAB /*!< IRQ Mask */
#define %'ModuleName'%.STATUS_ADDR             0x24    %>%CTAB /*!< Status bits that can cause an interrupt request when enabled */
#define %'ModuleName'%.RESIND_ADDR             0x25    %>%CTAB /*!< Reset indicator bit */
#define %'ModuleName'%.TIMER1_IRQMASK_BIT      0x0001  %>%CTAB /*!< Timer1 IRQ mask bit */

/* Mask and mode */
#define %'ModuleName'%.MODE_ADDR               0x06    %>%CTAB /*!< Control_A Register */
#define %'ModuleName'%.MODE2_ADDR              0x07    %>%CTAB /*!< Control_B Register */
#define %'ModuleName'%.LO1_COURSE_TUNE         0x8000  %>%CTAB /*!< LO1 course tune */

/* Main Timer */
#define %'ModuleName'%.TIMER_PRESCALE          0x09    %>%CTAB /*!< Timer Prescale */
#define %'ModuleName'%.TIMESTAMP_HI_ADDR       0x26    %>%CTAB /*!< Timestamp hi address */
#define %'ModuleName'%.TIMESTAMP_LO_ADDR       0x27    %>%CTAB /*!< Timestamp lo address */
#define %'ModuleName'%.TIMESTAMP_HI_MASK       0x00FF  %>%CTAB /*!< Timestamp hi mask */

/* Frequency */
#define %'ModuleName'%.XTAL_ADJ_ADDR           0x0A    %>%CTAB /*!< Xtal trim and clock rate */
#define %'ModuleName'%.CLKS_ADDR               0x0A    %>%CTAB /*!< Xtal trim and clock rate */
#define %'ModuleName'%.CLKS_16MHZ       0              %>%CTAB /*!< clko_rate of 16 MHz */
#define %'ModuleName'%.CLKS_8MHZ        1              %>%CTAB /*!< clko_rate of  8 MHz */
#define %'ModuleName'%.CLKS_4MHZ        2              %>%CTAB /*!< clko_rate of  4 MHz */
#define %'ModuleName'%.CLKS_2MHZ        3              %>%CTAB /*!< clko_rate of  2 MHz */
#define %'ModuleName'%.CLKS_1MHZ        4              %>%CTAB /*!< clko_rate of  1 MHz */
#define %'ModuleName'%.CLKS_62_5KHZ     5              %>%CTAB /*!< clko_rate of 62.5 kHz */
#define %'ModuleName'%.CLKS_32_786KHZ   6              %>%CTAB /*!< clko_rate of 32.786 kHz */
#define %'ModuleName'%.CLKS_16_393KHZ   7              %>%CTAB /*!< clko_rate of 16.393 kHz */

#define %'ModuleName'%.LO1_IDIV_ADDR           0x0F    %>%CTAB /*!< LO1 fractional-N synthesizer that sets transceiver channel freq */
#define %'ModuleName'%.LO1_NUM_ADDR            0x10    %>%CTAB /*!< Sets transceiver channel frequency */
#define %'ModuleName'%.PRESCALE_ADDR           0x09    %>%CTAB /*!< tmr_prescale[2:0] select the frequency of the base clock for the Event Timer */

/* Timer comparators */
#define %'ModuleName'%.T1_HI_ADDR              0x1B    %>%CTAB /*!< Timer1 comparator most significant 8 bits of the 24-bit compare */
#define %'ModuleName'%.T1_LO_ADDR              0x1C    %>%CTAB /*!< Timer1 comparator least significant 16 bits */
#define %'ModuleName'%.T2_HI_ADDR              0x1D    %>%CTAB /*!< Disable bit for Timer Comparator 2 and stores the most significant 8 bits */
#define %'ModuleName'%.T2_LO_ADDR              0x1E    %>%CTAB /*!< least significant 16 bits of the 24-bit compare value.*/
#define %'ModuleName'%.T3_HI_ADDR              0x1F    %>%CTAB /*!< Disable bit for Timer Comparator 3 and stores the most significant 8 bits */
#define %'ModuleName'%.T3_LO_ADDR              0x20    %>%CTAB /*!< least significant 16 bits of the 24-bit compare value.*/
#define %'ModuleName'%.T4_HI_ADDR              0x21    %>%CTAB /*!< Disable bit for Timer Comparator 4 and stores the most significant 8 bits */
#define %'ModuleName'%.T4_LO_ADDR              0x22    %>%CTAB /*!< least significant 16 bits of the 24-bit compare value.*/

/* CCA */
#define %'ModuleName'%.CCA_THRESHOLD           0x04    %>%CTAB /*!< Threshold value for Clear Channel Assessment in dB-linear format */
#define %'ModuleName'%.CCA_RESULT_ADDR         0x2D    %>%CTAB /*!< Bits 15-8 cca_final [7:0]  Average CCA energy */
#define %'ModuleName'%.FEGAIN_ADDR             0x04    %>%CTAB /*!< added to the measured value of the CCA operation */

/* TX */
#define %'ModuleName'%.PA_ENABLE_REG           0x08    %>%CTAB /*!< PA_Enable register*/
#define %'ModuleName'%.PA_ADJUST_ADDR          0x12    %>%CTAB /*!< sets the power level and drive level of the transmitter power amplifier.*/

/* GPIO */
#define %'ModuleName'%.GPIO_CONFIG             0x0B    %>%CTAB /*!< config. data direction + sets output drive strength of GPIO1 through GPIO4*/
#define %'ModuleName'%.GPIO_DATA               0x0C    %>%CTAB /*!< sets output value if GPIO configured as output + set the output drive strength of GPIO5 through GPIO7*/
#define %'ModuleName'%.GPIO_DATA_IN_REG        0x28    %>%CTAB /*!< if GPIO registers are set as input, then the values can be read from this register */
#define %'ModuleName'%.GPIO_DATA_MASK          0x003F  %>%CTAB /*!< GPIO data mask */

/* Version */
#define %'ModuleName'%.VERSION_REG             0x2C    %>%CTAB /*!< 9-bit chip version code */
#define %'ModuleName'%.VERSION_MASK            0xF800  %>%CTAB /*!< Version mask */

/******* Test registers *******/
#define %'ModuleName'%.BER_REG                 0x30    %>%CTAB /*!< Bit error rate register */
#define %'ModuleName'%.BER_MASK                0x8000  %>%CTAB /*!< Bit error rate mask */
#define %'ModuleName'%.PSM_REG                 0x31    %>%CTAB /*!< PSM register */
#define %'ModuleName'%.PSM_MASK                0x0008  %>%CTAB /*!< PSM mask */
#define %'ModuleName'%.PAEN_REG                0x08    %>%CTAB /*!< PA enable register */
#define %'ModuleName'%.PAEN_MASK               0x8000  %>%CTAB /*!< PA enable mask  */

/* Defines */
#define %'ModuleName'%.TX_IRQ_MASK             0x0040  %>%CTAB /*!< Transmit IRQ Mask */
#define %'ModuleName'%.RAMERR_IRQ_MASK         0x4000  %>%CTAB /*!< RAM add error IRQ Mask */
#define %'ModuleName'%.RX_IRQ_MASK             0x0080  %>%CTAB /*!< Receive IRQ Mask */
#define %'ModuleName'%.ATTN_IRQ_MASK           0x0400  %>%CTAB /*!< Attention IRQ Mask */
#define %'ModuleName'%.CRC_VALID_MASK          0x0001  %>%CTAB /*!< CRC valid Mask */
#define %'ModuleName'%.TIMER1_IRQ_MASK         0x0100  %>%CTAB /*!< Timer1 IRQ Mask */
#define %'ModuleName'%.XCVR_SEQ_MASK           0xFFF8  %>%CTAB /*!< Transceiver seq mask */
#define %'ModuleName'%.LO_LOCK_IRQ_MASK        0x8000  %>%CTAB /*!< Lo lock IRQ Mask */
#define %'ModuleName'%.CCA_IRQ_MASK            0x0020  %>%CTAB /*!< CCA IRQ Mask */
#define %'ModuleName'%.DOZE_IRQ_MASK           0x0200  %>%CTAB /*!< Doze IRQ Mask */
#define %'ModuleName'%.RESET_BIT_MASK          0x0080  %>%CTAB /*!< Reset bit Mask */
#define %'ModuleName'%.CCA_BIT_MASK            0x0002

#define USE_WRITE_4   0
%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-
%-BW_CUSTOM_USERTYPE_END


%-BW_DEFINITION_START
%-INHERITED_EVENT_BEGIN IRQ OnInterrupt
%ifdef @IRQ@OnInterrupt
void %@IRQ@OnInterrupt(void);

%endif %- @IRQ@OnInterrupt
%-INHERITED_EVENT_END IRQ OnInterrupt
%-************************************************************************************************************
%-BW_METHOD_BEGIN Write
%ifdef Write
void %'ModuleName'%.%Write(byte addr, word val);
%define! Paraddr
%define! Parval
%include Common\MC13192Write.Inc

%endif %- Write
%-BW_METHOD_END Write
%-************************************************************************************************************
%-BW_METHOD_BEGIN Read
%ifdef Read
word %'ModuleName'%.%Read(byte addr);
%define! Paraddr
%define! RetVal
%include Common\MC13192Read.Inc

%endif %- Read
%-BW_METHOD_END Read
%-************************************************************************************************************
%-BW_METHOD_BEGIN Read2
%ifdef Read2
word %'ModuleName'%.%Read2(byte addr);
%define! Paraddr
%define! RetVal
%include Common\MC13192Read2.Inc

%endif %- Read2
%-BW_METHOD_END Read2
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteTx
%ifdef WriteTx
void %'ModuleName'%.%WriteTx(tTxPacket *psTxPkt);
%define! ParpsTxPkt
%include Common\MC13192WriteTx.Inc

%endif %- WriteTx
%-BW_METHOD_END WriteTx
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadRx
%ifdef ReadRx
byte %'ModuleName'%.%ReadRx(tRxPacket *psRxPkt);
%define! ParpsRxPkt
%define! RetVal
%include Common\MC13192ReadRx.Inc

%endif %- ReadRx
%-BW_METHOD_END ReadRx
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG Init
void %'ModuleName'%.Init(void);
%include Common\GeneralInternal.inc (Init)

%-INTERNAL_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN RTXENDeAssert
%ifdef RTXENDeAssert
%if defined(INLINE_ME)
#define %'ModuleName'%.%RTXENDeAssert() %@RTXEN@'ModuleName'%.ClrVal();
%else
void %'ModuleName'%.%RTXENDeAssert(void);
%endif
%include Common\MC13192RTXENDeAssert.Inc

%endif %- RTXENDeAssert
%-BW_METHOD_END RTXENDeAssert
%-************************************************************************************************************
%-BW_METHOD_BEGIN RTXENAssert
%ifdef RTXENAssert
%if defined(INLINE_ME)
#define %'ModuleName'%.%RTXENAssert() %@RTXEN@'ModuleName'%.SetVal();
%else
void %'ModuleName'%.%RTXENAssert(void);
%endif
%include Common\MC13192RTXENAssert.Inc

%endif %- RTXENAssert
%-BW_METHOD_END RTXENAssert
%-************************************************************************************************************
%-BW_METHOD_BEGIN Wake
%ifdef Wake
%if defined(INLINE_ME)
#define %'ModuleName'%.%Wake() \
          %@ATTN@'ModuleName'%.ClrVal(); /* assert ATTN */ \
          %@ATTN@'ModuleName'%.SetVal(); /* deassert ATTN */
%else
void %'ModuleName'%.%Wake(void);
%endif
%include Common\MC13192Wake.Inc

%endif %- Wake
%-BW_METHOD_END Wake
%-************************************************************************************************************
%-BW_METHOD_BEGIN EnableInterrupts
%ifdef EnableInterrupts
%if defined(INLINE_ME)
#define %'ModuleName'%.%EnableInterrupts() %@IRQ@'ModuleName'%.Enable();
%else
void %'ModuleName'%.%EnableInterrupts(void);
%endif /* INLINE_ME */
%include Common\MC13192EnableInterrupts.Inc

%endif %- EnableInterrupts
%-BW_METHOD_END EnableInterrupts
%-************************************************************************************************************
%-BW_METHOD_BEGIN DisableInterrupts
%ifdef DisableInterrupts
%if defined(INLINE_ME)
#define %'ModuleName'%.%DisableInterrupts() %@IRQ@'ModuleName'%.Disable();
%else
void %'ModuleName'%.%DisableInterrupts(void);
%endif /* INLINE_ME */
%include Common\MC13192DisableInterrupts.Inc

%endif %- DisableInterrupts
%-BW_METHOD_END DisableInterrupts
%-************************************************************************************************************
%-BW_METHOD_BEGIN Restart
%ifdef Restart
void %'ModuleName'%.%Restart(void);
%include Common\MC13192Restart.Inc

%endif %- Restart
%-BW_METHOD_END Restart
%-************************************************************************************************************
%-BW_METHOD_BEGIN ContReset
%ifdef ContReset
void %'ModuleName'%.%ContReset(void);
%include Common\MC13192ContReset.Inc

%endif %- ContReset
%-BW_METHOD_END ContReset
%-************************************************************************************************************
%-BW_METHOD_BEGIN RadioInit
%ifdef RadioInit
void %'ModuleName'%.%RadioInit(void);
%include Common\MC13192RadioInit.Inc

%endif %- RadioInit
%-BW_METHOD_END RadioInit
%-************************************************************************************************************
%-BW_METHOD_BEGIN Write4
%ifdef Write4
void %'ModuleName'%.%Write4(byte addr, dword val);
%define! Paraddr
%define! Parval
%include Common\MC13192Write4.Inc

%endif %- Write4
%-BW_METHOD_END Write4
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetClockRate
%ifdef SetClockRate
byte %'ModuleName'%.%SetClockRate(byte u8Freq);
%define! Paru8Freq
%define! RetVal
%include Common\MC13192SetClockRate.Inc

%endif %- SetClockRate
%-BW_METHOD_END SetClockRate
%-************************************************************************************************************
%-BW_METHOD_BEGIN InitCommChannel
%ifdef InitCommChannel
void %'ModuleName'%.%InitCommChannel(void);
%include Common\MC13192InitCommChannel.Inc

%endif %- InitCommChannel
%-BW_METHOD_END InitCommChannel
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetRadioSPI
%ifdef GetRadioSPI
void %'ModuleName'%.%GetRadioSPI(void);
%include Common\MC13192GetRadioSPI.Inc

%endif %- GetRadioSPI
%-BW_METHOD_END GetRadioSPI
%-************************************************************************************************************
%-BW_METHOD_BEGIN LeaveRadioSPI
%ifdef LeaveRadioSPI
void %'ModuleName'%.%LeaveRadioSPI(void);
%include Common\MC13192LeaveRadioSPI.Inc

%endif %- LeaveRadioSPI
%-BW_METHOD_END LeaveRadioSPI
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_METHOD_BEGIN DataIndication
%ifdef DataIndication
%INTERFACE DataIndication
void %DataIndication(void);
%include Common\MC13192DataIndication.Inc

%endif %- DataIndication
%-BW_METHOD_END DataIndication
%-BW_METHOD_BEGIN ResetIndication
%ifdef ResetIndication
%INTERFACE ResetIndication
void %ResetIndication(void);
%include Common\MC13192ResetIndication.Inc

%endif %- ResetIndication
%-BW_METHOD_END ResetIndication
%-BW_METHOD_BEGIN OnCLKO
%ifdef OnCLKO
%INTERFACE OnCLKO
void %OnCLKO(byte freq);
%define! Parfreq
%include Common\MC13192OnCLKO.Inc

%endif %- OnCLKO
%-BW_METHOD_END OnCLKO
%-BW_METHOD_BEGIN OnGetRadioSPI
%ifdef OnGetRadioSPI
%INTERFACE OnGetRadioSPI
void %OnGetRadioSPI(void);
%include Common\MC13192OnGetRadioSPI.Inc

%endif %- OnGetRadioSPI
%-BW_METHOD_END OnGetRadioSPI
%-BW_METHOD_BEGIN OnLeaveRadioSPI
%ifdef OnLeaveRadioSPI
%INTERFACE OnLeaveRadioSPI
void %OnLeaveRadioSPI(void);
%include Common\MC13192OnLeaveRadioSPI.Inc

%endif %- OnLeaveRadioSPI
%-BW_METHOD_END OnLeaveRadioSPI
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\MC13192Settings.Inc
%define! Abstract Common\MC13192Abstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
%if (CPUfamily = "Kinetis")
#define %'ModuleName'_CPU_IS_LITTLE_ENDIAN 1 /* Cpu %CPUfamily is little endian */
%else
#define %'ModuleName'_CPU_IS_LITTLE_ENDIAN 0 /* Cpu %CPUfamily is big endian */
%endif

/* macros to deal with the IRQ pin, as configured in the component properties */
#if 1
%for i from IRQMacrosList
%i
%endfor
#else /* default implementation, as it should be in the component properties */

/* setting up the IRQ line from the modem:
* - pull up the signal
* - trigger on low level and/or falling edge
*/
#ifdef __HCS08__
  /* Macros for the HCS08 core, using the IRQ pin */
  #define IRQACK()        IRQSC |= IRQSC_IRQACK_MASK   /*!< IRQ acknowledge */
#else /* not HCS08 */
  /* %CPUfamily family */
  #if defined(__GNUC__)  /* Kinetis? using PTD2 below */
    #define IRQINIT() \
      PORT_PDD_SetPinPullSelect(PORTD_BASE_PTR, 2, PORT_PDD_PULL_UP); \
      PORT_PDD_SetPinPullEnable(PORTD_BASE_PTR, 2, PORT_PDD_PULL_ENABLE);
    #define IRQACK()   PORT_PDD_ClearPinInterruptFlag(PORTD_BASE_PTR, 2) /* ack the interrupt */
  #elif 0 /* Macros for the MCF52259 using the IRQ on IRQ5 */
    #define IRQACK()  (EPFR = IRQ1_PIN_MASK)
  #else  /* Macros for the MCF51CN128 using the IRQ on PTE4 */
    #define IRQACK()        KBI2SC_KBACK=1     /*!< IRQ acknowledge */
  #endif
#endif
#endif
%- PORT_PDD_SetPinPullSelect(%@IRQ@'InheritedComponent'%.PRPH_BASE_ADDRESS, %@IRQ@'InheritedComponent'%.PIN_INDEX, PORT_PDD_PULL_UP); \

#ifndef IRQINIT
  #define IRQINIT()       %>%CTAB /* assume it is configured in the IRQ properties or by user macro for falling edge */
#endif

#define SPI_GET_DEVICE() \
    %'ModuleName'%.DisableInterrupts();  %>%CTAB /* Necessary to prevent double SPI access during transceiver interrupt */ \
  %if defined(GetRadioSPI)
    %'ModuleName'%.%GetRadioSPI();       %>%CTAB /* call user handler to allow bus sharing */ \
  %endif
    %@CE@'ModuleName'%.ClrVal();               %>%CTAB /* Enables transceiver SPI */

#define SPI_LEAVE_DEVICE() \
    %@CE@'ModuleName'%.SetVal();               %>%CTAB /* Disables Transceiver SPI */ \
  %if defined(LeaveRadioSPI)
    %'ModuleName'%.%LeaveRadioSPI();     %>%CTAB/* call user handler to allow bus sharing */ \
  %endif
    %'ModuleName'%.EnableInterrupts();   %>%CTAB /* Restore transceiver interrupt status */

volatile byte %'ModuleName'%.gu8RTxMode;       %>%CTAB /*!< Needed for SMAC, application can read this variable */
tRxPacket *%'ModuleName'%.psDrvRxPacket;       %>%CTAB /*!< Where the packet received will be stored */

%ifdef COMPILER_HIX
#pragma MESSAGE DISABLE C4000 /* condition always true */
#pragma MESSAGE DISABLE C4001 /* condition always false */
#pragma MESSAGE DISABLE C5909 /* assignment in condition, might happen with SWSPI */
%endif

%------------------------------------------------------------------------------------------
%if SWSPI_Enabled='yes'
static byte SPI_WriteDummy_Read(void) {
  byte ch;

  while (%@SWSPI@'ModuleName'%.CharsInTxBuf()!=0) {} /* wait until tx is empty */
  while (%@SWSPI@'ModuleName'%.SendChar(0)!=ERR_OK) {} /* send character */
  while (%@SWSPI@'ModuleName'%.CharsInTxBuf()!=0) {} /* wait until data has been sent */
  while (%@SWSPI@'ModuleName'%.CharsInRxBuf()==0) {} /* wait until we receive data */
  while (%@SWSPI@'ModuleName'%.RecvChar(&ch)!=ERR_OK) {} /* get data */
  return ch;
}

static void SPI_Write_ReadDummy(byte val) {
  while (%@SWSPI@'ModuleName'%.CharsInTxBuf()!=0) {} /* wait until tx is empty */
  while (%@SWSPI@'ModuleName'%.SendChar(val)!=ERR_OK) {} /* send the value to the bus */
  while (%@SWSPI@'ModuleName'%.CharsInTxBuf()!=0) {} /* wait until data has been sent */
  while (%@SWSPI@'ModuleName'%.CharsInRxBuf()==0) {} /* wait until we receive data */
  while (%@SWSPI@'ModuleName'%.RecvChar(&val)!=ERR_OK) {} /* get data, but throw it away */
}
%------------------------------------------------------------------------------------------
%elif HWSPI_Enabled='yes'
static byte SPI_WriteDummy_Read(void) {
  byte ch;

  while (%@HWSPI@'ModuleName'%.GetCharsInTxBuf()!=0) {} /* wait until tx is empty */
  while (%@HWSPI@'ModuleName'%.SendChar(0)!=ERR_OK) {} /* send character */
  while (%@HWSPI@'ModuleName'%.GetCharsInTxBuf()!=0) {} /* wait until data has been sent */
  while (%@HWSPI@'ModuleName'%.GetCharsInRxBuf()==0) {} /* wait until we receive data */
  while (%@HWSPI@'ModuleName'%.RecvChar(&ch)!=ERR_OK) {} /* get data */
  return ch;
}

static void SPI_Write_ReadDummy(byte val) {
  while (%@HWSPI@'ModuleName'%.GetCharsInTxBuf()!=0) {} /* wait until tx is empty */
  while (%@HWSPI@'ModuleName'%.SendChar(val)!=ERR_OK) {} /* send the value to the bus */
  while (%@HWSPI@'ModuleName'%.GetCharsInTxBuf()!=0) {} /* wait until data has been sent */
  while (%@HWSPI@'ModuleName'%.GetCharsInRxBuf()==0) {} /* wait until we receive data */
  while (%@HWSPI@'ModuleName'%.RecvChar(&val)!=ERR_OK) {} /* get data, but throw it away */
}
%------------------------------------------------------------------------------------------
%else
  #error "no SPI method selected in component properties"
%endif
%------------------------------------------------------------------------------------------
%-
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-INHERITED_EVENT_BEGIN IRQ OnInterrupt
%ifdef @IRQ@OnInterrupt
%include Common\GeneralInternal.inc (OnInterrupt)
void %@IRQ@OnInterrupt(void)
{
  word u16StatusContent, u16Reg, u16Temp; /* Result of the status register read */
  /* Data length for the RX packet */
  byte u8DataLength = 0;
  byte u8MinLen = 0;

  u16StatusContent = %'ModuleName'%.%Read(%'ModuleName'%.STATUS_ADDR); %>%CTAB /* Read the Transceiver status register. */
  if (%@IRQ@'ModuleName'%.GetVal()==0) {               %>%CTAB /* Test for IRQ low: glitch or possible fast double IRQ. */
    IRQACK();                                    %>%CTAB /* Acknowledge the interrupt. Transceiver IRQ pin still low. */
    u16Reg = %'ModuleName'%.%Read(%'ModuleName'%.STATUS_ADDR);         %>%CTAB /* Read the Transceiver status register. */
    u16StatusContent |= u16Reg;                         %>%CTAB /* Actual status is the OR of both. */
  }
  if (PHY_PROMISCUOUS_MODE) {
    u8MinLen = 3;
  } else {
    u8MinLen = 5;
  }
  u16StatusContent &= %'ModuleName'%.TX_IRQ_MASK | %'ModuleName'%.RX_IRQ_MASK | %'ModuleName'%.ATTN_IRQ_MASK |
                        %'ModuleName'%.CRC_VALID_MASK | %'ModuleName'%.TIMER1_IRQ_MASK | %'ModuleName'%.CCA_IRQ_MASK |
                        %'ModuleName'%.LO_LOCK_IRQ_MASK | %'ModuleName'%.DOZE_IRQ_MASK | %'ModuleName'%.CCA_BIT_MASK;
  if (%'ModuleName'%.gu8RTxMode != %'ModuleName'%.RX_MODE_WTO) {
    /* If timeout not being used, mask out timer. */
    u16StatusContent &= ~(%'ModuleName'%.TIMER1_IRQ_MASK);
  }
  if ((u16StatusContent & ~(%'ModuleName'%.CRC_VALID_MASK)) == 0) {
    /* If no status bits are set just return. */
    return;
  }
  /* DOZE Complete Interrupt */
  if ((u16StatusContent & %'ModuleName'%.DOZE_IRQ_MASK) != 0) {
    %'ModuleName'%.%Write(%'ModuleName'%.T2_HI_ADDR, 0x8000); %>%CTAB /* disable the timer2 */
    u16Temp= %'ModuleName'%.%Read(%'ModuleName'%.MODE2_ADDR);
    u16Temp &= 0xFFFC;
    %'ModuleName'%.%Write(%'ModuleName'%.MODE2_ADDR, u16Temp); %>%CTAB /* disable doze/hibernate modes */
    %'ModuleName'%.gu8RTxMode = %'ModuleName'%.IDLE_MODE;
  }
  /* ATTN IRQ Handler*/
  if ((u16StatusContent & %'ModuleName'%.ATTN_IRQ_MASK) != 0) {
    /* If attn interrupt, set the rtx_state mirror.
     * For MC13192 V2.x devices, read the reset indication in R25/7 first.
     * If a reset is indicated, call back to a reset handler.
     */
    u16StatusContent = %'ModuleName'%.%Read(%'ModuleName'%.RESIND_ADDR); %>%CTAB /* Read the Transceiver reset indicator register. */
    u16StatusContent &= %'ModuleName'%.RESET_BIT_MASK;
    if (u16StatusContent == 0) {                          %>%CTAB /* Reset */
      %'ModuleName'%.gu8RTxMode = %'ModuleName'%.MC13192_RESET_MODE;     %>%CTAB /* Set the rtx_state mirror to idle with attn. */
      %ResetIndication();                                 %>%CTAB /* Call reset handler */
      return;
    } else {
      %'ModuleName'%.gu8RTxMode = %'ModuleName'%.IDLE_MODE_ATTN;         %>%CTAB /* Set the rtx_state mirror to idle with attn. */
      return;
    }
  }
  /* TIMER1 IRQ Handler (Used for receiver timeout notification) */
  if ((u16StatusContent & %'ModuleName'%.TIMER1_IRQ_MASK) != 0) {
    /* If timeout occurs (and timeout enabled), update mode mirror state. */
    if (%'ModuleName'%.gu8RTxMode == %'ModuleName'%.RX_MODE_WTO) {
      /* Clear Timer1 if in RX_MODE_WTO */
#if USE_WRITE_4
      %'ModuleName'%.%Write4(%'ModuleName'%.T1_HI_ADDR, 0x00008000);  %>%CTAB /* Disables TC1 and clears IRQ */
#else
      %'ModuleName'%.%Write(%'ModuleName'%.T1_HI_ADDR, 0x8000);  %>%CTAB /* Disables TC1 and clears IRQ */
      %'ModuleName'%.%Write(%'ModuleName'%.T1_LO_ADDR, 0x0000);
#endif
      %'ModuleName'%.psDrvRxPacket->u8Status = %'ModuleName'%.TIMEOUT;
      %'ModuleName'%.RTXENDeAssert();             %>%CTAB /* Forces the Transceiver to idle. */
      %'ModuleName'%.gu8RTxMode = %'ModuleName'%.IDLE_MODE;
      %DataIndication();                          %>%CTAB /* TIMEOUT notification */
      return;
    }
  }
  /* LO LOCK IRQ - Occurs when Transceiver loses LOCK */
  /* For receive cycles, re-enable. For transmit/CCA, abort. */
  if ((u16StatusContent & %'ModuleName'%.LO_LOCK_IRQ_MASK) != 0) {
    %'ModuleName'%.RTXENDeAssert();              %>%CTAB /* Forces the Transceiver to idle. */
    /* Unlock from receive cycles */
    if ((%'ModuleName'%.gu8RTxMode == %'ModuleName'%.RX_MODE) || (%'ModuleName'%.gu8RTxMode == %'ModuleName'%.RX_MODE_WTO) ||
        (%'ModuleName'%.gu8RTxMode == %'ModuleName'%.CCA_MODE) || (%'ModuleName'%.gu8RTxMode == %'ModuleName'%.PULSE_TX_MODE)) {
      /* Read the Transceiver trx register. Timer trigger off. */
      u16StatusContent = (word)(%'ModuleName'%.%Read(%'ModuleName'%.MODE_ADDR) & 0xFF7F);
      %'ModuleName'%.%Write(%'ModuleName'%.MODE_ADDR, u16StatusContent);   %>%CTAB /* Re-write the trx register. */
      %'ModuleName'%.RTXENAssert();                         %>%CTAB /* Re-start the sequence. */
    } else {
      %'ModuleName'%.gu8RTxMode = %'ModuleName'%.IDLE_MODE;
    }
    return;
  }
  if (   (%'ModuleName'%.gu8RTxMode == %'ModuleName'%.IDLE_MODE) || ((u16StatusContent & %'ModuleName'%.CCA_IRQ_MASK) != 0)
      || ((u16StatusContent & %'ModuleName'%.TX_IRQ_MASK) != 0)
     )
  {
    /* If in idle mode already or if CCA or TX is done, just return. */
    %'ModuleName'%.RTXENDeAssert();            %>%CTAB  /* Forces the Transceiver to idle. */
    /* Check for Pulse TX Mode for PRBS9 Test mode sequence */
    if (%'ModuleName'%.gu8RTxMode == %'ModuleName'%.PULSE_TX_MODE) {
      u16StatusContent = (word)(%'ModuleName'%.%Read(%'ModuleName'%.MODE_ADDR) & 0xFF7F); %>%CTAB /* Read the Transceiver trx register. Timer trigger off. */
      %'ModuleName'%.%Write(%'ModuleName'%.MODE_ADDR, u16StatusContent); %>%CTAB /* Re-write the trx register. */
      %'ModuleName'%.RTXENAssert();   %>%CTAB /* Re-start the sequence. */
      #if defined (PA)
      MC13192_PA_CTRL = PA_OFF;       %>%CTAB /* Turn off the PA when TX is complete */
      #endif
      return;
    }
    %'ModuleName'%.gu8RTxMode = %'ModuleName'%.IDLE_MODE;
    return;
  }
  /* If rx is done */
  if ((u16StatusContent & %'ModuleName'%.RX_IRQ_MASK) != 0) {
    %'ModuleName'%.RTXENDeAssert();            %>%CTAB /* Forces the Transceiver to idle. */
    if (((u16StatusContent & %'ModuleName'%.CRC_VALID_MASK) == 0) && (!PHY_PROMISCUOUS_MODE)) {
      /* If an invalid CRC, restart receiver. */
      /* Read the Transceiver trx register. Timer trigger off. */
      u16StatusContent = (word)(%'ModuleName'%.%Read(%'ModuleName'%.MODE_ADDR) & 0xFF7F);
      /* Update the trx register */
      %'ModuleName'%.%Write(%'ModuleName'%.MODE_ADDR, u16StatusContent);
      %'ModuleName'%.RTXENAssert();        %>%CTAB /* Forces the Transceiver to enter the receive mode. */
      return;
    } else {
      /* Read received packet length register and mask off length bits */
      u8DataLength = (byte) (%'ModuleName'%.%Read(%'ModuleName'%.RX_PKT_LEN) & 0x7F);
      if (u8DataLength < u8MinLen) { %>%CTAB  /* Rx_pkt_length is bad when <5 because of CRC and byte codes. */
        /* Read the Transceiver trx register. Timer trigger off. */
        u16StatusContent = (word)(%'ModuleName'%.%Read(%'ModuleName'%.MODE_ADDR) & 0xFF7F);
        /* Update the trx register. */
        %'ModuleName'%.%Write(%'ModuleName'%.MODE_ADDR, u16StatusContent);
        /* Forces the Transceiver to enter the receive mode. */
        %'ModuleName'%.RTXENAssert();
        return;
      }
      /* Test the Byte Codes */
      if (!PHY_PROMISCUOUS_MODE) {
        u16Temp = %'ModuleName'%.%Read2(%'ModuleName'%.RX_PKT); %>%CTAB  /* Get the code bytes */
        if (u16Temp != 0xFF7E) {
          /* Read the Transceiver trx register. Timer trigger off. */
          u16StatusContent = (word)(%'ModuleName'%.%Read(%'ModuleName'%.MODE_ADDR) & 0xFF7F);
          /* Update the trx register. */
          %'ModuleName'%.%Write(%'ModuleName'%.MODE_ADDR, u16StatusContent);
          /* Forces the Transceiver to enter the receive mode. */
          %'ModuleName'%.RTXENAssert();
          return;
        }
      }
      /* A valid packet has been received. */
      %'ModuleName'%.gu8RTxMode = %'ModuleName'%.IDLE_MODE;                     %>%CTAB /* Set the rtx_state to idle */
#if USE_WRITE_4
      %'ModuleName'%.%Write4(%'ModuleName'%.T1_HI_ADDR, 0x00008000);  %>%CTAB /* Disables TC1 and clears the IRQ. */
#else
      %'ModuleName'%.%Write(%'ModuleName'%.T1_HI_ADDR, 0x8000);  %>%CTAB /* Disables TC1 and clears the IRQ. */
      %'ModuleName'%.%Write(%'ModuleName'%.T1_LO_ADDR, 0x0000);
#endif
      %'ModuleName'%.psDrvRxPacket->u8DataLength = u8DataLength;
      %'ModuleName'%.psDrvRxPacket->u8Status = %'ModuleName'%.SUCCESS;
      %DataIndication();                          %>%CTAB /* Notify PHY that there is data available. */
      return;
    }
  }
}

%endif %- @IRQ@OnInterrupt
%-INHERITED_EVENT_END IRQ OnInterrupt
%-************************************************************************************************************
%-BW_METHOD_BEGIN Write
%ifdef Write
%define! Paraddr
%define! Parval
%include Common\MC13192Write.Inc
/*!
 * \brief %'ModuleName'%.%Write: Write 1 word to SPI
 * \param[in] addr - SPI address
 * \param[in] val - Data to send
 */
void %'ModuleName'%.%Write(byte addr, word val)
{
  SPI_GET_DEVICE();   %>%CTAB /* prevent concurrent access to device */
  SPI_Write_ReadDummy((byte)(addr&0x3F)); %>%CTAB /* Write Mask address, 6bit addr. Set write bit (i.e. 0) */
  SPI_Write_ReadDummy((byte)(val>>8));    %>%CTAB /* Write MSB */
  SPI_Write_ReadDummy((byte)(val&0xFF));  %>%CTAB /* Write LSB */
  SPI_LEAVE_DEVICE();   %>%CTAB /* release device */
}

%endif %- Write
%-BW_METHOD_END Write
%-************************************************************************************************************
%-BW_METHOD_BEGIN Write4
%ifdef Write4
%define! Paraddr
%define! Parval
%include Common\MC13192Write4.Inc
void %'ModuleName'%.%Write4(byte addr, dword val)
{
  SPI_GET_DEVICE();   %>%CTAB /* prevent concurrent access to device */
  SPI_Write_ReadDummy((byte)(addr&0x3F)); %>%CTAB /* Write Mask address, 6bit addr. Set write bit (i.e. 0) */
  SPI_Write_ReadDummy((byte)(val>>8));    %>%CTAB /* Write MSB */
  SPI_Write_ReadDummy((byte)(val&0xFF));  %>%CTAB /* Write LSB */
  SPI_Write_ReadDummy((byte)(val>>16));    %>%CTAB /* Write MSB */
  SPI_Write_ReadDummy((byte)((val>>16)&0xFF));  %>%CTAB /* Write LSB */
  SPI_LEAVE_DEVICE();   %>%CTAB /* release device */
}

%endif %- Write4
%-BW_METHOD_END Write4
%-************************************************************************************************************
%-BW_METHOD_BEGIN Read
%ifdef Read
%define! Paraddr
%define! RetVal
%include Common\MC13192Read.Inc
/*!
 * \brief %'ModuleName'%.%Read: Read 1 word from SPI
 * \param addr - SPI address
 * \return u16Data - u16Data[0] is the MSB, u16Data[1] is the LSB
 */
word %'ModuleName'%.%Read(byte addr)
{
  word data;                              %>%CTAB /* u16Data[0] is MSB, u16Data[1] is LSB */

  SPI_GET_DEVICE();   %>%CTAB /* prevent concurrent access to device */
  SPI_Write_ReadDummy((byte)((addr&0x3F)|0x80));  %>%CTAB /* Mask address, 6bit addr. Set read bit. */
#if %'ModuleName'_CPU_IS_LITTLE_ENDIAN
  ((byte*)&data)[1] = SPI_WriteDummy_Read();      %>%CTAB /* MSB */
  ((byte*)&data)[0] = SPI_WriteDummy_Read();      %>%CTAB /* LSB */
#else
  ((byte*)&data)[0] = SPI_WriteDummy_Read();      %>%CTAB /* MSB */
  ((byte*)&data)[1] = SPI_WriteDummy_Read();      %>%CTAB /* LSB */
#endif
  SPI_LEAVE_DEVICE();   %>%CTAB /* release device */
  return data;
}

%endif %- Read
%-BW_METHOD_END Read
%-************************************************************************************************************
%-BW_METHOD_BEGIN Read2
%ifdef Read2
%define! Paraddr
%define! RetVal
%include Common\MC13192Read2.Inc
/*!
 * \brief SPIDrvRead2 : Read the second word from SPI
 * \param addr - SPI address
 * \return u16Data -  u16Data[0] is the MSB, u16Data[1] is the LSB
 */
word %'ModuleName'%.%Read2(byte addr)
{
  word data;

  SPI_GET_DEVICE();   %>%CTAB /* prevent concurrent access to device */
  SPI_Write_ReadDummy((byte)((addr&0x3F)|0x80)); %>%CTAB /* Mask address, 6bit addr. Set read bit. */
  SPI_Write_ReadDummy(0);                        %>%CTAB /* Dummy write. Receive register of SPI will contain MSB */
  SPI_Write_ReadDummy(0);                        %>%CTAB /* Dummy write. Waiting until after reading received data insures no overrun */
#if %'ModuleName'_CPU_IS_LITTLE_ENDIAN
  ((byte*)&data)[1] = SPI_WriteDummy_Read();     %>%CTAB /* MSB */
  ((byte*)&data)[0] = SPI_WriteDummy_Read();     %>%CTAB /* LSB */
#else
  ((byte*)&data)[0] = SPI_WriteDummy_Read();     %>%CTAB /* MSB */
  ((byte*)&data)[1] = SPI_WriteDummy_Read();     %>%CTAB /* LSB */
#endif
  SPI_LEAVE_DEVICE();   %>%CTAB /* release device */
  return data;
}

%endif %- Read2
%-BW_METHOD_END Read2
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteTx
%ifdef WriteTx
%define! ParpsTxPkt
%include Common\MC13192WriteTx.Inc
void %'ModuleName'%.%WriteTx(tTxPacket *psTxPkt)
{
  byte i, u8TempByte=0;   %>%CTAB /* Temporary counters */
  byte u8MinLen=0;
  word u16Reg=0;          %>%CTAB /* TX packet length register value */

  if (PHY_PROMISCUOUS_MODE) {
    u8MinLen = 3;
  } else {
    u8MinLen = 5;
  }
  u16Reg = %'ModuleName'%.Read(%'ModuleName'%.TX_PKT_LEN); %>%CTAB /* Read the TX packet length register contents */
  u16Reg = (word)((0xFF80 & u16Reg) | (psTxPkt->u8DataLength + (u8MinLen - 1))); %>%CTAB /* Mask out old length setting and update. Add 2 for CRC and 2 for code bytes */
  %'ModuleName'%.Write(%'ModuleName'%.TX_PKT_LEN, u16Reg); %>%CTAB /* Update the TX packet length field */
  SPI_GET_DEVICE();   %>%CTAB /* prevent concurrent access to device */
  SPI_Write_ReadDummy(%'ModuleName'%.TX_PKT);    %>%CTAB /* SPI TX ram data register */
  if (!PHY_PROMISCUOUS_MODE) {
    SPI_Write_ReadDummy(0xFF);    %>%CTAB /* Send 1st Code Byte */
    SPI_Write_ReadDummy(0x7E);    %>%CTAB /* Send 2nd Code Byte */
  }
  u8TempByte = 0;  %>%CTAB /* Byte counter for *contents */
  /* Word loop. Round up. */
  for (i=0; i<((psTxPkt->u8DataLength+1) >> 1); i++) {
    SPI_Write_ReadDummy(psTxPkt->pu8Data[u8TempByte+1]); %>%CTAB /* Write MSB */
    SPI_Write_ReadDummy(psTxPkt->pu8Data[u8TempByte]);   %>%CTAB /* Write LSB */
    u8TempByte = (byte)(u8TempByte + 2);             %>%CTAB /* Increment byte counter */
  }
  SPI_LEAVE_DEVICE();   %>%CTAB /* release device */
}

%endif %- WriteTx
%-BW_METHOD_END WriteTx
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadRx
%ifdef ReadRx
%define! ParpsRxPkt
%define! RetVal
%include Common\MC13192ReadRx.Inc
byte %'ModuleName'%.%ReadRx(tRxPacket *psRxPkt)
{
  byte i, u8TempByte=0;    %>%CTAB /* Temporary counters. */
  byte u8MinLen=0;
  byte u8Status=0;       %>%CTAB /* Holder for the return value */
  word u16RxLength;

  if (PHY_PROMISCUOUS_MODE) {
    u8MinLen = 3;
  } else {
    u8MinLen = 5;
  }
  u16RxLength = %'ModuleName'%.Read(%'ModuleName'%.RX_PKT_LEN); %>%CTAB /* Read the RX packet length register contents */
  u16RxLength &= 0x007F;                         %>%CTAB /* Mask out all but the RX packet length */

  /* Transceiver reports length with 2 CRC bytes and 2 Code bytes, remove them. */
  if (u16RxLength >= u8MinLen) {
    psRxPkt->u8DataLength = (byte)(u16RxLength - (u8MinLen - 1)); /* Less byte code and CRC */
  } else {
    psRxPkt->u8DataLength = 0;
  }
  if ((psRxPkt->u8DataLength >= 1) && (psRxPkt->u8DataLength <= psRxPkt->u8MaxDataLength)) { /* If <5, the packet is garbage */
    SPI_GET_DEVICE();   %>%CTAB /* prevent concurrent access to device */
    SPI_Write_ReadDummy(%'ModuleName'%.RX_PKT|0x80); %>%CTAB /* SPI RX ram data register */
    (void)SPI_WriteDummy_Read(); %>%CTAB /* Dummy write/read. Receive register of SPI will contain MSB garbage for first read */
    (void)SPI_WriteDummy_Read(); %>%CTAB /* discard */
    if (!PHY_PROMISCUOUS_MODE) {
      /* Byte codes */
      (void)SPI_WriteDummy_Read(); %>%CTAB /* Dummy read first code byte */
      (void)SPI_WriteDummy_Read(); %>%CTAB /* Dummy read second code byte */
    }
    u8TempByte = 0;             /* Byte counter for *contents */
    /* Word loop. Round up. Deduct CRC. */
    for (i=0; i<((u16RxLength-1)>>1); i++) {
      /* For a trailing garbage byte, just read and discard */
      if ((u8TempByte + 3) == u16RxLength) {
        (void)SPI_WriteDummy_Read();   %>%CTAB /* Discard */
      } else {
        psRxPkt->pu8Data[u8TempByte+1] = SPI_WriteDummy_Read(); %>%CTAB /* Read MSB */
      }
      psRxPkt->pu8Data[u8TempByte] = SPI_WriteDummy_Read(); %>%CTAB /* Read LSB */
      u8TempByte = (byte)(u8TempByte + 2);            %>%CTAB /* Increment byte counter */
    }
    psRxPkt->u8Status = %'ModuleName'%.SUCCESS;
    SPI_LEAVE_DEVICE();   %>%CTAB /* release device */
  }
  /* Check to see if a larger packet than desired is received. */
  if (psRxPkt->u8DataLength > psRxPkt->u8MaxDataLength) {
    psRxPkt->u8Status = %'ModuleName'%.OVERFLOW;
  }
  return u8Status;
}
%endif %- ReadRx
%-BW_METHOD_END ReadRx
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG Init

static void ResetTransceiver(void) {
  IRQINIT();                                                     %>%CTAB /* IRQ must be configured to trigger on low level or falling edge, with pull up enabled */
  %@IRQ@'ModuleName'%.Disable();   %>%CTAB /* Disable Transceiver interrupt for the sequence below. */
  %@CE@'ModuleName'%.SetVal();     %>%CTAB /* Disables Transceiver SPI */
  %@ATTN@'ModuleName'%.SetVal();
  %@RTXEN@'ModuleName'%.ClrVal();
  %@RESET@'ModuleName'%.ClrVal();  %>%CTAB /* Do not initially reset Transceiver */
%-  #if defined (ANTENNA_SWITCH)
%-    MC13192_ANT_CTRL2_PORT = 1;   %>%CTAB /* Output for antenna port RX */
%-    MC13192_ANT_CTRL_PORT = 1;    %>%CTAB /* Output for antenna port TX */
%-    MC13192_ANT_CTRL2 = 1;        %>%CTAB /* Signal to turn on RX antenna */
%-    MC13192_ANT_CTRL = 1;         %>%CTAB /* Signal to turn on TX antenna */
%-  #endif
%-  #if defined (LNA)
%-    MC13192_LNA_CTRL = LNA_OFF;   %>%CTAB /* Turn off the LNA out of reset */
%-    MC13192_LNA_CTRL_PORT  = 1;   %>%CTAB /* Enable the port for OUTPUT */
%-  #endif
%-  #if defined (PA)
%-    MC13192_PA_CTRL = PA_OFF;     %>%CTAB /* Turn off the PA out of Reset */
%-    MC13192_PA_CTRL_PORT = 1;     %>%CTAB /* Enable the port for OUTPUT */
%-  #endif
  %'ModuleName'%.%InitCommChannel();
  %'ModuleName'%.gu8RTxMode = %'ModuleName'%.MC13192_RESET_MODE;
  %@RESET@'ModuleName'%.SetVal(); %>%CTAB /* Take Transceiver out of reset */
}

%include Common\GeneralInternal.inc (Init)
void %'ModuleName'%.Init(void)
{
  word u16IrqReg = 0;
  byte u8AttnIrq = FALSE;
  byte cntr;

%- %if SWSPI_Enabled='yes'
%-   /* initialize SPI */
%-   %@SWSPI@'ModuleName'%.Init(); /* idle clock polarity low, shift on falling edge */
%- %elif HWSPI_Enabled='yes'
%-   /* initialize SPI */
%-   %@HWSPI@'ModuleName'%.Init(); /* idle clock polarity low, shift on falling edge */
%- %endif
%-  %'ModuleName'%.gu8RTxMode = %'ModuleName'%.SYSTEM_RESET_MODE;
  cntr = 0;
  ResetTransceiver();
  for(;;) { /* will break */
    if (%@IRQ@'ModuleName'%.GetVal()==0) {           %>%CTAB /* Check to see if IRQ is asserted */
      u16IrqReg = %'ModuleName'%.%Read(%'ModuleName'%.STATUS_ADDR);  %>%CTAB /* Clear Transceiver interrupts and check for ATTN IRQ from 13192 */
      u16IrqReg &= 0x400;
      if (u16IrqReg == 0) {
        u8AttnIrq = FALSE;
      } else {
        u8AttnIrq = TRUE;
      }
    }
    if (u8AttnIrq==TRUE) {
      break; /* break for loop */
    }
    %@Wait@'ModuleName'%.Waitms(1);
    cntr++;
    if (cntr==50) { /* did take too long: restart reset sequence */
      ResetTransceiver();
      cntr = 0;
    }
  } /* for */
  IRQACK();                       %>%CTAB /* ACK the pending IRQ interrupt */
  %@IRQ@'ModuleName'%.Enable();   %>%CTAB /* Pin Enable, IE, IRQ CLR, negative edge. */
%if defined(OnCLKO)
  %OnCLKO(%'ModuleName'%.CLKS_32_786KHZ); /* default at reset is a CLKO of 32.786 kHz */
%endif
  %'ModuleName'%.gu8RTxMode = %'ModuleName'%.MC13192_CONFIG_MODE;
  %'ModuleName'%.RadioInit();
}

%-INTERNAL_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN RTXENDeAssert
%ifdef RTXENDeAssert
%include Common\MC13192RTXENDeAssert.Inc
%if defined(INLINE_ME)
/* function implemented as macro */
%else
void %'ModuleName'%.%RTXENDeAssert(void)
{
  %@RTXEN@'ModuleName'%.ClrVal();
}
%endif

%endif %- RTXENDeAssert
%-BW_METHOD_END RTXENDeAssert
%-************************************************************************************************************
%-BW_METHOD_BEGIN RTXENAssert
%ifdef RTXENAssert
%include Common\MC13192RTXENAssert.Inc
%if defined(INLINE_ME)
/* function implemented as macro */
%else
void %'ModuleName'%.%RTXENAssert(void)
{
  %@RTXEN@'ModuleName'%.SetVal();
}
%endif
%endif %- RTXENAssert
%-BW_METHOD_END RTXENAssert
%-************************************************************************************************************
%-BW_METHOD_BEGIN Wake
%ifdef Wake
%include Common\MC13192Wake.Inc
%if defined(INLINE_ME)
/* function implemented as macro */
%else
void %'ModuleName'%.%Wake(void)
{
  %@ATTN@'ModuleName'%.ClrVal(); /* assert ATTN */
  %@ATTN@'ModuleName'%.SetVal(); /* deassert ATTN */
}
%endif
%endif %- Wake
%-BW_METHOD_END Wake
%-************************************************************************************************************
%-BW_METHOD_BEGIN EnableInterrupts
%ifdef EnableInterrupts
%include Common\MC13192EnableInterrupts.Inc
%if defined(INLINE_ME)
/* implemented as macro in the header file */
%else
void %'ModuleName'%.%EnableInterrupts(void)
{
  %@IRQ@'ModuleName'%.Enable();
}
%endif /* INLINE_ME */
%endif %- EnableInterrupts
%-BW_METHOD_END EnableInterrupts
%-************************************************************************************************************
%-BW_METHOD_BEGIN DisableInterrupts
%ifdef DisableInterrupts
%include Common\MC13192DisableInterrupts.Inc
%if defined(INLINE_ME)
/* implemented as macro in the header file */
%else
void %'ModuleName'%.%DisableInterrupts(void)
{
  %@IRQ@'ModuleName'%.Disable();
}
%endif /* INLINE_ME */

%endif %- DisableInterrupts
%-BW_METHOD_END DisableInterrupts
%-************************************************************************************************************
%-BW_METHOD_BEGIN Restart
%ifdef Restart
%include Common\MC13192Restart.Inc
/*!
 * \brief Restart the MC13192.
 */
void %'ModuleName'%.%Restart(void)
{
  %'ModuleName'%.gu8RTxMode = %'ModuleName'%.SYSTEM_RESET_MODE;
  %@IRQ@'ModuleName'%.Enable();      %>%CTAB /* Turn on the IRQ pin. */
  %@RESET@'ModuleName'%.SetVal();    %>%CTAB /* Take Transceiver out of reset */
  while (%@IRQ@'ModuleName'%.GetVal()!=0) {       %>%CTAB /* Poll waiting for Transceiver to assert the irq */
    /* empty body */
  }           %>%CTAB /* (i.e. ATTN). */
  (void)%'ModuleName'%.%Read(%'ModuleName'%.STATUS_ADDR);  %>%CTAB /* Clear Transceiver interrupts */
  IRQACK();                    %>%CTAB /* ACK the pending IRQ interrupt */
  %@IRQ@'ModuleName'%.Enable();      %>%CTAB /* Pin Enable, IE, IRQ CLR, negative edge. */
}

%endif %- Restart
%-BW_METHOD_END Restart
%-************************************************************************************************************
%-BW_METHOD_BEGIN ContReset
%ifdef ContReset
%include Common\MC13192ContReset.Inc
/*!
 * \brief Reset (continuous) the Transceiver.
 */
void %'ModuleName'%.%ContReset(void)
{
  %'ModuleName'%.gu8RTxMode = %'ModuleName'%.SYSTEM_RESET_MODE;
  %@RESET@'ModuleName'%.ClrVal(); %>%CTAB /* Place the Transceiver into reset */
}

%endif %- ContReset
%-BW_METHOD_END ContReset
%-************************************************************************************************************
%-BW_METHOD_BEGIN RadioInit
%ifdef RadioInit
%include Common\MC13192RadioInit.Inc
void %'ModuleName'%.%RadioInit(void)
{
  /* Please refer to document MC13192RM for hidden register initialization */
%if TransceiverType = "0" %- MPC1320x, external chip
  /* Initialize external transceiver chip MPC1320x */
  %'ModuleName'%.%Write(0x11, 0x80FF);   %>%CTAB /* Eliminate Unlock Conditions due to L01 */
%else %- MPC131x, as found in SiP package e.g. with GT60
  /* Initialize internal transceiver chip MPC1321x */
  %'ModuleName'%.%Write(0x11, 0x20FF);   %>%CTAB /* Eliminate Unlock Conditions due to L01 */
%endif
#if USE_WRITE_4
  %'ModuleName'%.%Write4(%'ModuleName'%.T1_HI_ADDR,  0x80008000);   %>%CTAB /* Disable TC1 & TC2 */
  %'ModuleName'%.%Write4(%'ModuleName'%.T3_HI_ADDR,  0x80008000);   %>%CTAB /* Disable TC3 & TC4 */
#else
  %'ModuleName'%.%Write(%'ModuleName'%.T1_HI_ADDR,   0x8000);   %>%CTAB /* Disable TC1 */
  %'ModuleName'%.%Write(%'ModuleName'%.T2_HI_ADDR,   0x8000);   %>%CTAB /* Disable TC2 */
  %'ModuleName'%.%Write(%'ModuleName'%.T3_HI_ADDR,   0x8000);   %>%CTAB /* Disable TC3 */
  %'ModuleName'%.%Write(%'ModuleName'%.T4_HI_ADDR,   0x8000);   %>%CTAB /* Disable TC4 */
#endif
  %'ModuleName'%.%Write(%'ModuleName'%.GPIO_DATA,
   %if %GPIOenabled='yes'
    (%GPIO567DriveStrength<<14) | %>%CTAB /* strength for GPIO5, 6 and 7 */
   %endif
    (%MISODriveStrength<<12) |  %>%CTAB /* strength for MISO */
    (%CLKODriveStrength<<10) |  %>%CTAB /* strength for CLKO */
    (%IRQDriveStrength<<8) |    %>%CTAB /* strength for IRQ */
   %if %IRQpullUp='yes'
    (1<<7)     %>%CTAB /* IRQ Pullup enabled */
   %else
    (0<<7)     %>%CTAB /* IRQ Pullup disabled */
   %endif
  );
%if %GPIOenabled='yes'
  %'ModuleName'%.%Write(%'ModuleName'%.GPIO_CONFIG,
  %if %GPIO7input='no'
    (1<<13) | %>%CTAB /* GPIO7 enabled as output */
  %else
    (1<<6)  | %>%CTAB /* GPIO7 enabled as input */
  %endif
  %if %GPIO6input='no'
    (1<<12) | %>%CTAB /* GPIO6 enabled as output */
  %else
    (1<<5)  | %>%CTAB /* GPIO6 enabled as input */
  %endif
  %if %GPIO5input='no'
    (1<<11) | %>%CTAB /* GPIO5 enabled as output */
  %else
    (1<<4)  | %>%CTAB /* GPIO5 enabled as input */
  %endif
  %if %GPIO4input='no'
    (1<<10) | %>%CTAB /* GPIO4 enabled as output */
  %else
    (1<<3)  | %>%CTAB /* GPIO4 enabled as input */
  %endif
  %if %GPIO3input='no'
    (1<<9)  | %>%CTAB /* GPIO3 enabled as output */
  %else
    (1<<2)  | %>%CTAB /* GPIO3 enabled as input */
  %endif
  %if %GPIO2input='no'
    (1<<8)  | %>%CTAB /* GPIO2 enabled as output */
  %else
    (1<<1)  | %>%CTAB /* GPIO2 enabled as input */
  %endif
  %if %GPIO1input='no'
    (1<<7)  | %>%CTAB /* GPIO1 enabled as output */
  %else
    (1<<0)  | %>%CTAB /* GPIO1 enabled as input */
  %endif
    (%GPIO14DriveStrength<<14)   %>%CTAB /* strenght for GPIO1-4 */
  );
%endif
  %'ModuleName'%.%Write(%'ModuleName'%.PRESCALE_ADDR,
   %if defined(GPIOaltInterface) & %GPIOaltInterface='yes'
     (1<<7) | %>%CTAB /* Enable alternate MCU interface using GPIO1 and GPIO2 */
   %endif
   %if %CLKOenable='yes'
     (1<<5) |  %>%CTAB /* Enable CLKO */
   %endif
     0x3    |  %>%CTAB /* Event Timer Prescaler (default reset value) */
     0xF348    %>%CTAB /* don't care bits (default reset value) */
    );
  %'ModuleName'%.%Write(%'ModuleName'%.CCA_THRESHOLD, 0xA08D);          %>%CTAB /* New cal value */
  %'ModuleName'%.%Write(%'ModuleName'%.IRQ_MASK,      0x8351);          %>%CTAB /* Acoma, TC1, Doze, ATTN masks, LO1, CRC */
  %'ModuleName'%.%Write(%'ModuleName'%.MODE_ADDR,     0x4720);          %>%CTAB /* CCA, TX, RX, energy detect */
  (void)%'ModuleName'%.%Read(%'ModuleName'%.RESIND_ADDR);               %>%CTAB /* Sets the reset indicator bit */
  (void)%'ModuleName'%.%Read(%'ModuleName'%.STATUS_ADDR);               %>%CTAB /* Clear the status register, if set */
  /* CLKO_Ctl - Register 0A */
  %'ModuleName'%.%Write(%'ModuleName'%.CLKS_ADDR, (word)
   ( (%xtal_trim<<8)                                                     %>%CTAB /* bit 15..8: xtal_trim bits [7:0] */
    | 0x80                                                                %>%CTAB /* bit 7..3: reserved, reset value 0x80 */
    | %CLKOfrequency                                                     %>%CTAB /* bit 2..0: clko_rate[2:0], CLKO frequency */
   )
  );
  %'ModuleName'%.%Write(%'ModuleName'%.MODE2_ADDR,
   %if %CLKOoutOnDoze='yes'
     (1<<9) | %>%CTAB /* Enable CLKO in Doze */
   %endif
%if %CTbiasEnable='yes'
     (1<<14) | %>%CTAB /* CT bias enable bit */
%endif
%if %RFswitchMode='yes'
     (1<<12) | %>%CTAB /* RF switch mode enable bit */
%endif
%if %MISOHighImpedance='yes'
     (1<<11) | %>%CTAB /* MISO high impedance enable bit (default reset value) */
%endif
     (1<<10)   %>%CTAB /* dont'care bit, set to one during reset */
    );
  %'ModuleName'%.gu8RTxMode = %'ModuleName'%.IDLE_MODE;       %>%CTAB /* Update global variable to reflect Transceiver status */
%if defined(OnCLKO)
  %@Wait@'ModuleName'%.Waitms(1);                                             %>%CTAB /* wait some time to get the clock a chance to settle */
  %OnCLKO(%CLKOfrequency);                                              %>%CTAB /* inform application about changed CLKO */
%endif
}

%endif %- RadioInit
%-BW_METHOD_END RadioInit
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetClockRate
%ifdef SetClockRate
%define! Paru8Freq
%define! RetVal
%include Common\MC13192SetClockRate.Inc
byte %'ModuleName'%.%SetClockRate(byte u8Freq)
{
  word u16CurrentValue;

  u16CurrentValue = %'ModuleName'%.Read(%'ModuleName'%.CLKS_ADDR);     %>%CTAB /* Read register and re-write */
  u16CurrentValue &= 0xFFF8;
  u16CurrentValue |= u8Freq;
  %'ModuleName'%.Write(%'ModuleName'%.CLKS_ADDR, u16CurrentValue);
%if defined(OnCLKO)
  %@Wait@'ModuleName'%.Waitms(1);                                            %>%CTAB /* wait some time to get the clock a chance to settle */
  %OnCLKO(u8Freq);                                                     %>%CTAB /* inform application about changed CLKO */
%endif
  return %'ModuleName'%.SUCCESS;
}

%endif %- SetClockRate
%-BW_METHOD_END SetClockRate
%-************************************************************************************************************
%-BW_METHOD_BEGIN InitCommChannel
%ifdef InitCommChannel
%include Common\MC13192InitCommChannel.Inc
void %'ModuleName'%.%InitCommChannel(void)
{
%if defined(HWSPI)
  (void)%@HWSPI@'ModuleName'%.SetShiftClockPolarity(0); /* falling edge */
  (void)%@HWSPI@'ModuleName'%.SetIdleClockPolarity(0); /* low shift clock idle polarity */
  (void)%@HWSPI@'ModuleName'%.SetBaudRateMode(%HWSPIBaudRateMode); /* max 6 MHz */
%endif
}

%endif %- InitCommChannel
%-BW_METHOD_END InitCommChannel
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetRadioSPI
%ifdef GetRadioSPI
%include Common\MC13192GetRadioSPI.Inc
void %'ModuleName'%.%GetRadioSPI(void)
{
%if defined(OnGetRadioSPI)
  %OnGetRadioSPI();
%endif
  %'ModuleName'%.%InitCommChannel();
}

%endif %- GetRadioSPI
%-BW_METHOD_END GetRadioSPI
%-************************************************************************************************************
%-BW_METHOD_BEGIN LeaveRadioSPI
%ifdef LeaveRadioSPI
%include Common\MC13192LeaveRadioSPI.Inc
void %'ModuleName'%.%LeaveRadioSPI(void)
{
%if defined(OnLeaveRadioSPI)
  %OnLeaveRadioSPI();
%endif
}

%endif %- LeaveRadioSPI
%-BW_METHOD_END LeaveRadioSPI
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_METHOD_BEGIN DataIndication
%ifdef DataIndication
%IMPLEMENTATION DataIndication
%include Common\MC13192DataIndication.Inc
void %DataIndication(void)
{
  /* Write your code here ... */
}

%endif %- DataIndication
%-BW_METHOD_END DataIndication
%-BW_METHOD_BEGIN ResetIndication
%ifdef ResetIndication
%IMPLEMENTATION ResetIndication
%include Common\MC13192ResetIndication.Inc
void %ResetIndication(void)
{
  /* Write your code here ... */
}

%endif %- ResetIndication
%-BW_METHOD_END ResetIndication
%-BW_METHOD_BEGIN OnCLKO
%ifdef OnCLKO
%IMPLEMENTATION OnCLKO
%define! Parfreq
%include Common\MC13192OnCLKO.Inc
void %OnCLKO(byte freq)
{
  /* Write your code here ... */
#if 0 /* example code follows: */
  switch(freq) {
    case TRSVR1_CLKS_16MHZ:
      break;
    case TRSVR1_CLKS_8MHZ:
      break;
    case TRSVR1_CLKS_4MHZ:
      break;
    case TRSVR1_CLKS_2MHZ:
      break;
    case TRSVR1_CLKS_1MHZ:
      break;
    case TRSVR1_CLKS_62_5KHZ:
      break;
    case TRSVR1_CLKS_32_786KHZ:
      break;
    case TRSVR1_CLKS_16_393KHZ:
      break;
  }
#endif
}

%endif %- OnCLKO
%-BW_METHOD_END OnCLKO
%-BW_METHOD_BEGIN OnGetRadioSPI
%ifdef OnGetRadioSPI
%IMPLEMENTATION OnGetRadioSPI
%include Common\MC13192OnGetRadioSPI.Inc
void %OnGetRadioSPI(void)
{
  /* Write your code here ... */
}

%endif %- OnGetRadioSPI
%-BW_METHOD_END OnGetRadioSPI
%-BW_METHOD_BEGIN OnLeaveRadioSPI
%ifdef OnLeaveRadioSPI
%IMPLEMENTATION OnLeaveRadioSPI
%include Common\MC13192OnLeaveRadioSPI.Inc
void %OnLeaveRadioSPI(void)
{
  /* Write your code here ... */
}

%endif %- OnLeaveRadioSPI
%-BW_METHOD_END OnLeaveRadioSPI
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
%if InitializeInInit='yes'
  %'ModuleName'%.Init(); /* init the driver */
%endif
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This bean is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
