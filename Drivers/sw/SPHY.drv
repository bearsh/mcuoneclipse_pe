%-Driver generated by the Bean Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Bean Wizard
%- If you change these lines, Bean Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    04.07.2008
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%ifdef MC13192
  %ifdef @MC13192@DataIndication
    %define! Description_%@MC13192@DataIndication Called after a data packet has been received by the transceiver. The event services the event of the inherited component and eventually invokes other events.
  %endif %- @MC13192@DataIndication
%endif %- MC13192
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\SPHYSettings.Inc
%define! Abstract Common\SPHYAbstract.Inc
%include Common\Header.h

%if (CPUfamily = "Kinetis")
#include "PE_LDD.h" /* hack for Processor Expert (e.g. in MCU10.3) and LDD: PE_LDD.h includes at the end all shared modules, causing a recursive header file include conflict */
%endif

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited components */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"
%-
%define CTAB 45
%-

#define %'ModuleName'%.RADIO_BUF_SIZE %RadioBufSize                        %>%CTAB /*!< size of the radio tx/rx buffers */
#define %'ModuleName'%.gu8RTxMode    %@MC13192@'ModuleName'%.gu8RTxMode    %>%CTAB /*!< application can read this variable */
#define %'ModuleName'%.psDrvRxPacket %@MC13192@'ModuleName'%.psDrvRxPacket %>%CTAB /*!< pointer to the buffer for the rx data */

#define %'ModuleName'%.SUCCESS    %@MC13192@'ModuleName'%.SUCCESS
#define %'ModuleName'%.OVERFLOW   %@MC13192@'ModuleName'%.OVERFLOW
#define %'ModuleName'%.TIMEOUT    %@MC13192@'ModuleName'%.TIMEOUT

#define %'ModuleName'%.DOZE_MODE         %@MC13192@'ModuleName'%.DOZE_MODE
#define %'ModuleName'%.HIBERNATE_MODE    %@MC13192@'ModuleName'%.HIBERNATE_MODE
#define %'ModuleName'%.RX_MODE           %@MC13192@'ModuleName'%.RX_MODE
#define %'ModuleName'%.IDLE_MODE         %@MC13192@'ModuleName'%.IDLE_MODE
#define %'ModuleName'%.RX_MODE_WTO       %@MC13192@'ModuleName'%.RX_MODE_WTO

#define %'ModuleName'%.LO1_IDIV_ADDR     %@MC13192@'ModuleName'%.LO1_IDIV_ADDR
#define %'ModuleName'%.LO1_NUM_ADDR      %@MC13192@'ModuleName'%.LO1_NUM_ADDR

#define %'ModuleName'%.SCAN_MODE_ED      %@MC13192@'ModuleName'%.SCAN_MODE_ED
#define %'ModuleName'%.SCAN_MODE_CCA     %@MC13192@'ModuleName'%.SCAN_MODE_CCA

%if AllowPromiscuousMode = 'yes'
typedef struct {
  struct {
    byte u1PromiscuousMode   :1;
    byte u15Undef1           :7;
  } Bits;
} %'ModuleName'%.tPhyOptions;

extern %'ModuleName'%.tPhyOptions %'ModuleName'%.gsPhyOptions;

#define PHY_PROMISCUOUS_MODE   %'ModuleName'%.gsPhyOptions.Bits.u1PromiscuousMode
%else
#define PHY_PROMISCUOUS_MODE   0 /* no promiscuous mode */
%endif /* AllowPromiscuousMode */

#define MCU_LOW_POWER_WHILE() %'ProcessorModule'%.SetWaitMode() /*!< Low power Wait instruction */

/* Status enumations for the PHY. */
enum %'ModuleName'%.PD_DATA_STATUS {%'ModuleName'%.RX_ON = 1, %'ModuleName'%.TRX_OFF};
enum %'ModuleName'%.MC13192_POWER_MODES {%'ModuleName'%.RF_POWER_ON = 1, %'ModuleName'%.RF_POWER_HIBERNATE, %'ModuleName'%.RF_POWER_DOZE};
enum %'ModuleName'%.PLME_SET_TRX_STATE_REQUEST {%'ModuleName'%.ERROR = 1};

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-
%-BW_CUSTOM_USERTYPE_END


%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMEPhyReset
%ifdef PLMEPhyReset
byte %'ModuleName'%.%PLMEPhyReset(void);
%define! RetVal
%include Common\SPHYPLMEPhyReset.Inc

%endif %- PLMEPhyReset
%-BW_METHOD_END PLMEPhyReset
%-************************************************************************************************************
%-BW_METHOD_BEGIN PDDataRequest
%ifdef PDDataRequest
byte %'ModuleName'%.%PDDataRequest(tTxPacket *psPacket);
%define! ParpsPacket
%define! RetVal
%include Common\SPHYPDDataRequest.Inc

%endif %- PDDataRequest
%-BW_METHOD_END PDDataRequest
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMEHibernateRequest
%ifdef PLMEHibernateRequest
byte %'ModuleName'%.%PLMEHibernateRequest(void);
%define! RetVal
%include Common\SPHYPLMEHibernateRequest.Inc

%endif %- PLMEHibernateRequest
%-BW_METHOD_END PLMEHibernateRequest
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMEDozeRequest
%ifdef PLMEDozeRequest
byte %'ModuleName'%.%PLMEDozeRequest(dword u32Timeout);
%define! Paru32Timeout
%define! RetVal
%include Common\SPHYPLMEDozeRequest.Inc

%endif %- PLMEDozeRequest
%-BW_METHOD_END PLMEDozeRequest
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMEWakeRequest
%ifdef PLMEWakeRequest
byte %'ModuleName'%.%PLMEWakeRequest(void);
%define! RetVal
%include Common\SPHYPLMEWakeRequest.Inc

%endif %- PLMEWakeRequest
%-BW_METHOD_END PLMEWakeRequest
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMESetChannelRequest
%ifdef PLMESetChannelRequest
byte %'ModuleName'%.%PLMESetChannelRequest(byte u8Channel);
%define! Paru8Channel
%define! RetVal
%include Common\SPHYPLMESetChannelRequest.Inc

%endif %- PLMESetChannelRequest
%-BW_METHOD_END PLMESetChannelRequest
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMESetTrxStateRequest
%ifdef PLMESetTrxStateRequest
byte %'ModuleName'%.%PLMESetTrxStateRequest(byte u8ReqMode);
%define! Paru8ReqMode
%define! RetVal
%include Common\SPHYPLMESetTrxStateRequest.Inc

%endif %- PLMESetTrxStateRequest
%-BW_METHOD_END PLMESetTrxStateRequest
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMEEnergyDetect
%ifdef PLMEEnergyDetect
byte %'ModuleName'%.%PLMEEnergyDetect(void);
%define! RetVal
%include Common\SPHYPLMEEnergyDetect.Inc

%endif %- PLMEEnergyDetect
%-BW_METHOD_END PLMEEnergyDetect
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMECCARequest
%ifdef PLMECCARequest
byte %'ModuleName'%.%PLMECCARequest(void);
%define! RetVal
%include Common\SPHYPLMECCARequest.Inc

%endif %- PLMECCARequest
%-BW_METHOD_END PLMECCARequest
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMELinkQuality
%ifdef PLMELinkQuality
byte %'ModuleName'%.%PLMELinkQuality(void);
%define! RetVal
%include Common\SPHYPLMELinkQuality.Inc

%endif %- PLMELinkQuality
%-BW_METHOD_END PLMELinkQuality
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMEGetTimeRequest
%ifdef PLMEGetTimeRequest
dword %'ModuleName'%.%PLMEGetTimeRequest(void);
%define! RetVal
%include Common\SPHYPLMEGetTimeRequest.Inc

%endif %- PLMEGetTimeRequest
%-BW_METHOD_END PLMEGetTimeRequest
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMESetMC13192ClockRate
%ifdef PLMESetMC13192ClockRate
#define %'ModuleName'%.%PLMESetMC13192ClockRate(u8Freq) %@MC13192@'ModuleName'%.SetClockRate(u8Freq)
%define! Paru8Freq
%define! RetVal
%include Common\SPHYPLMESetMC13192ClockRate.Inc

%endif %- PLMESetMC13192ClockRate
%-BW_METHOD_END PLMESetMC13192ClockRate
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMESetMC13192TmrPrescale
%ifdef PLMESetMC13192TmrPrescale
byte %'ModuleName'%.%PLMESetMC13192TmrPrescale(byte freq);
%define! Parfreq
%define! RetVal
%include Common\SPHYPLMESetMC13192TmrPrescale.Inc

%endif %- PLMESetMC13192TmrPrescale
%-BW_METHOD_END PLMESetMC13192TmrPrescale
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMESetTimeRequest
%ifdef PLMESetTimeRequest
void %'ModuleName'%.%PLMESetTimeRequest(dword u32RequestedTime);
%define! Paru32RequestedTime
%include Common\SPHYPLMESetTimeRequest.Inc

%endif %- PLMESetTimeRequest
%-BW_METHOD_END PLMESetTimeRequest
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMEEnableMC13192Timer1
%ifdef PLMEEnableMC13192Timer1
byte %'ModuleName'%.%PLMEEnableMC13192Timer1(dword u32CounterValue);
%define! Paru32CounterValue
%define! RetVal
%include Common\SPHYPLMEEnableMC13192Timer1.Inc

%endif %- PLMEEnableMC13192Timer1
%-BW_METHOD_END PLMEEnableMC13192Timer1
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMEDisableMC13192Timer1
%ifdef PLMEDisableMC13192Timer1
byte %'ModuleName'%.%PLMEDisableMC13192Timer1(void);
%define! RetVal
%include Common\SPHYPLMEDisableMC13192Timer1.Inc

%endif %- PLMEDisableMC13192Timer1
%-BW_METHOD_END PLMEDisableMC13192Timer1
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMEMC13192SoftReset
%ifdef PLMEMC13192SoftReset
byte %'ModuleName'%.%PLMEMC13192SoftReset(void);
%define! RetVal
%include Common\SPHYPLMEMC13192SoftReset.Inc

%endif %- PLMEMC13192SoftReset
%-BW_METHOD_END PLMEMC13192SoftReset
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMEMC13192XtalAdjust
%ifdef PLMEMC13192XtalAdjust
byte %'ModuleName'%.%PLMEMC13192XtalAdjust(byte u8TrimValue);
%define! Paru8TrimValue
%define! RetVal
%include Common\SPHYPLMEMC13192XtalAdjust.Inc

%endif %- PLMEMC13192XtalAdjust
%-BW_METHOD_END PLMEMC13192XtalAdjust
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMEMC13192FEGainAdjust
%ifdef PLMEMC13192FEGainAdjust
byte %'ModuleName'%.%PLMEMC13192FEGainAdjust(byte i8GainValue);
%define! Pari8GainValue
%define! RetVal
%include Common\SPHYPLMEMC13192FEGainAdjust.Inc

%endif %- PLMEMC13192FEGainAdjust
%-BW_METHOD_END PLMEMC13192FEGainAdjust
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMEMC13192PAOutputAdjust
%ifdef PLMEMC13192PAOutputAdjust
byte %'ModuleName'%.%PLMEMC13192PAOutputAdjust(byte u8RequestedPAValue);
%define! Paru8RequestedPAValue
%define! RetVal
%include Common\SPHYPLMEMC13192PAOutputAdjust.Inc

%endif %- PLMEMC13192PAOutputAdjust
%-BW_METHOD_END PLMEMC13192PAOutputAdjust
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMEGetRficVersion
%ifdef PLMEGetRficVersion
byte %'ModuleName'%.%PLMEGetRficVersion(void);
%define! RetVal
%include Common\SPHYPLMEGetRficVersion.Inc

%endif %- PLMEGetRficVersion
%-BW_METHOD_END PLMEGetRficVersion
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMELoadPRBS9
%ifdef PLMELoadPRBS9
void %'ModuleName'%.%PLMELoadPRBS9(tTxPacket *psPacket);
%define! PartTxPacket
%include Common\SPHYPLMELoadPRBS9.Inc

%endif %- PLMELoadPRBS9
%-BW_METHOD_END PLMELoadPRBS9
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMEEnablePromiscuousMode
%ifdef PLMEEnablePromiscuousMode
byte %'ModuleName'%.%PLMEEnablePromiscuousMode(void);
%define! RetVal
%include Common\SPHYPLMEEnablePromiscuousMode.Inc

%endif %- PLMEEnablePromiscuousMode
%-BW_METHOD_END PLMEEnablePromiscuousMode
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMEDisablePromiscuousMode
%ifdef PLMEDisablePromiscuousMode
byte %'ModuleName'%.%PLMEDisablePromiscuousMode(void);
%define! RetVal
%include Common\SPHYPLMEDisablePromiscuousMode.Inc

%endif %- PLMEDisablePromiscuousMode
%-BW_METHOD_END PLMEDisablePromiscuousMode
%-INHERITED_EVENT_BEGIN MC13192 DataIndication
%ifdef @MC13192@DataIndication
void %@MC13192@DataIndication(void);

%endif %- @MC13192@DataIndication
%-INHERITED_EVENT_END MC13192 DataIndication
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMETestMode
%ifdef PLMETestMode
void %'ModuleName'%.%PLMETestMode(tTxPacket *psPacket, byte u8mode);
%define! ParpsPacket
%define! Paru8Mode
%define! Paru8mode
%include Common\SPHYPLMETestMode.Inc

%endif %- PLMETestMode
%-BW_METHOD_END PLMETestMode
%-************************************************************************************************************
%-BW_METHOD_BEGIN Write
%ifdef Write
%-BW_PUBLISH_MACRO
#define %'ModuleName'%.%Write %@MC13192@'ModuleName'%.%Write
%define! Paraddr
%define! Parval
%include Common\SPHYWrite.Inc

%endif %- Write
%-BW_METHOD_END Write
%-************************************************************************************************************
%-BW_METHOD_BEGIN Read
%ifdef Read
%-BW_PUBLISH_MACRO
#define %'ModuleName'%.%Read %@MC13192@'ModuleName'%.%Read
%define! Paraddr
%define! RetVal
%include Common\SPHYRead.Inc

%endif %- Read
%-BW_METHOD_END Read
%-************************************************************************************************************
%-BW_METHOD_BEGIN RadioInit
%ifdef RadioInit
%-BW_PUBLISH_MACRO
#define %'ModuleName'%.%RadioInit %@MC13192@'ModuleName'%.%RadioInit
%include Common\SPHYRadioInit.Inc

%endif %- RadioInit
%-BW_METHOD_END RadioInit
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMEGetGPIObyte
%ifdef PLMEGetGPIObyte
byte %'ModuleName'%.%PLMEGetGPIObyte(void);
%define! RetVal
%include Common\SPHYPLMEGetGPIObyte.Inc

%endif %- PLMEGetGPIObyte
%-BW_METHOD_END PLMEGetGPIObyte
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMEPutGPIObyte
%ifdef PLMEPutGPIObyte
void %'ModuleName'%.%PLMEPutGPIObyte(byte data);
%define! Pardata
%include Common\SPHYPLMEPutGPIObyte.Inc

%endif %- PLMEPutGPIObyte
%-BW_METHOD_END PLMEPutGPIObyte
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_METHOD_BEGIN DataIndicationPacket
%ifdef DataIndicationPacket
%INTERFACE DataIndicationPacket
void %DataIndicationPacket(tRxPacket *sRxPacket);
%define! ParsRxPacket
%include Common\SPHYDataIndicationPacket.Inc

%endif %- DataIndicationPacket
%-BW_METHOD_END DataIndicationPacket
%-BW_METHOD_BEGIN DataIndication
%ifdef DataIndication
%INTERFACE DataIndication
void %DataIndication(void);
%include Common\SPHYDataIndication.Inc

%endif %- DataIndication
%-BW_METHOD_END DataIndication
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\SPHYSettings.Inc
%define! Abstract Common\SPHYAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
%-
%if AllowPromiscuousMode = 'yes'
%'ModuleName'%.tPhyOptions %'ModuleName'%.gsPhyOptions;
%endif
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMEPhyReset
%ifdef PLMEPhyReset
%define! RetVal
%include Common\SPHYPLMEPhyReset.Inc
byte %'ModuleName'%.%PLMEPhyReset(void)
{
  /* Sets the default Options */
%if AllowPromiscuousMode = 'yes'
  %'ModuleName'%.gsPhyOptions.Bits.u1PromiscuousMode = 1;
%endif
%- /* not used? */
%-  %'ModuleName'%.gsPhyOptions.Byte.u16ScanChannels = 0xFFFF; /* Default to all channels */
%-
  return %'ModuleName'%.SUCCESS;
}

%endif %- PLMEPhyReset
%-BW_METHOD_END PLMEPhyReset
%-************************************************************************************************************
%-BW_METHOD_BEGIN PDDataRequest
%ifdef PDDataRequest
%define! ParpsPacket
%define! RetVal
%include Common\SPHYPDDataRequest.Inc
/*!
 * \brief Transmit data packet
 * \param *psPacket packet pointer
 * \return Status
 */
byte %'ModuleName'%.%PDDataRequest(tTxPacket *psPacket)
{
%if defined(Timeout) & %TransmitTimeoutMs >. "0"
  %@Timeout@'ModuleName'%.CounterHandle timeout;
%endif
  byte res = %'ModuleName'%.SUCCESS;

  if (%@MC13192@'ModuleName'%.gu8RTxMode == %@MC13192@'ModuleName'%.IDLE_MODE) {
    %if %SecurityEnabled='yes'
    if (%@SecurityInterface@'ModuleName'%.AdjustPacketSize(psPacket->pu8Data, %'ModuleName'%.RADIO_BUF_SIZE, &psPacket->u8DataLength) != ERR_OK) {
      return %'ModuleName'%.OVERFLOW; /* security gave an error */
    }
    if (%@SecurityInterface@'ModuleName'%.Encrypt(psPacket->pu8Data, psPacket->u8DataLength) != ERR_OK) {
      return %'ModuleName'%.OVERFLOW; /* security gave an error */
    }
    %endif
    %@MC13192@'ModuleName'%.WriteTx(psPacket);    %>%CTAB /* Load the data into packet RAM */
    if (%'ModuleName'%.PLMESetTrxStateRequest(%@MC13192@'ModuleName'%.TX_MODE)!=%'ModuleName'%.SUCCESS) {  %>%CTAB /* transmit it */
      return %'ModuleName'%.ERROR;
    }
    /* Wait for the state to return to idle. (finish transmitting) */
%if defined(Timeout) & %TransmitTimeoutMs >. "0"
    timeout = %@Timeout@'ModuleName'%.GetCounter(%TransmitTimeoutMs/%@Timeout@'ModuleName'%.TICK_PERIOD_MS); /* set up timeout counter */
%endif
    while (%@MC13192@'ModuleName'%.gu8RTxMode != %@MC13192@'ModuleName'%.IDLE_MODE) {
%if %LowPowerWait='yes'
      MCU_LOW_POWER_WHILE(); /* if you get a compiler warning here: Enable 'SetWaitMode()' method in the CPU component */
%endif
%if defined(Timeout) & %TransmitTimeoutMs >. "0"
      if (%@Timeout@'ModuleName'%.CounterExpired(timeout)) {
        res = %'ModuleName'%.TIMEOUT;
        break;
      }
%endif
    } /* while */
%if defined(Timeout) & %AppTaskTimeout >. "0"
    %@Timeout@'ModuleName'%.LeaveCounter(timeout); /* return timeout counter */
%endif
    return res;
  } else {
    return %'ModuleName'%.RX_ON;
  }
}

%endif %- PDDataRequest
%-BW_METHOD_END PDDataRequest
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMEHibernateRequest
%ifdef PLMEHibernateRequest
%define! RetVal
%include Common\SPHYPLMEHibernateRequest.Inc
/*!
 * \brief Hibernate the MC13192 (very low current, no CLKO).
 * \return Status
 */
byte %'ModuleName'%.%PLMEHibernateRequest(void)
{
  word u16CurrentValue;

  %@MC13192@'ModuleName'%.gu8RTxMode = %@MC13192@'ModuleName'%.HIBERNATE_MODE;
  u16CurrentValue = %@MC13192@'ModuleName'%.Read(%@MC13192@'ModuleName'%.MODE2_ADDR);  %>%CTAB  /* Read MC13192 Hiberate register. */
  u16CurrentValue &= 0xFFFC;
  u16CurrentValue |= 0x0002;                      %>%CTAB /* Hiberate enable */
  %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.MODE2_ADDR, u16CurrentValue);       %>%CTAB /* Write back to MC13192 to enable hibernate mode. */
  return %'ModuleName'%.SUCCESS;         %>%CTAB /* Call back to MAC layer indicating success. */
}

%endif %- PLMEHibernateRequest
%-BW_METHOD_END PLMEHibernateRequest
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMEDozeRequest
%ifdef PLMEDozeRequest
%define! Paru32Timeout
%define! RetVal
%include Common\SPHYPLMEDozeRequest.Inc
/*!
 * \brief Doze the MC13192 (Low current, CLKO <= 1MHz).
 * \param u32Timeout - timeout
 * \return Status
 */
byte %'ModuleName'%.%PLMEDozeRequest(dword u32Timeout)
{
  word u16CurrentValue;
  dword u32CurrentTime;

  %@MC13192@'ModuleName'%.gu8RTxMode = %@MC13192@'ModuleName'%.DOZE_MODE;
  u16CurrentValue = %@MC13192@'ModuleName'%.Read(%@MC13192@'ModuleName'%.MODE2_ADDR);         %>%CTAB /* Read MC13192 Doze register. */
  if (u32Timeout == 0) {  %>%CTAB /* ACOMA mode, with clkout */
    u16CurrentValue = %@MC13192@'ModuleName'%.Read(%@MC13192@'ModuleName'%.IRQ_MASK);
    u16CurrentValue &= 0xFE0D;                      %>%CTAB /* Change the IRQ_Mask to set Acoma en,*/
    u16CurrentValue |= 0x0100;                      %>%CTAB /* doze irq disabled and tmr2 disabled*/
    %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.IRQ_MASK, u16CurrentValue);
    u16CurrentValue = %@MC13192@'ModuleName'%.Read(%@MC13192@'ModuleName'%.MODE2_ADDR);       %>%CTAB /* Read MC13192 Doze register. */
    u16CurrentValue &= 0xFDFC;
    u16CurrentValue |= 0x0201;                      %>%CTAB /* Doze (acoma) & CLKOUT enable */
    %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.MODE2_ADDR, u16CurrentValue);       %>%CTAB /* Write back to MC13192 to enable hibernate mode. */
  } else {                                          %>%CTAB /* DOZE mode with timeout, no clkout */
    u16CurrentValue = %@MC13192@'ModuleName'%.Read(%@MC13192@'ModuleName'%.IRQ_MASK);
    u16CurrentValue &= 0xFE0D;                      %>%CTAB /* Change the IRQ_Mask to set Acoma dis,*/
    u16CurrentValue |= 0x0012;                      %>%CTAB /* doze enabled and tmr2 enabled*/
    %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.IRQ_MASK, u16CurrentValue);

    u32CurrentTime = %'ModuleName'%.PLMEGetTimeRequest();
    u32Timeout += u32CurrentTime;
    %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.T2_HI_ADDR, ((word)((u32Timeout>>16)&0x00FF)));
    %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.T2_LO_ADDR, ((word)(u32Timeout&0xFFFF)));  %>%CTAB /* Enable the Timer 2 and save the timeout value */
    u16CurrentValue = %@MC13192@'ModuleName'%.Read(%@MC13192@'ModuleName'%.MODE2_ADDR);
    u16CurrentValue &= 0xFDFC;                      %>%CTAB /* Disable CLKOinDozeand */
    u16CurrentValue |= 0x0001;                      %>%CTAB /* enter in Doze mode */
    %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.MODE2_ADDR, u16CurrentValue);
  }
  return %'ModuleName'%.SUCCESS;         %>%CTAB /* Call back to MAC layer indicating success. */
}

%endif %- PLMEDozeRequest
%-BW_METHOD_END PLMEDozeRequest
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMEWakeRequest
%ifdef PLMEWakeRequest
%define! RetVal
%include Common\SPHYPLMEWakeRequest.Inc
byte %'ModuleName'%.%PLMEWakeRequest(void)
{
  word u16CurrentValue;

  %@MC13192@'ModuleName'%.Wake();                   %>%CTAB /* Wake up the device */
  while (%@MC13192@'ModuleName'%.gu8RTxMode != %@MC13192@'ModuleName'%.IDLE_MODE_ATTN) {
%if %LowPowerWait='yes'
    MCU_LOW_POWER_WHILE();                    %>%CTAB /* Wait until ATTN, if you get a compiler warning here: Enable 'SetWaitMode()' method in the CPU bean */
%endif
  }
  u16CurrentValue = %@MC13192@'ModuleName'%.Read(%@MC13192@'ModuleName'%.MODE2_ADDR);   %>%CTAB /* Read MC13192 Hibernate/Doze register.*/
  u16CurrentValue &= 0xFFFC;                              %>%CTAB /* Hiberate and Doze disable */
  %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.MODE2_ADDR, u16CurrentValue);   %>%CTAB /* Write back to MC13192 to disable hibernate and doze mode.*/
  %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.T2_HI_ADDR, 0x0000);            %>%CTAB /* Disable Timer2 to avoid a T2 int because of doze w/timeout */
  %@MC13192@'ModuleName'%.gu8RTxMode = %@MC13192@'ModuleName'%.IDLE_MODE;
  return %'ModuleName'%.SUCCESS;
}

%endif %- PLMEWakeRequest
%-BW_METHOD_END PLMEWakeRequest
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMESetChannelRequest
%ifdef PLMESetChannelRequest
%define! Paru8Channel
%define! RetVal
%include Common\SPHYPLMESetChannelRequest.Inc
 /*!
 * \brief Set the MC13192 operating channel.
 * \param u8Channel Channel number
 * \return Status
 */
byte %'ModuleName'%.%PLMESetChannelRequest(byte u8Channel)
{
  static const struct {
    word val0, val1;
  } chValues[] = {
  /* channel  0 */ {0x0F95,0x5000},
  /* channel  1 */ {0x0F95,0xA000},
  /* channel  2 */ {0x0F95,0xF000},
  /* channel  3 */ {0x0F96,0x4000},
  /* channel  4 */ {0x0F96,0x9000},
  /* channel  5 */ {0x0F96,0xE000},
  /* channel  6 */ {0x0F97,0x3000},
  /* channel  7 */ {0x0F97,0x8000},
  /* channel  8 */ {0x0F97,0xD000},
  /* channel  9 */ {0x0F98,0x2000},
  /* channel 10 */ {0x0F98,0x7000},
  /* channel 11 */ {0x0F98,0xC000},
  /* channel 12 */ {0x0F99,0x1000},
  /* channel 13 */ {0x0F99,0x6000},
  /* channel 14 */ {0x0F99,0xB000},
  /* channel 15 */ {0x0F9A,0x0000}
  };

  u8Channel &= 0x0F; /* to make sure it is in the range of 0..15 */
  %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.LO1_IDIV_ADDR, chValues[u8Channel].val0);
  %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.LO1_NUM_ADDR, chValues[u8Channel].val1);
  return %'ModuleName'%.SUCCESS;
}

%endif %- PLMESetChannelRequest
%-BW_METHOD_END PLMESetChannelRequest
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMESetTrxStateRequest
%ifdef PLMESetTrxStateRequest
%define! Paru8ReqMode
%define! RetVal
%include Common\SPHYPLMESetTrxStateRequest.Inc
byte %'ModuleName'%.%PLMESetTrxStateRequest(byte u8ReqMode)
{
  word u16Reg;

  %@MC13192@'ModuleName'%.RTXENDeAssert();
  u16Reg = %@MC13192@'ModuleName'%.Read(%@MC13192@'ModuleName'%.MODE_ADDR);
  u16Reg &= 0xFFF8;                        %>%CTAB /* Clear mode. */
  switch (u8ReqMode) {
   //u16Reg |= IDLE_MODE;
   case %@MC13192@'ModuleName'%.IDLE_MODE:                         %>%CTAB /* Write Idle */
     #if defined (LNA)
        MC13192_LNA_CTRL = LNA_OFF;
     #endif
     #if defined (PA)
        MC13192_PA_CTRL = PA_OFF;
     #endif
     %@MC13192@'ModuleName'%.gu8RTxMode = %@MC13192@'ModuleName'%.IDLE_MODE;
     %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.MODE_ADDR, u16Reg);
     break;

   case %@MC13192@'ModuleName'%.RX_MODE:                           %>%CTAB /* Write RX */
     #if defined (LNA)
       MC13192_LNA_CTRL = LNA_ON;
     #endif
     #if defined (PA)
       MC13192_PA_CTRL = PA_OFF;
     #endif
     #if defined (ANTENNA_SWITCH)
       MC13192_ANT_CTRL2 = ANT_CTRL_ON;    %>%CTAB /* Turn on the RX antenna */
       MC13192_ANT_CTRL = ANT_CTRL_OFF;    %>%CTAB /* Turn off the TX antenna */
     #endif
     %@MC13192@'ModuleName'%.gu8RTxMode = %@MC13192@'ModuleName'%.RX_MODE;
     u16Reg |= %@MC13192@'ModuleName'%.RX_MODE;
     %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.MODE_ADDR, u16Reg);
     %@MC13192@'ModuleName'%.RTXENAssert();
     break;

   case %@MC13192@'ModuleName'%.RX_MODE_WTO:           %>%CTAB /* Write RX, but set %@MC13192@'ModuleName'%.gu8RTxMode to timeout */
     #if defined (LNA)
       MC13192_LNA_CTRL = LNA_ON;
     #endif
     #if defined (PA)
       MC13192_PA_CTRL = PA_OFF;
     #endif
     #if defined (ANTENNA_SWITCH)
       MC13192_ANT_CTRL2 = ANT_CTRL_ON;    %>%CTAB /* Turn on the RX antenna */
       MC13192_ANT_CTRL = ANT_CTRL_OFF;    %>%CTAB /* Turn off the TX antenna */
     #endif
     %@MC13192@'ModuleName'%.gu8RTxMode = %@MC13192@'ModuleName'%.RX_MODE_WTO;
     u16Reg |= %@MC13192@'ModuleName'%.RX_MODE;
     %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.MODE_ADDR, u16Reg);
     %@MC13192@'ModuleName'%.RTXENAssert();
     break;

   case %@MC13192@'ModuleName'%.TX_MODE:               %>%CTAB /* Write Tx. Note: force LO lock not used */
     #if defined (PA)
       MC13192_PA_CTRL = PA_ON;
     #endif
     #if defined (LNA)
       MC13192_LNA_CTRL = LNA_OFF;
     #endif
     #if defined (ANTENNA_SWITCH)
       MC13192_ANT_CTRL2 = ANT_CTRL_OFF;   %>%CTAB /* Turn off the RX antenna */
       MC13192_ANT_CTRL = ANT_CTRL_ON;     %>%CTAB /* Turn on the TX antenna */
     #endif
     u16Reg |= %@MC13192@'ModuleName'%.TX_MODE;
     %@MC13192@'ModuleName'%.gu8RTxMode = %@MC13192@'ModuleName'%.TX_MODE;
     %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.MODE_ADDR, u16Reg);
     %@MC13192@'ModuleName'%.RTXENAssert();
     break;

    case %@MC13192@'ModuleName'%.PULSE_TX_MODE: %>%CTAB /* Write Tx. Note: force LO lock not used */
      #if defined (PA)
        MC13192_PA_CTRL = %@MC13192@'ModuleName'%.PA_ON;
      #endif
      #if defined (LNA)
        MC13192_LNA_CTRL = %@MC13192@'ModuleName'%.LNA_OFF;
      #endif
      #if defined (ANTENNA_SWITCH)
        MC13192_ANT_CTRL2 = %@MC13192@'ModuleName'%.ANT_CTRL_OFF;      %>%CTAB /* Turn off the RX antenna */
        MC13192_ANT_CTRL = %@MC13192@'ModuleName'%.ANT_CTRL_ON;        %>%CTAB /* Turn on the TX antenna */
      #endif
      u16Reg |= %@MC13192@'ModuleName'%.TX_MODE;
      %@MC13192@'ModuleName'%.gu8RTxMode = %@MC13192@'ModuleName'%.PULSE_TX_MODE;
      %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.MODE_ADDR, u16Reg);
      %@MC13192@'ModuleName'%.RTXENAssert();
      break;

   default:
     return %'ModuleName'%.ERROR;
  }
  return %'ModuleName'%.SUCCESS;
}

%endif %- PLMESetTrxStateRequest
%-BW_METHOD_END PLMESetTrxStateRequest
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMEEnergyDetect
%ifdef PLMEEnergyDetect
%define! RetVal
%include Common\SPHYPLMEEnergyDetect.Inc
/*!
 * \brief Measure channel energy.
 * \return Energy
 * \note Actual power returned is: -(power/2)   \n
 * Global calibration required for accuracy.
 */
byte %'ModuleName'%.%PLMEEnergyDetect(void)
{
  word u16Reg;
  byte u8Power;

  %@MC13192@'ModuleName'%.gu8RTxMode = %@MC13192@'ModuleName'%.CCA_MODE;                %>%CTAB /* Write energy detect mode */
  u16Reg = %@MC13192@'ModuleName'%.Read(%@MC13192@'ModuleName'%.MODE_ADDR);
  u16Reg &= 0xFFC8; %>%CTAB /* Mask off the CCA_type mode 5:4, xcvr_seq 2:0 */
  u16Reg |= (%@MC13192@'ModuleName'%.CCA_MODE | %@MC13192@'ModuleName'%.SCAN_MODE_ED); %>%CTAB /* Set the CCA mode and turn on CCA */
  %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.MODE_ADDR, u16Reg);
  %@MC13192@'ModuleName'%.RTXENAssert();
  while (%@MC13192@'ModuleName'%.gu8RTxMode != %@MC13192@'ModuleName'%.IDLE_MODE) {   %>%CTAB /* Wait for energy detect to complete */
%if %LowPowerWait='yes'
    MCU_LOW_POWER_WHILE(); /* if you get a compiler warning here: Enable 'SetWaitMode()' method in the CPU bean */
%endif
  }
  u16Reg = (word)(%@MC13192@'ModuleName'%.Read(%@MC13192@'ModuleName'%.CCA_RESULT_ADDR) & 0xFF00);
  u8Power = (byte)(u16Reg >> 8);
  return u8Power;
}

%endif %- PLMEEnergyDetect
%-BW_METHOD_END PLMEEnergyDetect
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMECCARequest
%ifdef PLMECCARequest
%define! RetVal
%include Common\SPHYPLMECCARequest.Inc
byte %'ModuleName'%.%PLMECCARequest(void)
{
  /* Note: Actual power returned is: -(power/2) */
  /* Global calibration required for accuracy. */
  word u16Reg;

  %@MC13192@'ModuleName'%.gu8RTxMode = %@MC13192@'ModuleName'%.CCA_MODE;                %>%CTAB /* Write energy detect mode */
  u16Reg = %@MC13192@'ModuleName'%.Read(%@MC13192@'ModuleName'%.MODE_ADDR);
  u16Reg &= 0xFFC8; %>%CTAB /* Mask off the CCA_type mode 5:4, xcvr_seq 2:0 */
  u16Reg |= (%@MC13192@'ModuleName'%.CCA_MODE | %@MC13192@'ModuleName'%.SCAN_MODE_CCA); %>%CTAB /* Set the CCA mode and turn on CCA */
  %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.MODE_ADDR, u16Reg);
  %@MC13192@'ModuleName'%.RTXENAssert();
  while (%@MC13192@'ModuleName'%.gu8RTxMode != %@MC13192@'ModuleName'%.IDLE_MODE) {      %>%CTAB /* Wait for energy detect to complete */
%if %LowPowerWait='yes'
    MCU_LOW_POWER_WHILE(); /* if you get a compiler warning here: Enable 'SetWaitMode()' method in the CPU bean */
%endif
  }
#if 0
  /* hmm, u16StatusContent is local to the Transceiver ISR routine: a left over thing???? */
  if ((u16StatusContent & %@MC13192@'ModuleName'%.CCA_BIT_MASK) == 0) {
    return 0; %>%CTAB /* Clear */
  } else {
    return 1; %>%CTAB /* BUSY */
  }
#else
  return 0; %>%CTAB /* Clear */
#endif
}

%endif %- PLMECCARequest
%-BW_METHOD_END PLMECCARequest
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMELinkQuality
%ifdef PLMELinkQuality
%define! RetVal
%include Common\SPHYPLMELinkQuality.Inc
/*!
 * \brief Report energy from last successful RX packet.
 * \return Energy
 * \note Actual power returned is: -(power/2) \n
 *     Global calibration required for accuracy.
 */
byte %'ModuleName'%.%PLMELinkQuality(void)
{
  word u16Reg;
  byte u8Power;

  u16Reg = %@MC13192@'ModuleName'%.Read(%@MC13192@'ModuleName'%.CCA_RESULT_ADDR);
  u8Power = (byte)((u16Reg & 0xFF00) >> 8);
  return u8Power;
}

%endif %- PLMELinkQuality
%-BW_METHOD_END PLMELinkQuality
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMEGetTimeRequest
%ifdef PLMEGetTimeRequest
%define! RetVal
%include Common\SPHYPLMEGetTimeRequest.Inc
/*!
 * \brief Get MC13192 timer value.
 * \return Timer value
 */
dword %'ModuleName'%.%PLMEGetTimeRequest(void)
{
  dword u32UpperWord, u32LowerWord;
  dword u32CurrentTime;

  %'ProcessorModule'%.DisableInt();               %>%CTAB /* Disable Interrupts */
  u32UpperWord = %@MC13192@'ModuleName'%.Read(%@MC13192@'ModuleName'%.TIMESTAMP_HI_ADDR);
  u32LowerWord = %@MC13192@'ModuleName'%.Read(%@MC13192@'ModuleName'%.TIMESTAMP_LO_ADDR);
  u32UpperWord &= %@MC13192@'ModuleName'%.TIMESTAMP_HI_MASK;              %>%CTAB /* Clears TS_HELD bit. */
  u32CurrentTime = (dword) (u32UpperWord << 16) | u32LowerWord;
  %'ProcessorModule'%.EnableInt();                %>%CTAB /* Enable Interrupts */
  return u32CurrentTime;
}

%endif %- PLMEGetTimeRequest
%-BW_METHOD_END PLMEGetTimeRequest
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMESetMC13192ClockRate
%ifdef PLMESetMC13192ClockRate
%define! Paru8Freq
%define! RetVal
%include Common\SPHYPLMESetMC13192ClockRate.Inc
#if 0 /* implemented as macro in the header file */
/*!
 * \brief Set MC13192 CLKo frequency.
 * \param u8Freq Frequency value
 * \return Status
 */
byte %'ModuleName'%.%PLMESetMC13192ClockRate(byte u8Freq)
{
}
#endif

%endif %- PLMESetMC13192ClockRate
%-BW_METHOD_END PLMESetMC13192ClockRate
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMESetMC13192TmrPrescale
%ifdef PLMESetMC13192TmrPrescale
%define! Parfreq
%define! RetVal
%include Common\SPHYPLMESetMC13192TmrPrescale.Inc
/*!
 * \brief Set MC13192 timer frequency.
 * \param freq Frequency value
 * \return Status
 */
byte %'ModuleName'%.%PLMESetMC13192TmrPrescale(byte freq)
{
  word current_value;

  current_value = %@MC13192@'ModuleName'%.Read(%@MC13192@'ModuleName'%.PRESCALE_ADDR);
  current_value &= 0xFFF8;
  current_value |= freq;
  %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.PRESCALE_ADDR, current_value);
  return %'ModuleName'%.SUCCESS;
}

%endif %- PLMESetMC13192TmrPrescale
%-BW_METHOD_END PLMESetMC13192TmrPrescale
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMESetTimeRequest
%ifdef PLMESetTimeRequest
%define! Paru32RequestedTime
%include Common\SPHYPLMESetTimeRequest.Inc
void %'ModuleName'%.%PLMESetTimeRequest(dword u32RequestedTime)
{
  word u16UpperWord, u16LowerWord;
  word u16Mode2RegVal;

  /* Split 32 bit input into 2 16 bit values */
  u16UpperWord = (word)((u32RequestedTime >> 16) & 0x000000FF);
  u16LowerWord = (word)(u32RequestedTime & 0x0000FFFF);
  /* Program Time1 comparator with the desired value */
  %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.T1_HI_ADDR, u16UpperWord);
  %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.T1_LO_ADDR, u16LowerWord);
  /* Get current state of the MODE2 MC13192 register */
  u16Mode2RegVal = %@MC13192@'ModuleName'%.Read(%@MC13192@'ModuleName'%.MODE2_ADDR);
  /* Set the Tmr_load bit */
  u16Mode2RegVal |= 0x8000;
  /* Now write the value back to MC13192 register MODE2 */
  %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.MODE2_ADDR, u16Mode2RegVal);
  /* Clear the tmr_load bit */
  u16Mode2RegVal &= 0x7FFF;
  /* Clr the tmr_load bit to prepare for next set_time_request. */
  %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.MODE2_ADDR, u16Mode2RegVal);
}

%endif %- PLMESetTimeRequest
%-BW_METHOD_END PLMESetTimeRequest
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMEEnableMC13192Timer1
%ifdef PLMEEnableMC13192Timer1
%define! Paru32CounterValue
%define! RetVal
%include Common\SPHYPLMEEnableMC13192Timer1.Inc
/*!
 * \brief Set MC13192 timer compare value.
 * \param u32CounterValue
 * \return Status
 */
byte %'ModuleName'%.%PLMEEnableMC13192Timer1(dword u32CounterValue)
{
  /* Load the timeout value into T1 with Timer disabled. */
  %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.T1_HI_ADDR, (word)(((u32CounterValue >> 16) & 0x000000FF)|0x000080FF));
  %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.T1_LO_ADDR, (word)(u32CounterValue & 0x0000FFFF));
  /* Turn Timer1 mask on. */
  %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.T1_HI_ADDR, (word)((u32CounterValue >> 16) & 0x000000FF));
  %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.T1_LO_ADDR, (word)(u32CounterValue & 0x0000FFFF));
  return %'ModuleName'%.SUCCESS;
}

%endif %- PLMEEnableMC13192Timer1
%-BW_METHOD_END PLMEEnableMC13192Timer1
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMEDisableMC13192Timer1
%ifdef PLMEDisableMC13192Timer1
%define! RetVal
%include Common\SPHYPLMEDisableMC13192Timer1.Inc
 /*!
 * \brief Disable MC13192 timer comparator TC1.
 * \return Status
 */
byte %'ModuleName'%.%PLMEDisableMC13192Timer1(void)
{
  /* Load the timeout value into T1 with Timer disabled. */
  /* Clear Timer1 if in RX_MODE_WTO */
  %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.T1_HI_ADDR, 0x8000);
  %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.T1_LO_ADDR, 0x0000);
  //irq_mask_reg = SPIDrvRead(%@MC13192@'ModuleName'%.IRQ_MASK);      %>%CTAB /* NOT USED */
  //irq_mask_reg &= ~%@MC13192@'ModuleName'%.TIMER1_IRQMASK_BIT;
  //SPIDrvWrite(%@MC13192@'ModuleName'%.IRQ_MASK, irq_mask_reg);
  return %'ModuleName'%.SUCCESS;
}

%endif %- PLMEDisableMC13192Timer1
%-BW_METHOD_END PLMEDisableMC13192Timer1
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMEMC13192SoftReset
%ifdef PLMEMC13192SoftReset
%define! RetVal
%include Common\SPHYPLMEMC13192SoftReset.Inc
/*!
 * \brief Force the MC13192 into a soft reset condition.
 * \return Status
 */
byte %'ModuleName'%.%PLMEMC13192SoftReset(void)
{
  %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.RESET, 0x00);
  return %'ModuleName'%.SUCCESS;
}

%endif %- PLMEMC13192SoftReset
%-BW_METHOD_END PLMEMC13192SoftReset
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMEMC13192XtalAdjust
%ifdef PLMEMC13192XtalAdjust
%define! Paru8TrimValue
%define! RetVal
%include Common\SPHYPLMEMC13192XtalAdjust.Inc
/*!
 * \brief Adjust the MC13192s crystal trim value.
 * \param u8TrimValue Trim value
 * \return Status
 */
byte %'ModuleName'%.%PLMEMC13192XtalAdjust(byte u8TrimValue)
{
  word u16Reg;
  word u16RegValue;

  u16RegValue = (word)(u8TrimValue << 8);            %>%CTAB /* Shift the req value into the higher half word */
  u16Reg = %@MC13192@'ModuleName'%.Read(%@MC13192@'ModuleName'%.XTAL_ADJ_ADDR);    %>%CTAB /* Read the current value of XTAL Reg */
  u16Reg = (word)((u16Reg & 0x00FF) | u16RegValue);
  %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.XTAL_ADJ_ADDR, u16Reg);
  return %'ModuleName'%.SUCCESS;
}

%endif %- PLMEMC13192XtalAdjust
%-BW_METHOD_END PLMEMC13192XtalAdjust
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMEMC13192FEGainAdjust
%ifdef PLMEMC13192FEGainAdjust
%define! Pari8GainValue
%define! RetVal
%include Common\SPHYPLMEMC13192FEGainAdjust.Inc
/*!
 * \brief Adjust the MC13192s gain compensator.
 * \param i8GainValue Gain Compensation
 * \return Status
 */
byte %'ModuleName'%.%PLMEMC13192FEGainAdjust(byte i8GainValue)
{
  word u16Reg;

  u16Reg = %@MC13192@'ModuleName'%.Read(%@MC13192@'ModuleName'%.FEGAIN_ADDR);       %>%CTAB /* Read the current value of GAIN Reg */
  u16Reg = (word)((u16Reg & 0xFF00) | i8GainValue);
  %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.FEGAIN_ADDR, u16Reg);
  return %'ModuleName'%.SUCCESS;
}

%endif %- PLMEMC13192FEGainAdjust
%-BW_METHOD_END PLMEMC13192FEGainAdjust
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMEMC13192PAOutputAdjust
%ifdef PLMEMC13192PAOutputAdjust
%define! Paru8RequestedPAValue
%define! RetVal
%include Common\SPHYPLMEMC13192PAOutputAdjust.Inc
byte %'ModuleName'%.%PLMEMC13192PAOutputAdjust(byte u8RequestedPAValue)
{
  word u16Reg;
  byte u8PAValue;

  switch (u8RequestedPAValue) {
    case %@MC13192@'ModuleName'%.MAX_POWER:      %>%CTAB /* Sets the PA drive level and PA gain to MAX */
      u8PAValue = 0xFF;
      break;
    case %@MC13192@'ModuleName'%.MIN_POWER:
      u8PAValue = 0x00;  %>%CTAB /* Sets the PA drive level and PA gain to MIN */
      break;
    default:
      if (u8RequestedPAValue > 15) {
        return %@MC13192@'ModuleName'%.OVERFLOW;
      } else {
        u8PAValue = u8RequestedPAValue;
      }
      break;
  }
  u16Reg = %@MC13192@'ModuleName'%.Read(%@MC13192@'ModuleName'%.PA_ADJUST_ADDR);   %>%CTAB /* Read the current value of GAIN Register */
  u16Reg &= 0xFF00;
  if ((u8RequestedPAValue == %@MC13192@'ModuleName'%.MAX_POWER) || (u8RequestedPAValue == %@MC13192@'ModuleName'%.MIN_POWER)) {
    u16Reg |= u8PAValue;
  } else {
    u16Reg |= ((u8PAValue << 4) | 0x000C);
  }
  %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.PA_ADJUST_ADDR, u16Reg);
  return %'ModuleName'%.SUCCESS;
}

%endif %- PLMEMC13192PAOutputAdjust
%-BW_METHOD_END PLMEMC13192PAOutputAdjust
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMEGetRficVersion
%ifdef PLMEGetRficVersion
%define! RetVal
%include Common\SPHYPLMEGetRficVersion.Inc
/*!
 * \brief Returns the RFIC version number.
 * \return Version number
 */
byte %'ModuleName'%.%PLMEGetRficVersion(void)
{
  word u16Reg;

  u16Reg = %@MC13192@'ModuleName'%.Read(%@MC13192@'ModuleName'%.VERSION_REG);   %>%CTAB /* Read the version register version[12:10] */
  u16Reg &= %@MC13192@'ModuleName'%.VERSION_MASK;                         %>%CTAB /* Shift to generate accurate number */
  u16Reg = (word)(u16Reg >> 8);                   %>%CTAB /* Hard coded to shift, will lose one bit out of 9 */
  return (byte)u16Reg;
}

%endif %- PLMEGetRficVersion
%-BW_METHOD_END PLMEGetRficVersion
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMELoadPRBS9
%ifdef PLMELoadPRBS9
%define! PartTxPacket
%include Common\SPHYPLMELoadPRBS9.Inc
/*!
 * \brief Loads the transmit RAM with a PRBS9 data pattern.
 * \param  *psPacket Transmit buffer pointer
 */
void %'ModuleName'%.%PLMELoadPRBS9(tTxPacket *psPacket)
{
  byte u8c1;      %>%CTAB /* Byte counter */
  byte u8c2;      %>%CTAB /* Bit counter */
  word u16t1;     %>%CTAB /* LFSR */
  word u16t2;     %>%CTAB /* LFSR output */
  word u16t3;     %>%CTAB /* LFSR feedback tap */
  byte u8t4;      %>%CTAB /* Assembled transmit byte */

  u16t1 = 0x01FF;                      %>%CTAB /* Initialize the LFSR */
  for (u8c1=0; u8c1<64; u8c1++) {      %>%CTAB /* Byte counter */
    u8t4 = 0x00;                       %>%CTAB /* Initialize the byte */
    for (u8c2=0; u8c2<8; u8c2++) {     %>%CTAB /* Bit counter */
      u16t2 = (word)(u16t1 & 0x0001);  %>%CTAB /* LFSR output */
      if (u16t2 == 0x0001) {
        u8t4 = (byte)(u8t4 | 0x80);    %>%CTAB /* Set/Clear byte based on LFSR output */
      }
      if (u8c2 != 7) {
        u8t4 = (byte)(u8t4 >> 1);      %>%CTAB /* LSBit will be first bit out of LFSR */
      }
      u16t3 = (word)((u16t1 & 0x0010) >> 4); %>%CTAB /* LFSR tap */
      u16t1 = (word)(u16t1 >> 1);      %>%CTAB /* Now shift the LFSR */
      if (u16t2 == u16t3) {            %>%CTAB /* Set/Clr the LFSR MSBit */
        u16t1 = (word)(u16t1 & 0xFEFF);
      } else {
        u16t1 = (word)(u16t1 | 0x0100);
      }
    }
    psPacket->pu8Data[u8c1] = u8t4;
  }
  psPacket->u8DataLength = 64;
  %@MC13192@'ModuleName'%.WriteTx(psPacket); %>%CTAB /* Load the data into packet RAM */
}

%endif %- PLMELoadPRBS9
%-BW_METHOD_END PLMELoadPRBS9
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMEEnablePromiscuousMode
%ifdef PLMEEnablePromiscuousMode
%define! RetVal
%include Common\SPHYPLMEEnablePromiscuousMode.Inc
byte %'ModuleName'%.%PLMEEnablePromiscuousMode(void)
{
%if AllowPromiscuousMode = 'yes'
  %'ModuleName'%.gsPhyOptions.Bits.u1PromiscuousMode = TRUE;
%endif
  return SUCCESS;
}

%endif %- PLMEEnablePromiscuousMode
%-BW_METHOD_END PLMEEnablePromiscuousMode
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMEDisablePromiscuousMode
%ifdef PLMEDisablePromiscuousMode
%define! RetVal
%include Common\SPHYPLMEDisablePromiscuousMode.Inc
byte %'ModuleName'%.%PLMEDisablePromiscuousMode(void)
{
%if AllowPromiscuousMode = 'yes'
  %'ModuleName'%.gsPhyOptions.Bits.u1PromiscuousMode = FALSE;
%endif
  return %'ModuleName'%.SUCCESS;
}

%endif %- PLMEDisablePromiscuousMode
%-BW_METHOD_END PLMEDisablePromiscuousMode
%-INHERITED_EVENT_BEGIN MC13192 DataIndication
%ifdef @MC13192@DataIndication
%include Common\GeneralInternal.inc (DataIndication)
void %@MC13192@DataIndication(void)
{
  %ifdef DataIndication
  %DataIndication();    %>%CTAB /* call own handler (if enabled) */
  %endif DataIndication
  /* Read the Data only if it is a good packet. */
  if (%@MC13192@'ModuleName'%.psDrvRxPacket->u8Status == %@MC13192@'ModuleName'%.SUCCESS) {
    (void)%@MC13192@'ModuleName'%.ReadRx(%@MC13192@'ModuleName'%.psDrvRxPacket); %>%CTAB /* Read data from MC13192, check status */
  }
%if %EnableInterruptsInDataIndication='yes'
#if 1 /* Interrupts re-enabled in interrupt routine, as configured in the component properties */
%else
#if 0 /* Interrupts remain disabled in interrupt routine, as configured in the component properties */
%endif
  /* NOTE: re-enabling interrupts within an interrupt service is usually a very bad thing! */
  %'ProcessorModule'%.EnableInt();       %>%CTAB /* Allow system interrupts within the IRQ handler */
#endif
   %if %SecurityEnabled='yes'
  (void)%@SecurityInterface@'ModuleName'%.Decrypt(%@MC13192@'ModuleName'%.psDrvRxPacket->pu8Data, &%@MC13192@'ModuleName'%.psDrvRxPacket->u8DataLength);
  %endif
%if OTAPenabled='yes'
  if (gu8OTAPStatusAPI == OTAP_ACTIVE){
    OTAPDataIndication(%@MC13192@'ModuleName'%.psDrvRxPacket);
  } else {
   %DataIndicationPacket(%@MC13192@'ModuleName'%.psDrvRxPacket);
  }
%else
  %DataIndicationPacket(%@MC13192@'ModuleName'%.psDrvRxPacket);
%endif
}

%endif %- @MC13192@DataIndication
%-INHERITED_EVENT_END MC13192 DataIndication
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMETestMode
%ifdef PLMETestMode
%define! ParpsPacket
%define! Paru8Mode
%define! Paru8mode
%include Common\SPHYPLMETestMode.Inc
/*!
 * \brief Execute a test mode
 * \param *psPacket Packet pointer
 * \param u8mode desired test mode
 */
void %'ModuleName'%.%PLMETestMode(tTxPacket *psPacket, byte u8mode)
{
  word u16reg;
  dword i;

  switch (u8mode) {
    case %@MC13192@'ModuleName'%.PULSE_TX_PRBS9:
      /* Continuously transmit a PRBS9 pattern. */
      %'ModuleName'%.PLMELoadPRBS9(psPacket);               %>%CTAB /* Load the TX RAM */
      (void)%'ModuleName'%.PLMESetTrxStateRequest(%@MC13192@'ModuleName'%.PULSE_TX_MODE); %>%CTAB /* transmit it. Interrupt routine will retransmit after completion */
      break;

    case %@MC13192@'ModuleName'%.FORCE_IDLE:
      /* Sets the device back to original IDLE mode. */
      %@MC13192@'ModuleName'%.DisableInterrupts();                %>%CTAB /* Mask off interrupts from MC13192 */
      %@MC13192@'ModuleName'%.RTXENDeAssert();                    %>%CTAB /* Force MC13192 to IDLE */
      %@MC13192@'ModuleName'%.gu8RTxMode = %@MC13192@'ModuleName'%.IDLE_MODE;                               %>%CTAB /* set the SW mode to IDLE */
      %@MC13192@'ModuleName'%.EnableInterrupts();
      for (i=0; i < 200; i++) {} %>%CTAB /* Empty Loop */
      (void)%'ModuleName'%.PLMESetTrxStateRequest(%@MC13192@'ModuleName'%.IDLE_MODE);  %>%CTAB /* Set to IDLE */
      u16reg = %@MC13192@'ModuleName'%.Read(%@MC13192@'ModuleName'%.BER_REG);             %>%CTAB /* Turn off BER mode */
      u16reg = (word)(u16reg & ~(%@MC13192@'ModuleName'%.BER_MASK));
      %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.BER_REG,u16reg);
      u16reg = %@MC13192@'ModuleName'%.Read(%@MC13192@'ModuleName'%.PSM_REG);             %>%CTAB /* Turn off PSM test mode */
      u16reg = (word)(u16reg & ~(%@MC13192@'ModuleName'%.PSM_MASK));
      %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.PSM_REG,u16reg);

      u16reg = %@MC13192@'ModuleName'%.Read(%@MC13192@'ModuleName'%.PAEN_REG);            %>%CTAB /* dis-enable the PA */
      u16reg = (word)(u16reg & ~%@MC13192@'ModuleName'%.PAEN_MASK);
      %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.PAEN_REG,u16reg);

      (void)%'ModuleName'%.PLMESetTrxStateRequest(%@MC13192@'ModuleName'%.TX_MODE); %>%CTAB /* Realign TX */

      u16reg = %@MC13192@'ModuleName'%.Read(%@MC13192@'ModuleName'%.PAEN_REG);            %>%CTAB /* enable the PA */
      u16reg = (word)(u16reg | %@MC13192@'ModuleName'%.PAEN_MASK);
      %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.PAEN_REG,u16reg);
      break;

    case %@MC13192@'ModuleName'%.CONTINUOUS_RX:
      /* Sets the device into continuous RX mode */
      u16reg = %@MC13192@'ModuleName'%.Read(%@MC13192@'ModuleName'%.BER_REG);              %>%CTAB /* Turn on BER mode */
      u16reg = (word)(u16reg | %@MC13192@'ModuleName'%.BER_MASK);
      %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.BER_REG,u16reg);
      (void)%'ModuleName'%.PLMESetTrxStateRequest(%@MC13192@'ModuleName'%.RX_MODE);  %>%CTAB /* Turn the receiver on */
      break;

    case %@MC13192@'ModuleName'%.CONTINUOUS_TX_MOD:
      /* Sets the device to continuously transmit a 10101010 pattern */
      %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.TX_PKT,0xAAAA);                %>%CTAB /* Load the test pattern */
      u16reg = %@MC13192@'ModuleName'%.Read(%@MC13192@'ModuleName'%.PAEN_REG);             %>%CTAB /* Disable the PA */
      u16reg = (word)(u16reg & ~(%@MC13192@'ModuleName'%.PAEN_MASK));
      %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.PAEN_REG,u16reg);
      u16reg = %@MC13192@'ModuleName'%.Read(%@MC13192@'ModuleName'%.TX_PKT_LEN);           %>%CTAB /* Set the length field */
      u16reg = (word)((u16reg & ~(%@MC13192@'ModuleName'%.TX_PKT_LEN_MASK)) | 0x0004);
      %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.TX_PKT_LEN,u16reg);
      (void)%'ModuleName'%.PLMESetTrxStateRequest(%@MC13192@'ModuleName'%.TX_MODE);  %>%CTAB /* Do a transmit to initialize */
      while (%@MC13192@'ModuleName'%.gu8RTxMode != %@MC13192@'ModuleName'%.IDLE_MODE) {}                     %>%CTAB /* Wait till done */
      u16reg = %@MC13192@'ModuleName'%.Read(%@MC13192@'ModuleName'%.PAEN_REG);             %>%CTAB /* Re-enable the PA */
      u16reg = (word)(u16reg | %@MC13192@'ModuleName'%.PAEN_MASK);
      %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.PAEN_REG,u16reg);
      u16reg = %@MC13192@'ModuleName'%.Read(%@MC13192@'ModuleName'%.BER_REG);              %>%CTAB /* Turn on BER mode */
      u16reg = (word)(u16reg | %@MC13192@'ModuleName'%.BER_MASK);
      %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.BER_REG,u16reg);
      (void)%'ModuleName'%.PLMESetTrxStateRequest(%@MC13192@'ModuleName'%.TX_MODE);  %>%CTAB /* Turn the transmitter on */
      break;

    case %@MC13192@'ModuleName'%.CONTINUOUS_TX_NOMOD:
      /* Sets the device to continuously transmit an unmodulated CW */
      u16reg = %@MC13192@'ModuleName'%.Read(%@MC13192@'ModuleName'%.PAEN_REG);             %>%CTAB /* Disable the PA */
      u16reg = (word)(u16reg & ~(%@MC13192@'ModuleName'%.PAEN_MASK));
      %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.PAEN_REG,u16reg);
      u16reg = %@MC13192@'ModuleName'%.Read(%@MC13192@'ModuleName'%.TX_PKT_LEN);           %>%CTAB /* Set the length field */
      u16reg = (word)((u16reg & ~(%@MC13192@'ModuleName'%.TX_PKT_LEN_MASK)) | 0x0004);
      %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.TX_PKT_LEN,u16reg);
      (void)%'ModuleName'%.PLMESetTrxStateRequest(%@MC13192@'ModuleName'%.TX_MODE);  %>%CTAB /* Do a transmit to initialize */
      while (%@MC13192@'ModuleName'%.gu8RTxMode != %@MC13192@'ModuleName'%.IDLE_MODE) {}                     %>%CTAB /* Wait till done */
      u16reg = %@MC13192@'ModuleName'%.Read(%@MC13192@'ModuleName'%.PAEN_REG);             %>%CTAB /* Re-enable the PA */
      u16reg = (word)(u16reg | %@MC13192@'ModuleName'%.PAEN_MASK);
      %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.PAEN_REG,u16reg);
      u16reg = %@MC13192@'ModuleName'%.Read(%@MC13192@'ModuleName'%.BER_REG);              %>%CTAB /* Turn on BER mode */
      u16reg = (word)(u16reg | %@MC13192@'ModuleName'%.BER_MASK);
      %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.BER_REG,u16reg);
      u16reg = %@MC13192@'ModuleName'%.Read(%@MC13192@'ModuleName'%.PSM_REG);              %>%CTAB /* Turn off PSM */
      u16reg = (word)(u16reg | %@MC13192@'ModuleName'%.PSM_MASK);
      %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.PSM_REG,u16reg);
      (void)%'ModuleName'%.PLMESetTrxStateRequest(%@MC13192@'ModuleName'%.TX_MODE);  %>%CTAB /* Turn the transmitter on */
      break;
  }
}

%endif %- PLMETestMode
%-BW_METHOD_END PLMETestMode
%-************************************************************************************************************
%-BW_METHOD_BEGIN Write
%ifdef Write
%define! Paraddr
%define! Parval
%include Common\SPHYWrite.Inc
/*
void %'ModuleName'%.%Write(byte addr, word val)
  ** This method is implemented as macro
*/

%endif %- Write
%-BW_METHOD_END Write
%-************************************************************************************************************
%-BW_METHOD_BEGIN Read
%ifdef Read
%define! Paraddr
%define! RetVal
%include Common\SPHYRead.Inc
/*
word %'ModuleName'%.%Read(byte addr)
  ** This method is implemented as macro
*/

%endif %- Read
%-BW_METHOD_END Read
%-************************************************************************************************************
%-BW_METHOD_BEGIN RadioInit
%ifdef RadioInit
%include Common\SPHYRadioInit.Inc
/*
void %'ModuleName'%.%RadioInit(void)
  ** This method is implemented as macro
*/

%endif %- RadioInit
%-BW_METHOD_END RadioInit
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMEGetGPIObyte
%ifdef PLMEGetGPIObyte
%define! RetVal
%include Common\SPHYPLMEGetGPIObyte.Inc
byte %'ModuleName'%.%PLMEGetGPIObyte(void)
{
  return (byte)((%@MC13192@'ModuleName'%.Read(%@MC13192@'ModuleName'%.GPIO_DATA_IN_REG)&0x7F00)>>8);   %>%CTAB /* Read the data word and mask the bits */
}

%endif %- PLMEGetGPIObyte
%-BW_METHOD_END PLMEGetGPIObyte
%-************************************************************************************************************
%-BW_METHOD_BEGIN PLMEPutGPIObyte
%ifdef PLMEPutGPIObyte
%define! Pardata
%include Common\SPHYPLMEPutGPIObyte.Inc
void %'ModuleName'%.%PLMEPutGPIObyte(byte data)
{
  word w;

  w = %@MC13192@'ModuleName'%.Read(%@MC13192@'ModuleName'%.GPIO_DATA); %>%CTAB /* read first the register content, as the data bits are shared with other settings */
  w &= 0xFF80;                           %>%CTAB /* clear data bits: the lower 7 bits are our data bits */
  w |= data;                             %>%CTAB /* build up new register content with data */
  %@MC13192@'ModuleName'%.Write(%@MC13192@'ModuleName'%.GPIO_DATA, w); %>%CTAB /* write back register */
}

%endif %- PLMEPutGPIObyte
%-BW_METHOD_END PLMEPutGPIObyte
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_METHOD_BEGIN DataIndicationPacket
%ifdef DataIndicationPacket
%IMPLEMENTATION DataIndicationPacket
%define! ParsRxPacket
%include Common\SPHYDataIndicationPacket.Inc
void %DataIndicationPacket(tRxPacket *sRxPacket)
{
  /* Write your code here ... */
}

%endif %- DataIndicationPacket
%-BW_METHOD_END DataIndicationPacket
%-BW_METHOD_BEGIN DataIndication
%ifdef DataIndication
%IMPLEMENTATION DataIndication
%include Common\SPHYDataIndication.Inc
void %DataIndication(void)
{
  /* Write your code here ... */
}

%endif %- DataIndication
%-BW_METHOD_END DataIndication
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
  (void)%'ModuleName'%.%PLMEPhyReset();
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This bean is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
