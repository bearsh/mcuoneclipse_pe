%-Driver generated by the Bean Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Bean Wizard
%- If you change these lines, Bean Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    25.09.2009
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%define! Description_ElementInitCommon 
%define! Description_PaintHeader Paints a header in the window
%define! Description_WindowAddElement Adds an element to the window
%define! Description_PaintText Prints a text
%define! Description_PaintButton Paints a button
%define! Description_PaintCheckBox Paints a checkbox element
%define! Description_PaintBarGraph Paints a bar graph chart
%define! Description_PaintScrollMenu Paints the scroll menu element item
%define! Description_NextElement Finds the next element
%define! Description_PrevElement Finds the previous element
%define! Description_PaintIcon Paints the icon item
%define! Description_UpdateElementNoRefresh Paints an element to the window, with no explicit refresh
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\UserInterfaceSettings.Inc
%define! Abstract Common\UserInterfaceAbstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited beans */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"
#include <stddef.h> /* for size_t */

typedef enum {                                                   %>40/* this lists all the different element types supported */
  %'ModuleName'_WIDGET_SPACE,                                    %>40/* generic rectangle space (transparent) */
  %'ModuleName'_WIDGET_SCREEN,                                   %>40/* screen element, top element */
  %'ModuleName'_WIDGET_WINDOW,                                   %>40/* window element */
  %'ModuleName'_WIDGET_HEADER,                                   %>40/* header on top of window */
  %'ModuleName'_WIDGET_BUTTON,                                   %>40/* button which can be pressed */
  %'ModuleName'_WIDGET_CHECKBOX,                                 %>40/* checkbox element (checked or unchecked) */
  %'ModuleName'_WIDGET_TEXT,                                     %>40/* text element (both static and dynamic text */
  %'ModuleName'_SCROLLMENU,                                      %>40/* menu item which scrolls text on click. Similar like a drop down box. */
  %'ModuleName'_BARGRAPH,                                        %>40/* widget a bar graph*/
  %'ModuleName'_WIDGET_BARGRAPH,                                 %>40/* widget a bar graph*/
  %'ModuleName'_WIDGET_ICON,                                     %>40/* widget for an icon/symbol */
  %'ModuleName'_WIDGET_SLIDER,                                   %>40/* widget for a slider */

  %'ModuleName'_SPACE,                                           %>40/* generic rectangle space (transparent) */
  %'ModuleName'_WINDOW,                                          %>40/* window element */
  %'ModuleName'_HEADER,                                          %>40/* header on top of window */
  %'ModuleName'_BUTTON,                                          %>40/* button which can be pressed */
  %'ModuleName'_CHECKBOX,                                        %>40/* checkbox element (checked or unchecked) */
  %'ModuleName'_TEXT,                                            %>40/* text element (both static and dynamic text */
  %'ModuleName'_CALENDARDAY,                                     %>40/* widget showing a calendar day */
  %'ModuleName'_ICON,                                            %>40/* widget for an icon/symbol */
  %'ModuleName'_GRAPH                                            %>40/* widget for line graph */
} %'ModuleName'_ElementType;

typedef enum {                                                   %>40/* this lists all the different event callback argument types supported */
  %'ModuleName'_EVENT_ELEMENT_SELECT,                            %>40/* event for selecting an element */
  %'ModuleName'_EVENT_ELEMENT_DESELECT,                          %>40/* event for deselecting an element */
  %'ModuleName'_EVENT_ELEMENT_MOVE_OUT,                          %>40/* event called if cursor moved out of an element */
  %'ModuleName'_EVENT_WINDOW_CLOSE,                              %>40/* event for closing a window */
  %'ModuleName'_EVENT_CLICK,                                     %>40/* event for pressing a button/click (short click). Needed for animated buttons */
  %'ModuleName'_EVENT_CLICK_MOVE,                                %>40/* event for moving cursor while clicked (e.g. with a touch screen). Passes %'ModuleName'_Coordinate as data argument in the event callback */
  %'ModuleName'_EVENT_CLICK_RELEASE,                             %>40/* event for a short click release */
  %'ModuleName'_EVENT_CLICK_LONG,                                %>40/* event for a long click (at release time) */
  %'ModuleName'_EVENT_CALENDARDAY_APPOINTMENT_CLICK,             %>40/* event for clicking on a calendar day appointment */
  %'ModuleName'_EVENT_CALENDARDAY_APPOINTMENT_CLICK_LONG,        %>40/* event for long clicking on a calendar day appointment */
  /*button specific */
  %'ModuleName'_EVENT_BUTTON_PRESSED,                            %>40/* event for pressing a button */
  %'ModuleName'_EVENT_RELEASE_BUTTON,                            %>40/* event for releasing a button */
  /*slider specific */
  %'ModuleName'_EVENT_SLIDER_VAL_CHANGE,
  /*display specific */
  %'ModuleName'_EVENT_PRE_ORIENTATION_CHANGE,                    %>40/* event called before a display orientation change */
  %'ModuleName'_EVENT_ORIENTATION_CHANGE,                        %>40/* event called after the orientation change, before doing an update */
  %'ModuleName'_EVENT_POST_ORIENTATION_CHANGE,                   %>40/* event called after a display orientation change and update */
  %'ModuleName'_EVENT_PAINT                                      %>40/* event called for painting the element */
} %'ModuleName'_EventCallbackKind;

typedef enum _UIIconType {
  %'ModuleName'_ICON_ARROW_LEFT,                                 %>40/* left arrow icon */
  %'ModuleName'_ICON_ARROW_RIGHT,                                %>40/* right arrow icon */
  %'ModuleName'_ICON_ARROW_UP,                                   %>40/* up arrow icon */
  %'ModuleName'_ICON_ARROW_DOWN,                                 %>40/* down arrow icon */
  %'ModuleName'_ICON_CLOSE                                       %>40/* X shape */
} %'ModuleName'_IconType;

%if SelectionEnabled='yes'
#define %'ModuleName'_CAN_SELECT_ELEMENTS  1                     %>40/* We can select elements (this will need some more resources) */
%else
#define %'ModuleName'_CAN_SELECT_ELEMENTS  0                     %>40/* We cannot select elements (using additional resources) */
%endif %- SelectElement
%if AnimatedButtons='yes'
#define %'ModuleName'_ANIMATED_BUTTONS     1                     %>40/* Support for animated buttons. For a click pass both pass %'ModuleName'_EVENT_CLICK and then %'ModuleName'_EVENT_CLICK_RELEASE or %'ModuleName'_EVENT_CLICK_RELEASE_LONG %'ModuleName'_ClickSelectedElement()*/
%else
#define %'ModuleName'_ANIMATED_BUTTONS     0                     %>40/* No support for animated buttons. In that case only pass %'ModuleName'_EVENT_CLICK to %'ModuleName'_ClickSelectedElement(). */
%endif
%ifdef FixedFont
#define %'ModuleName'_USE_FIXED_FONT       1                     %>40/* We are using a fixed font for our UI elements to save ROM/RAM */
#define %'ModuleName'_FIXED_FONT()         %@FixedFont@'ModuleName'%.GetFont() /* the fixed font */
%else
#define %'ModuleName'_USE_FIXED_FONT       0                     %>40/* We can use multiple fonts, but his will require more resources */
#define %'ModuleName'_FIXED_FONT()         /* nothing */
%endif
%ifdef FixedTextForegroundColor
#define %'ModuleName'_USE_FIXED_TXT_COLOR  1                     %>40/* We are using a fixed foreground text color */
%else
#define %'ModuleName'_USE_FIXED_TXT_COLOR  0                     %>40/* We are using a fixed foreground text color */
%endif

#define %'ModuleName'%.COLOR_BLACK              %@Display@'ModuleName'%.COLOR_BLACK           /* black color */
#define %'ModuleName'%.COLOR_WHITE              %@Display@'ModuleName'%.COLOR_WHITE           /* white color */
#define %'ModuleName'%.COLOR_RED                %@Display@'ModuleName'%.COLOR_RED             /* red color */
#define %'ModuleName'%.COLOR_BRIGHT_RED         %@Display@'ModuleName'%.COLOR_BRIGHT_RED      /* bright red color */
#define %'ModuleName'%.COLOR_DARK_RED           %@Display@'ModuleName'%.COLOR_DARK_RED        /* dark red color */
#define %'ModuleName'%.COLOR_GREEN              %@Display@'ModuleName'%.COLOR_GREEN           /* green color */
#define %'ModuleName'%.COLOR_DARK_GREEN         %@Display@'ModuleName'%.COLOR_DARK_GREEN      /* dark green color */
#define %'ModuleName'%.COLOR_BRIGHT_GREEN       %@Display@'ModuleName'%.COLOR_BRIGHT_GREEN    /* bright green color */
#define %'ModuleName'%.COLOR_BLUE               %@Display@'ModuleName'%.COLOR_BLUE            /* blue color */
#define %'ModuleName'%.COLOR_BRIGHT_BLUE        %@Display@'ModuleName'%.COLOR_BRIGHT_BLUE     /* bright blue color */
#define %'ModuleName'%.COLOR_DARK_BLUE          %@Display@'ModuleName'%.COLOR_DARK_BLUE       /* dark blue color */
#define %'ModuleName'%.COLOR_YELLOW             %@Display@'ModuleName'%.COLOR_YELLOW          /* yellow color */
#define %'ModuleName'%.COLOR_BRIGHT_YELLOW      %@Display@'ModuleName'%.COLOR_BRIGHT_YELLOW   /* bright yellow color */
#define %'ModuleName'%.COLOR_ORANGE             %@Display@'ModuleName'%.COLOR_ORANGE          /* orange color */
#define %'ModuleName'%.COLOR_GREY               %@Display@'ModuleName'%.COLOR_GREY            /* grey color */
#define %'ModuleName'%.COLOR_BRIGHT_GREY        %@Display@'ModuleName'%.COLOR_BRIGHT_GREY     /* bright grey color */

typedef %@Display@'ModuleName'%.PixelColor %'ModuleName'%.PixelColor;%>40/* type large enough to hold the color information */
typedef %@Display@'ModuleName'%.PixelDim   %'ModuleName'%.PixelDim;%>40/* type big enough to hold the x and y coordinates */
typedef GFONT_Callbacks   %'ModuleName'%.FontCallbacks;          %>40/* Callback to retrieve font information. */

/* wrappers for the low level display orientation enumeration and type */
typedef %@Display@'ModuleName'%.DisplayOrientation %'ModuleName'%.DisplayOrientation;
#define %'ModuleName'%.ORIENTATION_PORTRAIT     %@Display@'ModuleName'%.ORIENTATION_PORTRAIT
#define %'ModuleName'%.ORIENTATION_PORTRAIT180  %@Display@'ModuleName'%.ORIENTATION_PORTRAIT180
#define %'ModuleName'%.ORIENTATION_LANDSCAPE    %@Display@'ModuleName'%.ORIENTATION_LANDSCAPE
#define %'ModuleName'%.ORIENTATION_LANDSCAPE180 %@Display@'ModuleName'%.ORIENTATION_LANDSCAPE180

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;

%- %define _OPTIMIZE_CLEARED_BACKGROUND /* if we shall optimize using the fact that the background has been filled with a color. Still experimental... */

/* flags for elements */
#define %'ModuleName'_FLAGS_INIT            (0)                  %>40/* initial value of flags */
#define %'ModuleName'_FLAGS_NEEDS_REPAINT   (1<<0)               %>40/* elements needs to be repainted */
#define %'ModuleName'_FLAGS_IS_SUBWINDOW    (1<<1)               %>40/* elements is a subwindow */
#define %'ModuleName'_FLAGS_HEADER_HAS_LINE (1<<2)               %>40/* header has a bottom line */
#define %'ModuleName'_FLAGS_ALIGN_RIGHT     (1<<3)               %>40/* element is right aligned */
%if SelectionEnabled='yes'
/* selection flags */
#define %'ModuleName'_FLAGS_CAN_SELECT      (1<<4)               %>40/* flag indicating that the element can be selected */
#define %'ModuleName'_FLAGS_IS_SELECTED     (1<<5)               %>40/* flag indicating that the element is selected */
#define %'ModuleName'_FLAGS_CLICKED         (1<<6)               %>40/* flag indicating that the element is clicked */
%endif

/* window flags */
#define %'ModuleName'_FLAGS_WINDOW_INIT          (0)             %>40/* initial value of flags */
#define %'ModuleName'_FLAGS_WINDOW_IS_MODAL      (1<<0)          %>40/* window is modal (e.g. a dialog box) */
#define %'ModuleName'_FLAGS_WINDOW_HAS_BORDER    (1<<1)          %>40/* window has a border */
%ifdef _OPTIMIZE_CLEARED_BACKGROUND
#define %'ModuleName'_FLAGS_WINDOW_BG_CLEARED    (1<<2)          %>40/* window just has been cleared with background color */
%endif
/* --- Screen --- */
typedef struct {                                                 %>40/* This is the abstraction of a generic window, with all the needed information. */
  struct %'ModuleName'_Window *first;                            %>40/* pointer to first child/sub window */
%if SelectionEnabled='yes'
  struct %'ModuleName'_Window *selectedW;                        %>40/* pointer to the currently selected window */
%endif
  %'ModuleName'_PixelColor bgColor;                              %>40/* background color of the window */
  bool updateAll;                                                %>40/* If the screen needs to be updated as a whole */
} %'ModuleName'_Screen;

/* --- Screen content: window, ... */
typedef struct %'ModuleName'_ElementProperties {                 %>40/* Common properties for elements */
  %'ModuleName'_ElementType type;                                %>40/* type of the element */
  byte flags;                                                    %>40/* element flags */
  %'ModuleName'_PixelDim x;                                      %>40/* x coordinate */
  %'ModuleName'_PixelDim y;                                      %>40/* y coordinate */
  %'ModuleName'_PixelDim width;                                  %>40/* element width in pixels */
  %'ModuleName'_PixelDim height;                                 %>40/* element height in pixels */
  %'ModuleName'_PixelColor color;                                %>40/* color of element */
} %'ModuleName'_ElementProperties;

typedef struct {                                                 %>40/* Structure to describe a simple text helper for drawing text */
  %'ModuleName'_PixelDim deltaX, deltaY;                         %>40/* delta x and y from the element coordinates */
  unsigned char *text;                                           %>40/* Pointer to the text itself */
%ifndef FixedFont
  %'ModuleName'_FontCallbacks *font;                             %>40/* Font callbacks to be used for the text */
%endif
%ifndef FixedTextForegroundColor
  %'ModuleName'_PixelColor txtColor;                             %>40/* foreground color of text */
%endif
} %'ModuleName'_TextInfo;

typedef void *%'ModuleName'_Pvoid;                               %>40/* pointer to void */

typedef struct {
  %'ModuleName'_PixelDim x;                                      %>40/* x coordinate */
  %'ModuleName'_PixelDim y;                                      %>40/* y coordinate */
} %'ModuleName'_Coordinate;

/* --- Element --- */
typedef struct %'ModuleName'_Element {                           %>40/* This describes a generic UI element */
  %'ModuleName'_ElementProperties prop;                          %>40/* common properties of element */
  byte (*painter)(struct %'ModuleName'_Window *, struct %'ModuleName'_Element*);%>40/* painter callback routine */
  struct %'ModuleName'_Element *next;                            %>40/* pointer to the next element in list */
} %'ModuleName'_Element;

typedef struct %'ModuleName'_Element* %'ModuleName'%.PElement;   %>40/* Pointer to element */

/* --- Window: contains elements --- */
typedef struct %'ModuleName'_Window {                            %>40/* This is the abstraction of a generic window, with all the needed information. */
  %'ModuleName'_ElementProperties prop;                          %>40/* common properties of element */
  struct %'ModuleName'_Window *next;                             %>40/* pointer to next window */
  %'ModuleName'_Element *first;                                  %>40/* pointer to the first element in the list */
%if SelectionEnabled='yes'
  void (*eventCallback) (                                        %>40/* event called for a window element */
    struct %'ModuleName'_Window *window,                         %>40/* window where the event happend */
    %'ModuleName'_Element *element,                              %>40/* element for the event */
    %'ModuleName'_EventCallbackKind eventKind,                   %>40/* kind of event */
    %'ModuleName'_Pvoid pData                                    %>40/* optional data pointer */
  );
%endif
  %'ModuleName'_Element *parentE;                                %>40/* parent element, or NULL */
  %'ModuleName'_Element *selectedE;                              %>40/* pointer to the currently selected element */
  bool updateAll;                                                %>40/* If the window needs to be updated as a whole */
  byte flags;                                                    %>40/* window flags */
} %'ModuleName'_Window;

typedef %'ModuleName'_Screen *%'ModuleName'%.PScreen;            %>40/* Pointer to Screen element. */
typedef struct %'ModuleName'_Window *%'ModuleName'%.PWindow;     %>40/* Pointer to Window element. */
typedef bool (*%'ModuleName'_ElementFindFct)(%'ModuleName'_Screen*, %'ModuleName'_Window*, %'ModuleName'_Element*, void*);%>40/* Function pointer for finding an element */

/* --- Element: Space --- */
typedef struct {                                                 %>40/* element showing static text */
  %'ModuleName'_Element element;                                 %>40/* the base element, always first in structure */
} %'ModuleName'_Space;

/* --- Element: Text --- */
typedef struct {                                                 %>40/* element showing static text */
  %'ModuleName'_Element element;                                 %>40/* the base element, always first in structure */
  %'ModuleName'_TextInfo textInfo;                               %>40/* Information describing the text. Must be right after element */
} %'ModuleName'_Text;

/* --- Element: Header --- */
typedef struct {                                                 %>40/* The header of the window */
  %'ModuleName'_Element element;                                 %>40/* the base element, always first in structure */
  %'ModuleName'_TextInfo textInfo;                               %>40/* Information describing the text. Must be right after element */
} %'ModuleName'_Header;

/* --- Element: Checkbox --- */
typedef struct {
  %'ModuleName'_Element element;                                 %>40/* the base element, always first in structure */
  %'ModuleName'%.TextInfo textInfo;                              %>40/* information about the checkbox text. Must be right after element */
  bool isChecked;                                                %>40/* if the box is checked or not */
  %'ModuleName'_PixelColor boxBgColor;                           %>40/* background fill color or the box */
  %'ModuleName'_PixelColor boxLineColor;                         %>40/* foreground line color or the box */
} %'ModuleName'_CheckBox;

/* --- Element: Button --- */
typedef struct {
  %'ModuleName'_Element element;                                 %>40/* the base element, always first in structure */
  %'ModuleName'_TextInfo textInfo;                               %>40/* information about the button text. Must be right after element */
  bool isPressed;                                                %>40/* if button is pressed */
} %'ModuleName'_Button;

/* --- Element: BarGraph --- */
typedef struct {
  %'ModuleName'_Element element;                                 %>40/* the base element, always first in structure */
  byte borderWidth;                                              %>40/* width of the border in pixels. Zero means no border */
  %'ModuleName'_PixelColor borderColor;                          %>40/* color of border */
  byte borderSpace;                                              %>40/* space between bars and border */
  %'ModuleName'_PixelColor barColor;                             %>40/* color of bars */
  byte nofData;                                                  %>40/* number of data elements */
  byte *data;                                                    %>40/* pointer to data itself (values must be 0...100) */
} %'ModuleName'_BarGraph;

/* --- Element: ScrollMenu --- */
typedef struct {
  %'ModuleName'_Element element;                                 %>40/* the base element, always first in structure */
  %'ModuleName'_TextInfo textInfo;                               %>40/* information about the menu text. Must be right after element */
  %'ModuleName'_PixelColor boxBgColor;                           %>40/* background fill color or the box */
  %'ModuleName'_PixelColor boxLineColor;                         %>40/* foreground line color or the box */
  byte selectedItem;                                             %>40/* index of currently selected item. The items itself are part of the TextInfo, separated by \r */
} %'ModuleName'_ScrollMenu;

/* --- Element: Icon --- */
typedef struct {
  %'ModuleName'_Element element;                                 %>40/* the base element, always first in structure */
  %'ModuleName'_IconType type;
  %'ModuleName'_PixelColor fgColor;                              %>40/* foreground color */
  %'ModuleName'_PixelDim rightOffset;                            %>40/* if right aligned to window (%'ModuleName'_FLAGS_ALIGN_RIGHT), this is the offset */
} %'ModuleName'_Icon;

/* --- Element: SubWindow --- */
typedef struct {
  %'ModuleName'_Element element;                                 %>40/* the base element, always first in structure */
  %'ModuleName'_Window subWindow;                                %>40/* the (sub) window itself, must be right after element */
  %'ModuleName'_Window *parentWindow;                            %>40/* need pointer to parent window, so we could call the parent event handler */
} %'ModuleName'_SubWindow;

typedef byte (*%'ModuleName'_painterCallback) (%'ModuleName'_Window *window, %'ModuleName'_Element *element);%>40/* callback to be called to paint the element */
%-
%-BW_CUSTOM_USERTYPE_END


%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN CreateWindow
%ifdef CreateWindow
byte %'ModuleName'%.%CreateWindow(%'ModuleName'_Screen *screen, %'ModuleName'_Window *window, %'ModuleName'_PixelColor bgColor, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim width, %'ModuleName'_PixelDim height);
%define! Parwindow
%define! ParbgColor
%define! Parx
%define! Pary
%define! Parwidth
%define! Parheight
%define! Parscreen
%define! RetVal
%include Common\UserInterfaceCreateWindow.Inc

%endif %- CreateWindow
%-BW_METHOD_END CreateWindow
%-************************************************************************************************************
%-BW_METHOD_BEGIN CreateText
%ifdef CreateText
byte %'ModuleName'%.%CreateText(%'ModuleName'_Window *window, %'ModuleName'_Text *textElem, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim width, %'ModuleName'_PixelDim height, byte *text, %'ModuleName'_FontCallbacks *font);
%define! Parx
%define! Pary
%define! Parwidth
%define! Parheight
%define! Partext
%define! Parwindow
%define! Parfont
%define! PartextElem
%define! RetVal
%include Common\UserInterfaceCreateText.Inc

%endif %- CreateText
%-BW_METHOD_END CreateText
%-************************************************************************************************************
%-BW_METHOD_BEGIN CreateHeader
%ifdef CreateHeader
byte %'ModuleName'%.%CreateHeader(%'ModuleName'_Window *window, %'ModuleName'_Header *header, byte *text, %'ModuleName'_FontCallbacks *font, %'ModuleName'_PixelColor bgColor);
%define! Parwindow
%define! Parheader
%define! Partext
%define! ParbgColor
%define! Parfont
%define! RetVal
%include Common\UserInterfaceCreateHeader.Inc

%endif %- CreateHeader
%-BW_METHOD_END CreateHeader
%-************************************************************************************************************
%-BW_METHOD_BEGIN UpdateWindow
%ifdef UpdateWindow
void %'ModuleName'%.%UpdateWindow(%'ModuleName'_Window *window);
%define! Parwindow
%include Common\UserInterfaceUpdateWindow.Inc

%endif %- UpdateWindow
%-BW_METHOD_END UpdateWindow
%-************************************************************************************************************
%-BW_METHOD_BEGIN CreateCheckBox
%ifdef CreateCheckBox
byte %'ModuleName'%.%CreateCheckBox(%'ModuleName'_Window *window, %'ModuleName'_CheckBox *checkBox, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim width, %'ModuleName'_PixelDim height, %'ModuleName'_PixelColor boxLineColor, %'ModuleName'_PixelColor boxBgColor, byte *text, %'ModuleName'_FontCallbacks *font, %'ModuleName'_PixelColor txtBgColor);
%define! Parwindow
%define! ParcheckBox
%define! Parx
%define! Pary
%define! ParboxBgColor
%define! Partext
%define! Parfont
%define! PartxtBgColor
%define! Parwidth
%define! Parheight
%define! ParboxLineColor
%define! RetVal
%include Common\UserInterfaceCreateCheckBox.Inc

%endif %- CreateCheckBox
%-BW_METHOD_END CreateCheckBox
%-************************************************************************************************************
%-BW_METHOD_BEGIN CreateButton
%ifdef CreateButton
byte %'ModuleName'%.%CreateButton(%'ModuleName'_Window *window, %'ModuleName'_Button *button, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim width, %'ModuleName'_PixelDim height, byte *text, %'ModuleName'_FontCallbacks *font, %'ModuleName'_PixelColor btnColor);
%define! Parwindow
%define! Parbutton
%define! Parx
%define! Pary
%define! Parwidth
%define! Parheight
%define! Partext
%define! Parfont
%define! ParbtnColor
%define! RetVal
%include Common\UserInterfaceCreateButton.Inc

%endif %- CreateButton
%-BW_METHOD_END CreateButton
%-************************************************************************************************************
%-BW_METHOD_BEGIN CheckBoxIsChecked
%ifdef CheckBoxIsChecked
#define %'ModuleName'%.%CheckBoxIsChecked(checkBox) \
  (checkBox)->isChecked

%define! ParcheckBox
%define! RetVal
%include Common\UserInterfaceCheckBoxIsChecked.Inc

%endif %- CheckBoxIsChecked
%-BW_METHOD_END CheckBoxIsChecked
%-************************************************************************************************************
%-BW_METHOD_BEGIN CheckBoxSet
%ifdef CheckBoxSet
void %'ModuleName'%.%CheckBoxSet(%'ModuleName'_CheckBox *checkBox, bool checked);
%define! ParcheckBox
%define! Parchecked
%include Common\UserInterfaceCheckBoxSet.Inc

%endif %- CheckBoxSet
%-BW_METHOD_END CheckBoxSet
%-************************************************************************************************************
%-BW_METHOD_BEGIN ChangeText
%ifdef ChangeText
byte %'ModuleName'%.%ChangeText(%'ModuleName'_Window *window, %'ModuleName'_Element *elem, size_t dstTextSize, byte *txt);
%define! Partxt
%define! Parwindow
%define! Parelem
%define! PardstTextSize
%define! RetVal
%include Common\UserInterfaceChangeText.Inc

%endif %- ChangeText
%-BW_METHOD_END ChangeText
%-************************************************************************************************************
%-BW_METHOD_BEGIN PressButton
%ifdef PressButton
void %'ModuleName'%.%PressButton(%'ModuleName'_Window *window, %'ModuleName'_Button *button);
%define! Parbutton
%define! Parwindow
%include Common\UserInterfacePressButton.Inc

%endif %- PressButton
%-BW_METHOD_END PressButton
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReleaseButton
%ifdef ReleaseButton
void %'ModuleName'%.%ReleaseButton(%'ModuleName'_Window *window, %'ModuleName'_Button *button);
%define! Parbutton
%define! Parwindow
%include Common\UserInterfaceReleaseButton.Inc

%endif %- ReleaseButton
%-BW_METHOD_END ReleaseButton
%-************************************************************************************************************
%-BW_METHOD_BEGIN UpdateElement
%ifdef UpdateElement
void %'ModuleName'%.%UpdateElement(%'ModuleName'_Window *window, %'ModuleName'_Element *element);
%define! Parelement
%define! Parwindow
%include Common\UserInterfaceUpdateElement.Inc

%endif %- UpdateElement
%-BW_METHOD_END UpdateElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN ChangeBarGraphData
%ifdef ChangeBarGraphData
byte %'ModuleName'%.%ChangeBarGraphData(%'ModuleName'_Window *window, %'ModuleName'_BarGraph *barGraph, byte index, byte newData);
%define! ParbarGraph
%define! Parwindow
%define! Parindex
%define! ParnewData
%define! RetVal
%include Common\UserInterfaceChangeBarGraphData.Inc

%endif %- ChangeBarGraphData
%-BW_METHOD_END ChangeBarGraphData
%-************************************************************************************************************
%-BW_METHOD_BEGIN CreateBarGraph
%ifdef CreateBarGraph
byte %'ModuleName'%.%CreateBarGraph(%'ModuleName'_Window *window, %'ModuleName'_BarGraph *barGraph, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim width, %'ModuleName'_PixelDim height, %'ModuleName'_PixelColor bgColor, byte *data, byte nofData, %'ModuleName'_PixelColor barColor, byte borderWidth, %'ModuleName'_PixelColor borderColor, byte borderSpace);
%define! Parwindow
%define! Parx
%define! Pary
%define! Parwidth
%define! Parheight
%define! Pardata
%define! ParnofData
%define! ParbarColor
%define! ParborderWidth
%define! ParborderColor
%define! ParborderSpace
%define! ParbarGraph
%define! ParbgColor
%define! RetVal
%include Common\UserInterfaceCreateBarGraph.Inc

%endif %- CreateBarGraph
%-BW_METHOD_END CreateBarGraph
%-************************************************************************************************************
%-BW_METHOD_BEGIN SelectElement
%ifdef SelectElement
void %'ModuleName'%.%SelectElement(%'ModuleName'_Screen *screen, %'ModuleName'_Window *window, %'ModuleName'_Element *element);
%define! Parwindow
%define! Parelement
%define! Parscreen
%include Common\UserInterfaceSelectElement.Inc

%endif %- SelectElement
%-BW_METHOD_END SelectElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN ClickSelectedElement
%ifdef ClickSelectedElement
void %'ModuleName'%.%ClickSelectedElement(%'ModuleName'_Screen *screen, %'ModuleName'_EventCallbackKind kind, %'ModuleName'_Pvoid data);
%define! Parscreen
%define! Parkind
%define! Pardata
%include Common\UserInterfaceClickSelectedElement.Inc

%endif %- ClickSelectedElement
%-BW_METHOD_END ClickSelectedElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN SelectNextElement
%ifdef SelectNextElement
void %'ModuleName'%.%SelectNextElement(%'ModuleName'_Screen *screen, bool forward);
%define! Parforward
%define! Parscreen
%include Common\UserInterfaceSelectNextElement.Inc

%endif %- SelectNextElement
%-BW_METHOD_END SelectNextElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN CreateScrollMenu
%ifdef CreateScrollMenu
byte %'ModuleName'%.%CreateScrollMenu(%'ModuleName'_Window *window, %'ModuleName'_ScrollMenu *scrollMenu, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim width, %'ModuleName'_PixelDim height, byte *text, %'ModuleName'_FontCallbacks *font, %'ModuleName'_PixelColor bgColor, %'ModuleName'_PixelColor lineColor, %'ModuleName'_PixelColor boxBgColor);
%define! Parwindow
%define! ParscrollMenu
%define! Parx
%define! Pary
%define! Parwidth
%define! Parheight
%define! Partext
%define! Parfont
%define! ParlineColor
%define! ParbgColor
%define! ParboxBgColor
%define! RetVal
%include Common\UserInterfaceCreateScrollMenu.Inc

%endif %- CreateScrollMenu
%-BW_METHOD_END CreateScrollMenu
%-************************************************************************************************************
%-BW_METHOD_BEGIN AssignText
%ifdef AssignText
byte %'ModuleName'%.%AssignText(%'ModuleName'_Window *window, %'ModuleName'_Element *elem, byte *txt);
%define! Parwindow
%define! Parelem
%define! Partxt
%define! RetVal
%include Common\UserInterfaceAssignText.Inc

%endif %- AssignText
%-BW_METHOD_END AssignText
%-************************************************************************************************************
%-BW_METHOD_BEGIN ChangeTextFgColor
%ifdef FixedTextForegroundColor
#define %'ModuleName'%.%ChangeTextFgColor(elem, fgColor) /* do nothing, as using fixed text forground color */
%else
%ifdef ChangeTextFgColor
void %'ModuleName'%.%ChangeTextFgColor(%'ModuleName'_Element *elem, %'ModuleName'_PixelColor fgColor);
%define! ParfgColor
%define! Parelem
%include Common\UserInterfaceChangeTextFgColor.Inc

%endif %- ChangeTextFgColor
%endif /* FixedTextForegroundColor */
%-BW_METHOD_END ChangeTextFgColor
%-************************************************************************************************************
%-BW_METHOD_BEGIN EnableElementSelection
%ifdef EnableElementSelection
#define %'ModuleName'%.%EnableElementSelection(elem) \
%if SelectionEnabled='yes'
  ((%'ModuleName'_Element*)elem)->prop.flags |= %'ModuleName'_FLAGS_CAN_SELECT%>40/* indicate that we can select the element */
%else
  /* do nothing, as selection is disabled in the settings */
%endif

%define! Parelem
%include Common\UserInterfaceEnableElementSelection.Inc

%endif %- EnableElementSelection
%-BW_METHOD_END EnableElementSelection
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetElementWidth
%ifdef GetElementWidth
#define %'ModuleName'%.%GetElementWidth(elem) \
  ((%'ModuleName'_Element*)elem)->prop.width

%define! Parelem
%define! RetVal
%include Common\UserInterfaceGetElementWidth.Inc

%endif %- GetElementWidth
%-BW_METHOD_END GetElementWidth
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetElementHeight
%ifdef GetElementHeight
#define %'ModuleName'%.%GetElementHeight(elem) \
  ((%'ModuleName'_Element*)elem)->prop.height

%define! Parelem
%define! RetVal
%include Common\UserInterfaceGetElementHeight.Inc

%endif %- GetElementHeight
%-BW_METHOD_END GetElementHeight
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetElementPosX
%ifdef GetElementPosX
#define %'ModuleName'%.%GetElementPosX(elem)\
  ((%'ModuleName'_Element*)elem)->prop.x

%define! Parelem
%define! RetVal
%include Common\UserInterfaceGetElementPosX.Inc

%endif %- GetElementPosX
%-BW_METHOD_END GetElementPosX
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetElementPosY
%ifdef GetElementPosY
#define %'ModuleName'%.%GetElementPosY(elem)\
  ((%'ModuleName'_Element*)elem)->prop.y

%define! Parelem
%define! RetVal
%include Common\UserInterfaceGetElementPosY.Inc

%endif %- GetElementPosY
%-BW_METHOD_END GetElementPosY
%-************************************************************************************************************
%-BW_METHOD_BEGIN ClickElement
%ifdef ClickElement
void %'ModuleName'%.%ClickElement(%'ModuleName'_Screen *screen, %'ModuleName'_Window *window, %'ModuleName'_Element *element, %'ModuleName'_EventCallbackKind kind, %'ModuleName'_Pvoid data);
%define! Parscreen
%define! Parwindow
%define! Parelement
%define! Parkind
%define! Pardata
%include Common\UserInterfaceClickElement.Inc

%endif %- ClickElement
%-BW_METHOD_END ClickElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScrollMenuGetSelection
%ifdef ScrollMenuGetSelection
#define %'ModuleName'%.%ScrollMenuGetSelection(scrollMenu) \
  (scrollMenu)->selectedItem

%define! ParscrollMenu
%define! RetVal
%include Common\UserInterfaceScrollMenuGetSelection.Inc

%endif %- ScrollMenuGetSelection
%-BW_METHOD_END ScrollMenuGetSelection
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScrollMenuSetSelection
%ifdef ScrollMenuSetSelection
void %'ModuleName'%.%ScrollMenuSetSelection(%'ModuleName'_ScrollMenu *scrollMenu, byte newSelection);
%define! ParscrollMenu
%define! ParnewSelection
%include Common\UserInterfaceScrollMenuSetSelection.Inc

%endif %- ScrollMenuSetSelection
%-BW_METHOD_END ScrollMenuSetSelection
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScrollMenuNofItems
%ifdef ScrollMenuNofItems
byte %'ModuleName'%.%ScrollMenuNofItems(%'ModuleName'_ScrollMenu *scrollMenu);
%define! ParscrollMenu
%define! RetVal
%include Common\UserInterfaceScrollMenuNofItems.Inc

%endif %- ScrollMenuNofItems
%-BW_METHOD_END ScrollMenuNofItems
%-************************************************************************************************************
%-BW_METHOD_BEGIN CreateIcon
%ifdef CreateIcon
byte %'ModuleName'%.%CreateIcon(%'ModuleName'_Window *window, %'ModuleName'_Icon *icon, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim width, %'ModuleName'_PixelDim height, %'ModuleName'_IconType type);
%define! Parwindow
%define! Paricon
%define! Parx
%define! Pary
%define! Parwidth
%define! Parheight
%define! Partype
%define! RetVal
%include Common\UserInterfaceCreateIcon.Inc

%endif %- CreateIcon
%-BW_METHOD_END CreateIcon
%-************************************************************************************************************
%-BW_METHOD_BEGIN CreateScreen
%ifdef CreateScreen
void %'ModuleName'%.%CreateScreen(%'ModuleName'_Screen *screen, %'ModuleName'_PixelColor bgColor);
%define! Parscreen
%define! ParbgColor
%include Common\UserInterfaceCreateScreen.Inc

%endif %- CreateScreen
%-BW_METHOD_END CreateScreen
%-************************************************************************************************************
%-BW_METHOD_BEGIN UpdateScreen
%ifdef UpdateScreen
void %'ModuleName'%.%UpdateScreen(%'ModuleName'_Screen *screen);
%define! Parscreen
%include Common\UserInterfaceUpdateScreen.Inc

%endif %- UpdateScreen
%-BW_METHOD_END UpdateScreen
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetWindowEventCallback
%ifdef SetWindowEventCallback
#define %'ModuleName'%.%SetWindowEventCallback(window, callback) \
%if SelectionEnabled='yes'
  (window)->eventCallback = callback
%else
  /* do nothing, as events not enabled in properties */
%endif

%define! Parwindow
%define! Parcallback
%include Common\UserInterfaceSetWindowEventCallback.Inc

%endif %- SetWindowEventCallback
%-BW_METHOD_END SetWindowEventCallback
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawHLine
%ifdef DrawHLine
#define %'ModuleName'%.%DrawHLine(window, xPos, yPos, w, color) \
  %@Display@'ModuleName'%.DrawHLine((%'ModuleName'_PixelDim)((window)->prop.x+xPos), (%'ModuleName'_PixelDim)((window)->prop.y+yPos), w, color)

%define! Parwindow
%define! Parx
%define! Pary
%define! Parw
%define! Parcolor
%include Common\UserInterfaceDrawHLine.Inc

%endif %- DrawHLine
%-BW_METHOD_END DrawHLine
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawVLine
%ifdef DrawVLine
#define %'ModuleName'%.%DrawVLine(window, xPos, yPos, h, color) \
  %@Display@'ModuleName'%.DrawVLine((%'ModuleName'_PixelDim)((window)->prop.x+xPos), (%'ModuleName'_PixelDim)((window)->prop.y+yPos), h, color)

%define! Parwindow
%define! Parx
%define! Pary
%define! Parh
%define! Parcolor
%include Common\UserInterfaceDrawVLine.Inc

%endif %- DrawVLine
%-BW_METHOD_END DrawVLine
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawFilledBox
%ifdef DrawFilledBox
void %'ModuleName'%.%DrawFilledBox(%'ModuleName'_Window *window, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim w, %'ModuleName'_PixelDim h, %'ModuleName'_PixelColor color);

%define! Parwindow
%define! Parx
%define! Pary
%define! Parw
%define! Parh
%define! Parcolor
%include Common\UserInterfaceDrawFilledBox.Inc

%endif %- DrawFilledBox
%-BW_METHOD_END DrawFilledBox
%-************************************************************************************************************
%-BW_METHOD_BEGIN CreateDialogWindow
%ifdef CreateDialogWindow
byte %'ModuleName'%.%CreateDialogWindow(%'ModuleName'_Screen *screen, %'ModuleName'_Window *window, %'ModuleName'_PixelColor bgColor, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim width, %'ModuleName'_PixelDim height);
%define! Parscreen
%define! Parwindow
%define! ParbgColor
%define! Parx
%define! Pary
%define! Parwidth
%define! Parheight
%define! RetVal
%include Common\UserInterfaceCreateDialogWindow.Inc

%endif %- CreateDialogWindow
%-BW_METHOD_END CreateDialogWindow
%-************************************************************************************************************
%-BW_METHOD_BEGIN CloseDialogWindow
%ifdef CloseDialogWindow
byte %'ModuleName'%.%CloseDialogWindow(%'ModuleName'_Screen *screen, %'ModuleName'_Window *window);
%define! Parscreen
%define! Parwindow
%define! RetVal
%include Common\UserInterfaceCloseDialogWindow.Inc

%endif %- CloseDialogWindow
%-BW_METHOD_END CloseDialogWindow
%-************************************************************************************************************
%-BW_METHOD_BEGIN RemoveWindow
%ifdef RemoveWindow
byte %'ModuleName'%.%RemoveWindow(%'ModuleName'_Screen *screen, %'ModuleName'_Window *window);
%define! Parscreen
%define! Parwindow
%define! RetVal
%include Common\UserInterfaceRemoveWindow.Inc

%endif %- RemoveWindow
%-BW_METHOD_END RemoveWindow
%-************************************************************************************************************
%-BW_METHOD_BEGIN WindowSetBorder
%ifdef WindowSetBorder
#define %'ModuleName'%.%WindowSetBorder(window) \
  (window)->flags |= %'ModuleName'_FLAGS_WINDOW_HAS_BORDER

%define! Parwindow
%include Common\UserInterfaceWindowSetBorder.Inc

%endif %- WindowSetBorder
%-BW_METHOD_END WindowSetBorder
%-************************************************************************************************************
%-BW_METHOD_BEGIN HeaderSetLine
%ifdef HeaderSetLine
#define %'ModuleName'%.%HeaderSetLine(header) \
  (header)->element.prop.flags |= %'ModuleName'_FLAGS_HEADER_HAS_LINE; \
  (header)->element.prop.height++;

%define! Parheader
%define! RetVal
%include Common\UserInterfaceHeaderSetLine.Inc

%endif %- HeaderSetLine
%-BW_METHOD_END HeaderSetLine
%-************************************************************************************************************
%-BW_METHOD_BEGIN RefreshDialogWindow
%ifdef RefreshDialogWindow
void %'ModuleName'%.%RefreshDialogWindow(%'ModuleName'_Window *window);
%define! Parwindow
%include Common\UserInterfaceRefreshDialogWindow.Inc

%endif %- RefreshDialogWindow
%-BW_METHOD_END RefreshDialogWindow
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawBox
%ifdef DrawBox
void %'ModuleName'%.%DrawBox(%'ModuleName'_Window *window, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim w, %'ModuleName'_PixelDim h, %'ModuleName'_PixelDim lineWidth, %'ModuleName'_PixelColor color);
%define! Parwindow
%define! Parx
%define! Pary
%define! Parw
%define! Parh
%define! ParlineWidth
%define! Parcolor
%include Common\UserInterfaceDrawBox.Inc

%endif %- DrawBox
%-BW_METHOD_END DrawBox
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawLine
%ifdef DrawLine
void %'ModuleName'%.%DrawLine(%'ModuleName'_Window *window, %'ModuleName'_PixelDim x0, %'ModuleName'_PixelDim y0, %'ModuleName'_PixelDim x1, %'ModuleName'_PixelDim y1, %'ModuleName'_PixelColor color);
%define! Parwindow
%define! Parx0
%define! Pary0
%define! Parx1
%define! Pary1
%define! Parcolor
%include Common\UserInterfaceDrawLine.Inc

%endif %- DrawLine
%-BW_METHOD_END DrawLine
%-************************************************************************************************************
%-************************************************************************************************************
%-BW_METHOD_BEGIN DeselectElement
%ifdef DeselectElement
void %'ModuleName'%.%DeselectElement(%'ModuleName'_Screen *screen, %'ModuleName'_Window *window, %'ModuleName'_Element *element);
%define! Parscreen
%define! Parwindow
%define! Parelement
%include Common\UserInterfaceDeselectElement.Inc

%endif %- DeselectElement
%-BW_METHOD_END DeselectElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN ChangeElementColor
%ifdef ChangeElementColor
#define %'ModuleName'%.%ChangeElementColor(elem, newColor) \
  (elem)->element.prop.color = newColor
%define! Parelem
%define! Parcolor
%include Common\UserInterfaceChangeElementColor.Inc

%endif %- ChangeElementColor
%-BW_METHOD_END ChangeElementColor
%-************************************************************************************************************
%-BW_METHOD_BEGIN ChangeIconFgColor
%ifdef ChangeIconFgColor
#define %'ModuleName'%.%ChangeIconFgColor(icon, newFgColor) \
  (icon)->fgColor = newFgColor
%define! ParfgColor
%define! Paricon
%include Common\UserInterfaceChangeIconFgColor.Inc

%endif %- ChangeIconFgColor
%-BW_METHOD_END ChangeIconFgColor
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG WindowAddElement
byte %'ModuleName'%.WindowAddElement(%'ModuleName'_Window *window, %'ModuleName'_Element *element);
%define! Parwindow
%define! Parelement
%define! RetVal
%include Common\GeneralInternal.inc (WindowAddElement)

%-INTERNAL_METHOD_END WindowAddElement
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG ElementInitCommon
void %'ModuleName'%.ElementInitCommon(%'ModuleName'_Element *element, %'ModuleName'_ElementType type, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim width, %'ModuleName'_PixelDim height, %'ModuleName'_PixelColor bgColor, %'ModuleName'_painterCallback painter);
%define! Parelement
%define! Partype
%define! Parx
%define! Pary
%define! Parwidth
%define! Parheight
%define! ParbgColor
%define! Parpainter
%include Common\GeneralInternal.inc (ElementInitCommon)

%-INTERNAL_METHOD_END ElementInitCommon
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG PaintText
byte %'ModuleName'%.PaintText(%'ModuleName'_Window *window, %'ModuleName'_Element *element);
%define! Parwindow
%define! Parelement
%define! RetVal
%include Common\GeneralInternal.inc (PaintText)

%-INTERNAL_METHOD_END PaintText
%-************************************************************************************************************
%-BW_METHOD_BEGIN CreateSpace
%ifdef CreateSpace
byte %'ModuleName'%.%CreateSpace(%'ModuleName'_Window *window, %'ModuleName'_Space *space, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim width, %'ModuleName'_PixelDim height);
%define! Parwindow
%define! Parspace
%define! Parx
%define! Pary
%define! Parwidth
%define! Parheight
%define! RetVal
%include Common\UserInterfaceCreateSpace.Inc

%endif %- CreateSpace
%-BW_METHOD_END CreateSpace
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetScreen
%ifdef GetScreen
%'ModuleName'_PScreen %'ModuleName'%.%GetScreen(void);
%define! RetVal
%include Common\UserInterfaceGetScreen.Inc

%endif %- GetScreen
%-BW_METHOD_END GetScreen
%-************************************************************************************************************
%-BW_METHOD_BEGIN EqualElement
%ifdef EqualElement
#define %'ModuleName'%.%EqualElement(elem1, elem2) \
  ((elem1)==&((elem2)->element))
%define! Parelem1
%define! Parelem2
%define! RetVal
%include Common\UserInterfaceEqualElement.Inc

%endif %- EqualElement
%-BW_METHOD_END EqualElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetSelectedElement
%ifdef GetSelectedElement
bool %'ModuleName'%.%GetSelectedElement(%'ModuleName'_Screen *screen, %'ModuleName'_PWindow *pWindow, %'ModuleName'_PElement *pElement);
%define! Parscreen
%define! ParpWindow
%define! ParpElement
%define! RetVal
%include Common\UserInterfaceGetSelectedElement.Inc

%endif %- GetSelectedElement
%-BW_METHOD_END GetSelectedElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN FindElement
%ifdef FindElement
bool %'ModuleName'%.%FindElement(%'ModuleName'_Screen *screen, %'ModuleName'_PWindow *pWindow, %'ModuleName'_PElement *pElement, %'ModuleName'_ElementFindFct compare, %'ModuleName'_Pvoid data);
%define! Parscreen
%define! ParpWindow
%define! ParpElement
%define! Parcompare
%define! Pardata
%define! RetVal
%include Common\UserInterfaceFindElement.Inc

%endif %- FindElement
%-BW_METHOD_END FindElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN ChangeTextBgColor
%ifdef ChangeTextBgColor
void %'ModuleName'%.%ChangeTextBgColor(%'ModuleName'_Element *elem, %'ModuleName'_PixelColor bgColor);
%define! Parelem
%define! ParbgColor
%include Common\UserInterfaceChangeTextBgColor.Inc

%endif %- ChangeTextBgColor
%-BW_METHOD_END ChangeTextBgColor
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetDisplayOrientation
%ifdef GetDisplayOrientation
%-BW_PUBLISH_MACRO
#define %'ModuleName'%.%GetDisplayOrientation %@Display@'ModuleName'%.%GetDisplayOrientation
%define! RetVal
%include Common\UserInterfaceGetDisplayOrientation.Inc

%endif %- GetDisplayOrientation
%-BW_METHOD_END GetDisplayOrientation
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetWidth
%ifdef GetWidth
%-BW_PUBLISH_MACRO
#define %'ModuleName'%.%GetWidth %@Display@'ModuleName'%.%GetWidth
%define! RetVal
%include Common\UserInterfaceGetWidth.Inc

%endif %- GetWidth
%-BW_METHOD_END GetWidth
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetHeight
%ifdef GetHeight
%-BW_PUBLISH_MACRO
#define %'ModuleName'%.%GetHeight %@Display@'ModuleName'%.%GetHeight
%define! RetVal
%include Common\UserInterfaceGetHeight.Inc

%endif %- GetHeight
%-BW_METHOD_END GetHeight
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetDisplayOrientation
%ifdef SetDisplayOrientation
void %'ModuleName'%.%SetDisplayOrientation(%'ModuleName'_DisplayOrientation newOrientation);
%define! ParnewOrientation
%include Common\UserInterfaceSetDisplayOrientation.Inc

%endif %- SetDisplayOrientation
%-BW_METHOD_END SetDisplayOrientation
%-************************************************************************************************************
%-BW_METHOD_BEGIN OnWindowResize
%ifdef OnWindowResize
void %'ModuleName'%.%OnWindowResize(%'ModuleName'_Window *window);
%define! Parwindow
%include Common\UserInterfaceOnWindowResize.Inc

%endif %- OnWindowResize
%-BW_METHOD_END OnWindowResize
%-************************************************************************************************************
%-BW_METHOD_BEGIN RemoveWindowPaintBackground
%ifdef RemoveWindowPaintBackground
void %'ModuleName'%.%RemoveWindowPaintBackground(%'ModuleName'_Screen *screen, %'ModuleName'_Window *window);
%define! Parscreen
%define! Parwindow
%include Common\UserInterfaceRemoveWindowPaintBackground.Inc

%endif %- RemoveWindowPaintBackground
%-BW_METHOD_END RemoveWindowPaintBackground
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_METHOD_BEGIN OnEvent
%ifdef OnEvent
%INTERFACE OnEvent
void %OnEvent(%'ModuleName'_Screen *screen, %'ModuleName'_Window *window, %'ModuleName'_Element *element, %'ModuleName'_EventCallbackKind event);
%define! Parscreen
%define! Parwindow
%define! Parelement
%define! Parevent
%include Common\UserInterfaceOnEvent.Inc

%endif %- OnEvent
%-BW_METHOD_END OnEvent
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\UserInterfaceSettings.Inc
%define! Abstract Common\UserInterfaceAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
#include <string.h> /* for memcpy */
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
#ifndef NULL
  #define NULL ((void*)0)
#endif

/* constants for Button properties */
#define %'ModuleName'%.BUTTON_LINE_WIDTH          %ButtonLineWidth%>40/* width of lines around button */
#define %'ModuleName'%.BUTTON_TEXT_BORDER_WIDTH   %ButtonTextBorderWidth%>40/* width of space around button text (between border and text) */
#define %'ModuleName'%.BUTTON_PRESS_Y_DELTA       %'ModuleName'%.BUTTON_LINE_WIDTH%>40/* the button text will be moved by this delta in pressed state */

/* constants for ScrollMenu properties */
#define %'ModuleName'%.SCROLLMENU_LINE_WIDTH          %ScrollMenuLineWidth%>40/* width of line used for scroll menu */
#define %'ModuleName'%.SCROLLMENU_TEXT_BORDER_WIDTH   %ScrollMenuTextBorderWidth%>40/* width of space around scroll menu text (between lines and text) */

/* constants for Checkbox properties */
#define %'ModuleName'%.CHECKBOX_LINE_WIDTH  %CheckBoxLineWidth   %>40/* line thickness of check box */
#define %'ModuleName'%.CHECKBOX_TEXT_SPACE  %CheckBoxTextSpaceWidth%>40/* space between checkbox and text */

static %'ModuleName'%.Screen *currentScreen;                     %>40/* current screen */
%-
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-UNLOCKED
/* Internal method prototypes */
%-INTERNAL_LOC_METHOD_BEG PaintHeader
static byte PaintHeader(%'ModuleName'_Window *window, %'ModuleName'_Element *element);
%-INTERNAL_LOC_METHOD_END PaintHeader
%-INTERNAL_LOC_METHOD_BEG PaintButton
static byte PaintButton(%'ModuleName'_Window *window, %'ModuleName'_Element *element);
%-INTERNAL_LOC_METHOD_END PaintButton
%-INTERNAL_LOC_METHOD_BEG PaintCheckBox
static byte PaintCheckBox(%'ModuleName'_Window *window, %'ModuleName'_Element *element);
%-INTERNAL_LOC_METHOD_END PaintCheckBox
%-INTERNAL_LOC_METHOD_BEG PaintBarGraph
static byte PaintBarGraph(%'ModuleName'_Window *window, %'ModuleName'_Element *element);
%-INTERNAL_LOC_METHOD_END PaintBarGraph
%-INTERNAL_LOC_METHOD_BEG PaintScrollMenu
static byte PaintScrollMenu(%'ModuleName'_Window *window, %'ModuleName'_Element *element);
%-INTERNAL_LOC_METHOD_END PaintScrollMenu
%-INTERNAL_LOC_METHOD_BEG NextElement
static void NextElement(%'ModuleName'_Screen *screen, %'ModuleName'_PWindow *ppWindow, %'ModuleName'_PElement *ppElement);
%-INTERNAL_LOC_METHOD_END NextElement
%-INTERNAL_LOC_METHOD_BEG PrevElement
static void PrevElement(%'ModuleName'_Screen *screen, %'ModuleName'_PWindow *ppWindow, %'ModuleName'_PElement *ppElement);
%-INTERNAL_LOC_METHOD_END PrevElement
%-INTERNAL_LOC_METHOD_BEG PaintIcon
static byte PaintIcon(%'ModuleName'_Window *window, %'ModuleName'_Element *element);
%-INTERNAL_LOC_METHOD_END PaintIcon
%-INTERNAL_LOC_METHOD_BEG UpdateElementNoRefresh
static void UpdateElementNoRefresh(%'ModuleName'_Window *window, %'ModuleName'_Element *element, byte updateAll);
%-INTERNAL_LOC_METHOD_END UpdateElementNoRefresh
%-

%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN CreateWindow
%ifdef CreateWindow
%define! Parwindow
%define! ParbgColor
%define! Parx
%define! Pary
%define! Parwidth
%define! Parheight
%define! Parscreen
%define! RetVal
%include Common\UserInterfaceCreateWindow.Inc
byte %'ModuleName'%.%CreateWindow(%'ModuleName'_Screen *screen, %'ModuleName'_Window *window, %'ModuleName'_PixelColor bgColor, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim width, %'ModuleName'_PixelDim height)
{
  if (window == NULL || screen == NULL) {
    return ERR_FAILED;
  }
  %'ModuleName'%.ElementInitCommon((%'ModuleName'%.Element*)window, %'ModuleName'%.WINDOW,
    x, y, width, height, bgColor, NULL);
  window->next = NULL;
  window->first = NULL;
%if SelectionEnabled='yes'
  window->selectedE = NULL;
  window->eventCallback = NULL;
%endif
  window->parentE = NULL;
  window->updateAll = TRUE;
  window->flags = %'ModuleName'_FLAGS_WINDOW_INIT;
  /* add to screen: we add new windows to the end of the list */
  if (screen->first == NULL) {                                   %>40/* first in list */
    screen->first = window;
  } else {                                                       %>40/* append to the end of the list */
    %'ModuleName'_Window *w;

    w = screen->first;
    while(w->next != NULL) {                                     %>40/* iterate through the list */
      w = w->next;
    }
    w->next = window;
  }
  return ERR_OK;
}

%endif %- CreateWindow
%-BW_METHOD_END CreateWindow
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG WindowAddElement
%define! Parwindow
%define! Parelement
%define! RetVal
%include Common\GeneralInternal.inc (WindowAddElement)
byte %'ModuleName'%.WindowAddElement(%'ModuleName'_Window *window, %'ModuleName'_Element *element)
{
  if (window == NULL) {
    return ERR_FAILED;
  }
  /* we add elements to the end of the list */
  if (window->first == NULL) {                                   %>40/* first in list */
    window->first = element;
  } else {                                                       %>40/* append to the end of the list */
    %'ModuleName'_Element *e;
    e = window->first;
    while(e->next != NULL) {                                     %>40/* iterate through the list */
      e = e->next;
    }
    e->next = element;
  }
  return ERR_OK;
}

%-INTERNAL_METHOD_END WindowAddElement
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG ElementInitCommon
%define! Parelement
%define! Partype
%define! Parx
%define! Pary
%define! Parwidth
%define! Parheight
%define! ParbgColor
%define! Parpainter
%include Common\GeneralInternal.inc (ElementInitCommon)
void %'ModuleName'%.ElementInitCommon(%'ModuleName'_Element *element, %'ModuleName'_ElementType type, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim width, %'ModuleName'_PixelDim height, %'ModuleName'_PixelColor bgColor, %'ModuleName'_painterCallback painter)
{
  element->prop.type = type;
  element->prop.x = x;
  element->prop.y = y;
  element->prop.width = width;
  element->prop.height = height;
  element->prop.color = bgColor;
  element->prop.flags = %'ModuleName'_FLAGS_INIT;                %>40/* initialize flags */
  element->painter = painter;
  element->next = NULL;
}

%-INTERNAL_METHOD_END ElementInitCommon
%-************************************************************************************************************
%-BW_METHOD_BEGIN ChangeTextFgColor
%ifdef ChangeTextFgColor
%define! ParfgColor
%define! Parelem
%include Common\UserInterfaceChangeTextFgColor.Inc
%ifndef FixedTextForegroundColor
void %'ModuleName'%.%ChangeTextFgColor(%'ModuleName'_Element *elem, %'ModuleName'_PixelColor fgColor)
{
  %'ModuleName'_TextInfo *textInfo;

  if (   elem == NULL ||
      !(   elem->prop.type == %'ModuleName'%.TEXT
        || elem->prop.type == %'ModuleName'%.CHECKBOX
        || elem->prop.type == %'ModuleName'%.HEADER
        || elem->prop.type == %'ModuleName'%.BUTTON
        || elem->prop.type == %'ModuleName'%.SCROLLMENU
       )
     )
  {
    return; /* error! */
  }
  textInfo = (%'ModuleName'_TextInfo *)(((byte*)elem)+sizeof(%'ModuleName'_Element));%>40/* the textInfo is just after the element */
  textInfo->txtColor = fgColor;
}
%endif

%endif %- ChangeTextFgColor
%-BW_METHOD_END ChangeTextFgColor
%-************************************************************************************************************
%-BW_METHOD_BEGIN ChangeTextBgColor
%ifdef ChangeTextBgColor
%define! Parelem
%define! ParbgColor
%include Common\UserInterfaceChangeTextBgColor.Inc
void %'ModuleName'%.%ChangeTextBgColor(%'ModuleName'_Element *elem, %'ModuleName'_PixelColor bgColor)
{
  if (   elem == NULL ||
      !(   elem->prop.type == %'ModuleName'%.TEXT
        || elem->prop.type == %'ModuleName'%.CHECKBOX
        || elem->prop.type == %'ModuleName'%.HEADER
        || elem->prop.type == %'ModuleName'%.BUTTON
        || elem->prop.type == %'ModuleName'%.SCROLLMENU
       )
     )
  {
    return; /* error! */
  }
  elem->prop.color = bgColor;
}

%endif %- ChangeTextBgColor
%-BW_METHOD_END ChangeTextBgColor
%-************************************************************************************************************
%-BW_METHOD_BEGIN AssignText
%ifdef AssignText
%define! Parwindow
%define! Parelem
%define! Partxt
%define! RetVal
%include Common\UserInterfaceAssignText.Inc
byte %'ModuleName'%.%AssignText(%'ModuleName'_Window *window, %'ModuleName'_Element *elem, byte *txt)
{
  %'ModuleName'_TextInfo *textInfo;

  if (   elem == NULL ||
      !(   elem->prop.type == %'ModuleName'%.TEXT
        || elem->prop.type == %'ModuleName'%.CHECKBOX
        || elem->prop.type == %'ModuleName'%.HEADER
        || elem->prop.type == %'ModuleName'%.BUTTON
        || elem->prop.type == %'ModuleName'%.SCROLLMENU
       )
     )
  {
    return ERR_FAILED; /* error! */
  }
  textInfo = (%'ModuleName'_TextInfo *)(((byte*)elem)+sizeof(%'ModuleName'_Element));%>40/* the textInfo is just after the element */
  textInfo->text = txt;
  return %'ModuleName'%.PaintText(window, (%'ModuleName'_Element*)elem);
}

%endif %- AssignText
%-BW_METHOD_END AssignText
%-************************************************************************************************************
%-BW_METHOD_BEGIN ChangeText
%ifdef ChangeText
%define! Partxt
%define! Parwindow
%define! Parelem
%define! PardstTextSize
%define! RetVal
%include Common\UserInterfaceChangeText.Inc
byte %'ModuleName'%.%ChangeText(%'ModuleName'_Window *window, %'ModuleName'_Element *elem, size_t dstTextSize, byte *txt)
{
  %'ModuleName'_PixelDim x, y, leftPos, xCursor, yCursor;
  %'ModuleName'_TextInfo *textInfo;
  unsigned char *p, *q;
  %'ModuleName'_PixelDim width, totalWidth;
  %'ModuleName'_PixelDim height, totalHeight;
  %'ModuleName'_PixelColor drawColor, clrColor;
  %@FontDisplay@'ModuleName'%.Font *font;

  if (   elem == NULL ||
      !(   elem->prop.type == %'ModuleName'%.TEXT
        || elem->prop.type == %'ModuleName'%.CHECKBOX
        || elem->prop.type == %'ModuleName'%.HEADER
        || elem->prop.type == %'ModuleName'%.BUTTON
        || elem->prop.type == %'ModuleName'%.SCROLLMENU
       )
     )
  {
    return ERR_FAILED; /* error! */
  }
  textInfo = (%'ModuleName'_TextInfo *)(((byte*)elem)+sizeof(%'ModuleName'_Element));%>40/* the textInfo is just after the element */
%ifdef FixedFont
  font = %@FixedFont@'ModuleName'%.GetFont();
%else
  font = textInfo->font;
%endif
  x = (%'ModuleName'_PixelDim)(window->prop.x + elem->prop.x + textInfo->deltaX);
  leftPos = x; /* position on the left side of the text box */
  y = (%'ModuleName'_PixelDim)(window->prop.y + elem->prop.y + textInfo->deltaY);
  xCursor = x; yCursor = y;
  %@FontDisplay@'ModuleName'%.GetFontHeight(font, &height, &totalHeight);
  /* determine color to clear text and color to draw text */
%if SelectionEnabled='yes'
  if (elem->prop.flags&%'ModuleName'_FLAGS_IS_SELECTED) {
    drawColor = elem->prop.color;
  %ifdef FixedTextForegroundColor
    clrColor = %@Display@'ModuleName'%.COLOR_%DefaultTextTextForegroundColor;
  %else
    clrColor = textInfo->txtColor;
  %endif
  } else {
  %ifdef FixedTextForegroundColor
    drawColor = %@Display@'ModuleName'%.COLOR_%DefaultTextTextForegroundColor;
  %else
    drawColor = textInfo->txtColor;
  %endif
    clrColor = elem->prop.color;
  }
%else
  %ifdef FixedTextForegroundColor
  drawColor = %@Display@'ModuleName'%.COLOR_%DefaultTextTextForegroundColor;
  %else
  drawColor = textInfo->txtColor;
  %endif
  clrColor = elem->prop.color;
%endif
  /* iterate through the two strings and compare them. Need to care about '\n' too. Note that we do not handle '\r' 100%% correctly :-(. */
  p = textInfo->text;
  q = txt;
  do {                                                           %>40/* skip text which is the same, will break */
    if (*p=='\n' && *q=='\n') {                                  %>40/* new line */
      x = leftPos;
      y += totalHeight;
      p++; q++;                                                  %>40/* move on */
    } else if (*p=='\0' && *q=='\0') {
      break; /* done */
    } else if (*p==*q) {                                         %>40/* same character: do not change, only update position */
      %@FontDisplay@'ModuleName'%.GetCharWidth(*p, &width, &totalWidth, font);
      x += totalWidth;
      p++; q++;                                                  %>40/* move on */
    } else if (*q=='\0') { /* new text is at its end */
      /* clear existing remaining text */
      xCursor = x; yCursor = y;
      if (*p=='\n') {
        xCursor = leftPos;
      }
      %@FontDisplay@'ModuleName'%.WriteString(p, clrColor, &xCursor, &yCursor, font);
      break; /* done */
    } else if (*p=='\0') { /* existing text is at its end */
      /* write new text */
      xCursor = x; yCursor = y;
      if (*q=='\n') {
        xCursor = leftPos;
      }
      %@FontDisplay@'ModuleName'%.WriteString(q, drawColor, &xCursor, &yCursor, font);
      break; /* done */
    } else {                                                     %>40/* mismatch, new character is different: update until new line */
      /* first re-draw text using the background color to make it disappear */
      xCursor = x; yCursor = y;
      while(*p!='\0' && *p!='\n') {
        %@FontDisplay@'ModuleName'%.WriteChar(*p, clrColor, &xCursor, &yCursor, font);
        p++;
      }
      xCursor = x; yCursor = y;
      while(*q!='\0' && *q!='\n') {
        %@FontDisplay@'ModuleName'%.WriteChar(*q, drawColor, &xCursor, &yCursor, font);
        q++;
      }
    }
  } while(1);
  /* now update element with the new text */
  %@Utility@'ModuleName'%.strcpy(textInfo->text, dstTextSize, txt);%>40 /* set new text */
  return ERR_OK;
}

%endif %- ChangeText
%-BW_METHOD_END ChangeText
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG PaintText
%define! Parwindow
%define! Parelement
%define! RetVal
%include Common\GeneralInternal.inc (PaintText)
byte %'ModuleName'%.PaintText(%'ModuleName'_Window *window, %'ModuleName'_Element *element)
{
  %'ModuleName'_TextInfo *textInfo = (%'ModuleName'_TextInfo *)(((byte*)element)+sizeof(%'ModuleName'_Element));
  %'ModuleName'_PixelDim x, y;
  %'ModuleName'_PixelColor fgColor, bgColor;

%ifdef FixedTextForegroundColor
  fgColor = %@Display@'ModuleName'%.COLOR_%DefaultTextTextForegroundColor;
%else
  fgColor = textInfo->txtColor;
%endif
  bgColor = element->prop.color;

%if SelectionEnabled='yes'
  if (element->prop.flags&%'ModuleName'_FLAGS_IS_SELECTED) {     %>40/* invert colors */
    %'ModuleName'_PixelColor tmp;

    tmp = fgColor; fgColor = bgColor; bgColor = tmp;
  }
%endif
  /* draw background */
  %'ModuleName'%.DrawFilledBox(window, element->prop.x, element->prop.y,
       element->prop.width, element->prop.height, bgColor);
  /* now write text */
  x = (%'ModuleName'_PixelDim)(window->prop.x + element->prop.x + textInfo->deltaX);
  y = (%'ModuleName'_PixelDim)(window->prop.y + element->prop.y + textInfo->deltaY);
  %@FontDisplay@'ModuleName'%.WriteString(textInfo->text,
    fgColor,
    &x, &y,
%ifndef FixedFont
    textInfo->font
%else
    %@FixedFont@'ModuleName'%.GetFont()
%endif
  );
  return ERR_OK;
}

%-INTERNAL_METHOD_END PaintText
%-************************************************************************************************************
%-BW_METHOD_BEGIN CreateText
%ifdef CreateText
%define! Parx
%define! Pary
%define! Parwidth
%define! Parheight
%define! Partext
%define! Parwindow
%define! Parfont
%define! PartextElem
%define! RetVal
%include Common\UserInterfaceCreateText.Inc
byte %'ModuleName'%.%CreateText(%'ModuleName'_Window *window, %'ModuleName'_Text *textElem, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim width, %'ModuleName'_PixelDim height, byte *text, %'ModuleName'_FontCallbacks *font)
{
  if (text == NULL || textElem == NULL || window == NULL) {
    return ERR_FAILED;
  }
%ifdef FixedFont
  font = %@FixedFont@'ModuleName'%.GetFont();
%endif
  if (width == 0) {                                              %>40/* auto size */
    width = %@FontDisplay@'ModuleName'%.GetStringWidth(text, font, NULL);
  }
  if (height == 0) {                                             %>40/* auto size */
    height = %@FontDisplay@'ModuleName'%.GetStringHeight(text, font, NULL);
  }
  %'ModuleName'%.ElementInitCommon((%'ModuleName'%.Element*)textElem, %'ModuleName'%.TEXT,
    x, y, width, height, window->prop.color, (%'ModuleName'%.painterCallback)%'ModuleName'%.PaintText);
  textElem->textInfo.deltaX = 0;
  textElem->textInfo.deltaY = 0;
  textElem->textInfo.text = text;
%ifndef FixedFont
  textElem->textInfo.font = font;
%endif
%ifndef FixedTextForegroundColor
  textElem->textInfo.txtColor = %@Display@'ModuleName'%.COLOR_%DefaultTextTextForegroundColor;
%endif
  if (%'ModuleName'%.WindowAddElement(window, (%'ModuleName'%.Element *)textElem) != ERR_OK) {
    return ERR_FAILED;
  }
  return ERR_OK;
}

%endif %- CreateText
%-BW_METHOD_END CreateText
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG PaintHeader
%define! Parwindow
%define! Parelement
%define! RetVal
%include Common\GeneralInternalGlobal.inc (PaintHeader)
static byte PaintHeader(%'ModuleName'_Window *window, %'ModuleName'_Element *element)
{
  %'ModuleName'%.Header* header = (%'ModuleName'%.Header*)element;
  byte res;

  if (header->element.prop.type != %'ModuleName'%.HEADER) {
    return ERR_FAILED;
  }
  res = %'ModuleName'%.PaintText(window, element);               %>40/* draw the text */
  if (header->element.prop.flags&%'ModuleName'_FLAGS_HEADER_HAS_LINE) {
    %'ModuleName'%.%DrawHLine(window, element->prop.x, element->prop.height, element->prop.width, %@Display@'ModuleName'%.COLOR_%HeaderLineColor);
  }
  return res;
}

%-INTERNAL_METHOD_END PaintHeader
%-************************************************************************************************************
%-BW_METHOD_BEGIN CreateHeader
%ifdef CreateHeader
%define! Parwindow
%define! Parheader
%define! Partext
%define! ParbgColor
%define! Parfont
%define! RetVal
%include Common\UserInterfaceCreateHeader.Inc
byte %'ModuleName'%.%CreateHeader(%'ModuleName'_Window *window, %'ModuleName'_Header *header, byte *text, %'ModuleName'_FontCallbacks *font, %'ModuleName'_PixelColor bgColor)
{
  %'ModuleName'%.PixelDim height, x, y, width;

  if (window == NULL || header == NULL || text == NULL || font == NULL) {
    return ERR_FAILED;
  }
%ifdef FixedFont
  font = %@FixedFont@'ModuleName'%.GetFont();
%endif
  height = (%'ModuleName'%.PixelDim)(%@FontDisplay@'ModuleName'%.GetStringHeight(text, font, NULL) + 2*%HeaderTextBorderWidth);
  if (window->flags&%'ModuleName'_FLAGS_WINDOW_HAS_BORDER) {
    x = 1;
    y = 1;
    width = (%'ModuleName'_PixelDim)(window->prop.width-2);
  } else {
    x = 0;
    y = 0;
    width = window->prop.width;
  }
  %'ModuleName'%.ElementInitCommon((%'ModuleName'%.Element*)header, %'ModuleName'%.HEADER,
    x, y, width, height,
    bgColor, (%'ModuleName'%.painterCallback)PaintHeader);
  header->textInfo.deltaX = %HeaderTextBorderWidth;
  header->textInfo.deltaY = %HeaderTextBorderWidth;
  header->textInfo.text = text;
%ifndef FixedFont
  header->textInfo.font = font;
%else
  (void)font; /* avoid warning, as we have a fixed font */
%endif
%ifndef FixedTextForegroundColor
  header->textInfo.txtColor = %@Display@'ModuleName'%.COLOR_%DefaultHeaderTextForegroundColor;
%endif
  if (%'ModuleName'%.WindowAddElement(window, (%'ModuleName'%.Element *)header) != ERR_OK) {
    return ERR_FAILED;
  }
  return ERR_OK;
}

%endif %- CreateHeader
%-BW_METHOD_END CreateHeader
%-************************************************************************************************************
%-BW_METHOD_BEGIN UpdateElement
%ifdef UpdateElement
%define! Parelement
%define! Parwindow
%include Common\UserInterfaceUpdateElement.Inc
void %'ModuleName'%.%UpdateElement(%'ModuleName'_Window *window, %'ModuleName'_Element *element)
{
  UpdateElementNoRefresh(window, element, TRUE);
  %@Display@'ModuleName'%.UpdateRegion(element->prop.x, element->prop.y, element->prop.width, element->prop.height);
}

%endif %- UpdateElement
%-BW_METHOD_END UpdateElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN UpdateWindow
%ifdef UpdateWindow
%define! Parwindow
%include Common\UserInterfaceUpdateWindow.Inc
void %'ModuleName'%.%UpdateWindow(%'ModuleName'_Window *window)
{
  bool updateAll; /* do we need a global update? */
  %'ModuleName'%.Element *element;

  if (window != NULL) {
    updateAll = window->updateAll;
    if (updateAll) {                                             %>40/* start with drawing the background */
%ifdef _OPTIMIZE_CLEARED_BACKGROUND
      if (window->flags&%'ModuleName'_FLAGS_WINDOW_HAS_BORDER) {
        %@Display@'ModuleName'%.DrawBox(window->prop.x, window->prop.y, window->prop.width, window->prop.height, 1, %@Display@'ModuleName'%.COLOR_%WindowBorderColor);
        if (!(window->flags&%'ModuleName'_FLAGS_WINDOW_BG_CLEARED)) {
          %@Display@'ModuleName'%.DrawFilledBox(
              (%'ModuleName'_PixelDim)(window->prop.x+1),
              (%'ModuleName'_PixelDim)(window->prop.y+1),
              (%'ModuleName'_PixelDim)(window->prop.width-2),
              (%'ModuleName'_PixelDim)(window->prop.height-2), window->prop.color);
          window->flags |= %'ModuleName'_FLAGS_WINDOW_BG_CLEARED;%>40/* window is in background color now */
        }
      } else if (!(window->flags&%'ModuleName'_FLAGS_WINDOW_BG_CLEARED)) {
        %@Display@'ModuleName'%.DrawFilledBox(window->prop.x, window->prop.y, window->prop.width, window->prop.height, window->prop.color);
        window->flags |= %'ModuleName'_FLAGS_WINDOW_BG_CLEARED;  %>40/* window is in background color now */
      }
    }
%else
      if (window->flags&%'ModuleName'_FLAGS_WINDOW_HAS_BORDER) {
        %@Display@'ModuleName'%.DrawBox(window->prop.x, window->prop.y, window->prop.width, window->prop.height, 1, %@Display@'ModuleName'%.COLOR_%WindowBorderColor);
        %@Display@'ModuleName'%.DrawFilledBox(
              (%'ModuleName'_PixelDim)(window->prop.x+1),
              (%'ModuleName'_PixelDim)(window->prop.y+1),
              (%'ModuleName'_PixelDim)(window->prop.width-2),
              (%'ModuleName'_PixelDim)(window->prop.height-2), window->prop.color);
      } else {
        %@Display@'ModuleName'%.DrawFilledBox(window->prop.x, window->prop.y, window->prop.width, window->prop.height, window->prop.color);
      }
    }
%endif
    if (window->parentE != NULL) {                               %>40/* we are a subwindow: paint first the parent element */
      if ((window->parentE->prop.flags&%'ModuleName'_FLAGS_NEEDS_REPAINT) || updateAll) {
        if (window->parentE->painter == NULL) { /* create user event */
          /* call user callback */
          if (window->eventCallback != NULL) {
            window->eventCallback(window, window->parentE, %'ModuleName'_EVENT_PAINT, NULL);
          }
        } else {
          (void)(*window->parentE->painter)(window, window->parentE);
        }
        window->parentE->prop.flags &= ~%'ModuleName'_FLAGS_NEEDS_REPAINT;
      }
    }
    element=window->first;
    while (element != NULL) {
      UpdateElementNoRefresh(window, element, updateAll);
      element = element->next;
    } /* if */
    window->updateAll = FALSE;
%ifdef _OPTIMIZE_CLEARED_BACKGROUND
    window->flags &= ~%'ModuleName'_FLAGS_WINDOW_BG_CLEARED;     %>40/* mark that we have changed content and it is not any more in just background color */
%endif
  }
}

%endif %- UpdateWindow
%-BW_METHOD_END UpdateWindow
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG PaintCheckBox
%define! Parwindow
%define! Parelement
%define! RetVal
%include Common\GeneralInternalGlobal.inc (PaintCheckBox)
static byte PaintCheckBox(%'ModuleName'_Window *window, %'ModuleName'_Element *element)
{
  %'ModuleName'_CheckBox *chkbox = (%'ModuleName'_CheckBox*)element;
  %'ModuleName'_PixelDim x, y, boxSize;
  byte res;

  if (chkbox == NULL) {
    return ERR_FAILED;
  }
  if (element->prop.type != %'ModuleName'_CHECKBOX) {
    return ERR_FAILED;
  }
  res = %'ModuleName'%.PaintText(window, element);
  if (res != ERR_OK) {
    return res;
  }
  x = (%'ModuleName'_PixelDim)(element->prop.x+window->prop.x);
  y = (%'ModuleName'_PixelDim)(element->prop.y+window->prop.y);
  /* determine the size of the quadratic check box: this depends on the font used for the text */
%ifndef FixedFont
  boxSize = (%'ModuleName'_PixelDim)(
      chkbox->textInfo.font->boundingBoxHeight
    - chkbox->textInfo.font->lineSpaceBoxHeight
    - chkbox->textInfo.font->underlineBoxHeight);
%else
  boxSize = (%'ModuleName'_PixelDim)(
      %@FixedFont@'ModuleName'%.GetBoxHeight()
    - %@FixedFont@'ModuleName'%.GetLineSpaceHeight()
    - %@FixedFont@'ModuleName'%.GetUnderlineBoxHeight());
%endif
  /* Draw background of check box */
  %'ModuleName'%.DrawFilledBox(window, element->prop.x, element->prop.y,
    (%'ModuleName'_PixelDim)(boxSize+%'ModuleName'%.CHECKBOX_TEXT_SPACE),
    element->prop.height,
    element->prop.color);
  /* Draw the check box bounding box (check box quadratic box) */
  %@Display@'ModuleName'%.DrawBox(x, y, boxSize, boxSize, %'ModuleName'%.CHECKBOX_LINE_WIDTH, chkbox->boxLineColor);
  /* Draw the check box background (fill the quadratic check box) */
  %@Display@'ModuleName'%.DrawFilledBox(
    (%'ModuleName'_PixelDim)(x+%'ModuleName'%.CHECKBOX_LINE_WIDTH),
    (%'ModuleName'_PixelDim)(y+%'ModuleName'%.CHECKBOX_LINE_WIDTH),
    (%'ModuleName'_PixelDim)(boxSize-2*%'ModuleName'%.CHECKBOX_LINE_WIDTH),
    (%'ModuleName'_PixelDim)(boxSize-2*%'ModuleName'%.CHECKBOX_LINE_WIDTH),
    chkbox->boxBgColor);
  if (chkbox->isChecked) { /* draw cross */
    %@Display@'ModuleName'%.DrawLine(
      x, y,
      (%'ModuleName'_PixelDim)(x+boxSize-%'ModuleName'%.CHECKBOX_LINE_WIDTH),
      (%'ModuleName'_PixelDim)(y+boxSize-%'ModuleName'%.CHECKBOX_LINE_WIDTH),
      chkbox->boxLineColor);
    %@Display@'ModuleName'%.DrawLine(
      x,
      (%'ModuleName'_PixelDim)(y+boxSize-%'ModuleName'%.CHECKBOX_LINE_WIDTH),
      (%'ModuleName'_PixelDim)(x+boxSize-%'ModuleName'%.CHECKBOX_LINE_WIDTH),
      y, chkbox->boxLineColor);
  }
  return ERR_OK;
}

%-INTERNAL_METHOD_END PaintCheckBox
%-************************************************************************************************************
%-BW_METHOD_BEGIN CreateCheckBox
%ifdef CreateCheckBox
%define! Parwindow
%define! ParcheckBox
%define! Parx
%define! Pary
%define! ParboxBgColor
%define! Partext
%define! Parfont
%define! PartxtBgColor
%define! Parwidth
%define! Parheight
%define! ParboxLineColor
%define! RetVal
%include Common\UserInterfaceCreateCheckBox.Inc
byte %'ModuleName'%.%CreateCheckBox(%'ModuleName'_Window *window, %'ModuleName'_CheckBox *checkBox, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim width, %'ModuleName'_PixelDim height, %'ModuleName'_PixelColor boxLineColor, %'ModuleName'_PixelColor boxBgColor, byte *text, %'ModuleName'_FontCallbacks *font, %'ModuleName'_PixelColor txtBgColor)
{
  %'ModuleName'_PixelDim boxSize;

  if (window == NULL || checkBox == NULL) {
    return ERR_FAILED;
  }
  /* calculate size of the check box: size of the 'upperline' font size */
%ifdef FixedFont
  font = %@FixedFont@'ModuleName'%.GetFont();
%endif
  boxSize = (%'ModuleName'_PixelDim)(font->boundingBoxHeight - font->lineSpaceBoxHeight - font->underlineBoxHeight);
  if (width == 0) {                                              %>40/* auto size */
    width = (%'ModuleName'_PixelDim)(%@FontDisplay@'ModuleName'%.GetStringWidth(text, font, NULL)
             + boxSize+%'ModuleName'%.CHECKBOX_TEXT_SPACE);      %>40/* for the checkbox, plus space  */
  }
  if (height == 0) {                                             %>40/* auto size */
    height = %@FontDisplay@'ModuleName'%.GetStringHeight(text, font, NULL);
  }
  %'ModuleName'%.ElementInitCommon((%'ModuleName'_Element*)checkBox, %'ModuleName'_CHECKBOX,
    x, y, width, height,
    txtBgColor, (%'ModuleName'%.painterCallback)PaintCheckBox);
  checkBox->textInfo.deltaX = (%'ModuleName'_PixelDim)(boxSize+%'ModuleName'%.CHECKBOX_TEXT_SPACE);
  checkBox->textInfo.deltaY = 0;
  checkBox->textInfo.text = text;
%ifndef FixedFont
  checkBox->textInfo.font = font;
%endif
%ifndef FixedTextForegroundColor
  checkBox->textInfo.txtColor = %@Display@'ModuleName'%.COLOR_%DefaultCheckBoxTextForegroundColor;
%endif
  checkBox->boxLineColor = boxLineColor;
  checkBox->boxBgColor = boxBgColor;
  checkBox->isChecked = FALSE;
  if (%'ModuleName'%.WindowAddElement(window, (%'ModuleName'%.Element *)checkBox) != ERR_OK) {
    return ERR_FAILED;
  }
  return ERR_OK;
}

%endif %- CreateCheckBox
%-BW_METHOD_END CreateCheckBox
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG PaintButton
%define! Parwindow
%define! Parelement
%define! RetVal
%include Common\GeneralInternalGlobal.inc (PaintButton)
static byte PaintButton(%'ModuleName'_Window *window, %'ModuleName'_Element *element)
{
  %'ModuleName'_Button *button = (%'ModuleName'_Button*)element;
  %'ModuleName'_PixelDim w, h;
  %'ModuleName'_PixelColor topLineColor, bottomLineColor;
  byte res;

  if (button == NULL) {
    return ERR_FAILED;
  }
  if (element->prop.type != %'ModuleName'_BUTTON) {
    return ERR_FAILED;
  }
  w = element->prop.width;
  h = element->prop.height;

  /* draw text */
  if (button->isPressed) {
    struct {
      %'ModuleName'_Element element;
      %'ModuleName'_TextInfo textInfo;
    } info;                                                      %>40 /* temporary information for pressed button text */

    (void)memcpy(&info, element, sizeof(%'ModuleName'_Element)+sizeof(%'ModuleName'_TextInfo));
    /* because of the shift below, we need to fill the remaining part */
    info.textInfo.deltaY += %'ModuleName'%.BUTTON_PRESS_Y_DELTA; /* in pressed state, text is moved a little bit */
    res = %'ModuleName'%.PaintText(window, (%'ModuleName'_Element*)&info);
  } else {
    res = %'ModuleName'%.PaintText(window, element);
  }
  if (res != ERR_OK) {
    return res;
  }
  /* draw shape */
%if ButtonTopColor != ButtonBottomColor
  if (button->isPressed) {
    topLineColor = %@Display@'ModuleName'%.COLOR_%ButtonTopColor;
    bottomLineColor = %@Display@'ModuleName'%.COLOR_%ButtonBottomColor;
  } else {
    topLineColor = %@Display@'ModuleName'%.COLOR_%ButtonBottomColor;
    bottomLineColor = %@Display@'ModuleName'%.COLOR_%ButtonTopColor;
  }
%else
  topLineColor = %@Display@'ModuleName'%.COLOR_%ButtonTopColor;
  bottomLineColor = %@Display@'ModuleName'%.COLOR_%ButtonBottomColor;
%endif
  %'ModuleName'%.DrawFilledBox(window, element->prop.x, element->prop.y, w, %'ModuleName'%.BUTTON_LINE_WIDTH, topLineColor);
  %'ModuleName'%.DrawFilledBox(window,
    element->prop.x,
    (%'ModuleName'_PixelDim)(element->prop.y+%'ModuleName'%.BUTTON_LINE_WIDTH),
    %'ModuleName'%.BUTTON_LINE_WIDTH,
    (%'ModuleName'_PixelDim)(h-%'ModuleName'%.BUTTON_LINE_WIDTH),
    topLineColor);
  %'ModuleName'%.DrawFilledBox(window,
    (%'ModuleName'_PixelDim)(element->prop.x+%'ModuleName'%.BUTTON_LINE_WIDTH),
    (%'ModuleName'_PixelDim)(element->prop.y+h-%'ModuleName'%.BUTTON_LINE_WIDTH),
    (%'ModuleName'_PixelDim)(w-%'ModuleName'%.BUTTON_LINE_WIDTH),
    %'ModuleName'%.BUTTON_LINE_WIDTH,
    bottomLineColor);
  %'ModuleName'%.DrawFilledBox(window,
    (%'ModuleName'_PixelDim)(element->prop.x+w-%'ModuleName'%.BUTTON_LINE_WIDTH),
    (%'ModuleName'_PixelDim)(element->prop.y+%'ModuleName'%.BUTTON_LINE_WIDTH),
    %'ModuleName'%.BUTTON_LINE_WIDTH,
    (%'ModuleName'_PixelDim)(h-(2*%'ModuleName'%.BUTTON_LINE_WIDTH)),
    bottomLineColor);
  return ERR_OK;
}

%-INTERNAL_METHOD_END PaintButton
%-************************************************************************************************************
%-BW_METHOD_BEGIN CreateButton
%ifdef CreateButton
%define! Parwindow
%define! Parbutton
%define! Parx
%define! Pary
%define! Parwidth
%define! Parheight
%define! Partext
%define! Parfont
%define! ParbtnColor
%define! RetVal
%include Common\UserInterfaceCreateButton.Inc
byte %'ModuleName'%.%CreateButton(%'ModuleName'_Window *window, %'ModuleName'_Button *button, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim width, %'ModuleName'_PixelDim height, byte *text, %'ModuleName'_FontCallbacks *font, %'ModuleName'_PixelColor btnColor)
{
  if (window == NULL || button == NULL) {
    return ERR_FAILED;
  }
%ifdef FixedFont
  font = %@FixedFont@'ModuleName'%.GetFont();
%endif
  if (width == 0) {                                              %>40/* auto size */
    width =  (%'ModuleName'_PixelDim)(%@FontDisplay@'ModuleName'%.GetStringWidth(text, font, NULL)
           + 2*%'ModuleName'%.BUTTON_LINE_WIDTH                  %>40/* left and right button border */
           + 2*%'ModuleName'%.BUTTON_TEXT_BORDER_WIDTH);         %>40/* space border around button text */
  }
  if (height == 0) {                                             %>40/* auto size */
    height =  (%'ModuleName'_PixelDim)(%@FontDisplay@'ModuleName'%.GetStringHeight(text, font, NULL)
            + 2*%'ModuleName'%.BUTTON_LINE_WIDTH                 %>40/* top and lower button border */
            + 2*%'ModuleName'%.BUTTON_TEXT_BORDER_WIDTH          %>40/* space border around button text */
            + %'ModuleName'%.BUTTON_PRESS_Y_DELTA);              %>40/* needed additional space for the button text in pressed state */
  }
  %'ModuleName'%.ElementInitCommon((%'ModuleName'_Element*)button, %'ModuleName'_BUTTON,
    x, y, width, height,
    btnColor, (%'ModuleName'%.painterCallback)PaintButton);
  button->textInfo.deltaX = (%'ModuleName'_PixelDim)(%'ModuleName'%.BUTTON_LINE_WIDTH+%'ModuleName'%.BUTTON_TEXT_BORDER_WIDTH);
  button->textInfo.deltaY = (%'ModuleName'_PixelDim)(%'ModuleName'%.BUTTON_LINE_WIDTH+%'ModuleName'%.BUTTON_TEXT_BORDER_WIDTH);
  button->textInfo.text = text;
%ifndef FixedFont
  button->textInfo.font = font;
%endif
%ifndef FixedTextForegroundColor
  button->textInfo.txtColor = %@Display@'ModuleName'%.COLOR_%DefaultButtonTextForegroundColor;
%endif
  button->isPressed = FALSE;
  if (%'ModuleName'%.WindowAddElement(window, (%'ModuleName'%.Element *)button) != ERR_OK) {
    return ERR_FAILED;
  }
  return ERR_OK;
}

%endif %- CreateButton
%-BW_METHOD_END CreateButton
%-************************************************************************************************************
%-BW_METHOD_BEGIN CheckBoxIsChecked
%ifdef CheckBoxIsChecked
%define! ParcheckBox
%define! RetVal
%include Common\UserInterfaceCheckBoxIsChecked.Inc
#if 0
bool %'ModuleName'%.%CheckBoxIsChecked(%'ModuleName'_CheckBox *checkBox)
{
 /* function is implemented as macro in the header file */
}
#endif

%endif %- CheckBoxIsChecked
%-BW_METHOD_END CheckBoxIsChecked
%-************************************************************************************************************
%-BW_METHOD_BEGIN CheckBoxSet
%ifdef CheckBoxSet
%define! ParcheckBox
%define! Parchecked
%include Common\UserInterfaceCheckBoxSet.Inc
void %'ModuleName'%.%CheckBoxSet(%'ModuleName'_CheckBox *checkBox, bool checked)
{
  if (checkBox->isChecked != checked) {
    checkBox->isChecked = checked;                               %>40 /* set new status */
    checkBox->element.prop.flags |= %'ModuleName'_FLAGS_NEEDS_REPAINT;%>40 /* mark element as due for update */
  }
}

%endif %- CheckBoxSet
%-BW_METHOD_END CheckBoxSet
%-************************************************************************************************************
%-BW_METHOD_BEGIN PressButton
%ifdef PressButton
%define! Parbutton
%define! Parwindow
%include Common\UserInterfacePressButton.Inc
void %'ModuleName'%.%PressButton(%'ModuleName'_Window *window, %'ModuleName'_Button *button)
{
  if (!button->isPressed) {
    button->isPressed = TRUE;                                    %>40 /* change button state */
    button->element.prop.flags |= %'ModuleName'_FLAGS_NEEDS_REPAINT;%>40 /* mark element as due for update */
    %'ModuleName'%.%UpdateElement(window, (%'ModuleName'_Element*)button);%>40/* element needs update */
  }
}

%endif %- PressButton
%-BW_METHOD_END PressButton
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReleaseButton
%ifdef ReleaseButton
%define! Parbutton
%define! Parwindow
%include Common\UserInterfaceReleaseButton.Inc
void %'ModuleName'%.%ReleaseButton(%'ModuleName'_Window *window, %'ModuleName'_Button *button)
{
  if (button->isPressed) {
    button->isPressed = FALSE;                                   %>40 /* change button state */
    button->element.prop.flags |= %'ModuleName'_FLAGS_NEEDS_REPAINT;%>40 /* mark element as due for update */
    %'ModuleName'%.%UpdateElement(window, (%'ModuleName'_Element*)button);%>40/* element needs update */
  }
}

%endif %- ReleaseButton
%-BW_METHOD_END ReleaseButton
%-************************************************************************************************************
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG PaintBarGraph
%define! Parwindow
%define! Parelement
%define! RetVal
%include Common\GeneralInternalGlobal.inc (PaintBarGraph)
static byte PaintBarGraph(%'ModuleName'_Window *window, %'ModuleName'_Element *element)
{
  %'ModuleName'_BarGraph *barGraph = (%'ModuleName'_BarGraph*)element;
  byte i;
  %'ModuleName'_PixelDim barHeight; /* for calculation of each bar height */
  %'ModuleName'_PixelDim barWidth; /* bar width, based on even distribution of the bars */
  %'ModuleName'_PixelDim x, y, width, height;

  x = (%'ModuleName'_PixelDim)(element->prop.x+window->prop.x);
  y = (%'ModuleName'_PixelDim)(element->prop.y+window->prop.y);
  width = element->prop.width;
  height = element->prop.height;
  %@Display@'ModuleName'%.DrawFilledBox(x, y, width, height, element->prop.color);
  if (barGraph->borderWidth > 0) { /* border */
    %@Display@'ModuleName'%.DrawBox(x, y, width, height, barGraph->borderWidth, barGraph->borderColor);
  }
  /* reduce drawing area because of border */
  x += barGraph->borderWidth+barGraph->borderSpace;
  y += barGraph->borderWidth+barGraph->borderSpace;
  width -= 2*(barGraph->borderWidth+barGraph->borderSpace);
  height -= 2*(barGraph->borderWidth+barGraph->borderSpace);

  /* calculate bar width based on number of bars so we fill out our drawing area */
  barWidth = (%'ModuleName'_PixelDim)((width-(barGraph->nofData+1)*barGraph->borderSpace)/barGraph->nofData);

  /* draw the bars */
  for(i=0; i<barGraph->nofData; i++) {
    barHeight = (%'ModuleName'_PixelDim)((height*barGraph->data[i])/100); /* scale with %% value */
    if (barHeight > 0) {
      %@Display@'ModuleName'%.DrawFilledBox(x, (%'ModuleName'_PixelDim)(y+height-barHeight), barWidth, barHeight, barGraph->barColor);
    }
    x += barWidth+barGraph->borderSpace;
  }
  return ERR_OK;
}

%-INTERNAL_METHOD_END PaintBarGraph
%-************************************************************************************************************
%-BW_METHOD_BEGIN ChangeBarGraphData
%ifdef ChangeBarGraphData
%define! ParbarGraph
%define! Parwindow
%define! Parindex
%define! ParnewData
%define! RetVal
%include Common\UserInterfaceChangeBarGraphData.Inc
byte %'ModuleName'%.%ChangeBarGraphData(%'ModuleName'_Window *window, %'ModuleName'_BarGraph *barGraph, byte index, byte newData)
{
  %'ModuleName'_PixelDim oldBarHeight, newBarHeight; /* for calculation of each bar height */
  %'ModuleName'_PixelDim barWidth; /* bar width, based on even distribution of the bars */
  %'ModuleName'_PixelDim x, y, width, height;

  if (index >= barGraph->nofData || newData > 100) {             %>40/* data index out of range! */
    return ERR_FAILED;
  }
  if (barGraph->data[index] == newData) {                        %>40/* same value, nothing to do */
    return ERR_OK;
  }
  x = (%'ModuleName'_PixelDim)(barGraph->element.prop.x+window->prop.x);
  y = (%'ModuleName'_PixelDim)(barGraph->element.prop.y+window->prop.y);
  width = barGraph->element.prop.width;
  height = barGraph->element.prop.height;
  /* reduce drawing area because of border */
  x += barGraph->borderWidth+barGraph->borderSpace;
  y += barGraph->borderWidth+barGraph->borderSpace;
  width -= 2*(barGraph->borderWidth+barGraph->borderSpace);
  height -= 2*(barGraph->borderWidth+barGraph->borderSpace);
  /* calculate bar width based on number of bars so we fill out our drawing area */
  barWidth = (%'ModuleName'_PixelDim)((width-(barGraph->nofData+1)*barGraph->borderSpace)/barGraph->nofData);
  /* draw the bars */
  x += index*(barWidth+barGraph->borderSpace);
  oldBarHeight = (%'ModuleName'_PixelDim)((height*barGraph->data[index])/100);%>40/* scale with %% value */
  newBarHeight = (%'ModuleName'_PixelDim)((height*newData)/100); %>40/* scale with %% value */
  if (newBarHeight > oldBarHeight) {                             %>40/* simply draw new higher bar */
    %@Display@'ModuleName'%.DrawFilledBox(x, (%'ModuleName'_PixelDim)(y+height-newBarHeight), barWidth, (%'ModuleName'_PixelDim)(newBarHeight-oldBarHeight), barGraph->barColor);
  } else {                                                       %>40/* draw the difference as background */
    %@Display@'ModuleName'%.DrawFilledBox(x, (%'ModuleName'_PixelDim)(y+height-oldBarHeight), barWidth, (%'ModuleName'_PixelDim)(oldBarHeight-newBarHeight), barGraph->element.prop.color);
  }
  barGraph->data[index] = newData;
  return ERR_OK;
}

%endif %- ChangeBarGraphData
%-BW_METHOD_END ChangeBarGraphData
%-************************************************************************************************************
%-BW_METHOD_BEGIN CreateBarGraph
%ifdef CreateBarGraph
%define! Parwindow
%define! Parx
%define! Pary
%define! Parwidth
%define! Parheight
%define! Pardata
%define! ParnofData
%define! ParbarColor
%define! ParborderWidth
%define! ParborderColor
%define! ParborderSpace
%define! ParbarGraph
%define! ParbgColor
%define! RetVal
%include Common\UserInterfaceCreateBarGraph.Inc
byte %'ModuleName'%.%CreateBarGraph(%'ModuleName'_Window *window, %'ModuleName'_BarGraph *barGraph, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim width, %'ModuleName'_PixelDim height, %'ModuleName'_PixelColor bgColor, byte *data, byte nofData, %'ModuleName'_PixelColor barColor, byte borderWidth, %'ModuleName'_PixelColor borderColor, byte borderSpace)
{
  byte i;

  %'ModuleName'%.ElementInitCommon((%'ModuleName'_Element*)barGraph, %'ModuleName'_BARGRAPH,
    x, y, width, height,
    bgColor, (%'ModuleName'%.painterCallback)PaintBarGraph);
  barGraph->barColor = barColor;
  barGraph->borderWidth = borderWidth;
  barGraph->borderColor = borderColor;
  barGraph->borderSpace = borderSpace;
  barGraph->nofData = nofData;
  barGraph->data = data;
  for(i=0; i<nofData; i++) {
    if (data[i] > 100) {                                         %>40/* values have to be in range 0..100 */
      return ERR_FAILED;
    }
  }
  if (%'ModuleName'%.WindowAddElement(window, (%'ModuleName'%.Element *)barGraph) != ERR_OK) {
    return ERR_FAILED;
  }
  return ERR_OK;
}

%endif %- CreateBarGraph
%-BW_METHOD_END CreateBarGraph
%-************************************************************************************************************
%-************************************************************************************************************
%-************************************************************************************************************
%-BW_METHOD_BEGIN EnableElementSelection
%ifdef EnableElementSelection
%define! Parelem
%include Common\UserInterfaceEnableElementSelection.Inc
#if 0
void %'ModuleName'%.%EnableElementSelection(%'ModuleName'_Element *elem)
{
  /* method is implemented as macro in the header file */
}
#endif

%endif %- EnableElementSelection
%-BW_METHOD_END EnableElementSelection
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG PrevElement
%define! Parscreen
%define! ParppWindow
%define! ParppElement
%include Common\GeneralInternalGlobal.inc (PrevElement)
#if defined(__HIWARE__)
  #pragma MESSAGE DISABLE C1855 /* Recursive function call */
#endif
static void PrevElement(%'ModuleName'_Screen *screen, %'ModuleName'_PWindow *ppWindow, %'ModuleName'_PElement *ppElement)
{
%if SelectionEnabled='no'
  (void)screen; (void)ppWindow; (void)ppElement; /* not used, as component settings have selections disabled */
%else
  /* precondition: screen != NULL, ppWindow != NULL, ppElement != NULL */
  %'ModuleName'_Element *e, *eNext;
  %'ModuleName'_Window *w, *weNext;

  if (screen->first == NULL) {
    return;                                                      %>40/* no window at all? */
  }
  if (screen->selectedW != NULL && (screen->selectedW->flags&%'ModuleName'_FLAGS_WINDOW_IS_MODAL)) {%>40/* modal window */
    w = screen->selectedW;
  } else {
    w = screen->first;
  }
  e = w->first;
  eNext = e;
  weNext = w;
  for(;;) {                                                      %>40/* find previous element in element list */
    /* advance e in chain of elements */
    if (e->prop.flags & %'ModuleName'_FLAGS_IS_SUBWINDOW) {      %>40/* sub-window */
      %'ModuleName'_Window *ew = (%'ModuleName'_Window*)((byte*)e+sizeof(%'ModuleName'_Element));

      w = ew;
      e = ew->first;
    } else if (e->next != NULL) {
      e = e->next;
    } else if (!(w->flags&%'ModuleName'_FLAGS_WINDOW_IS_MODAL) && w->next != NULL) {%>40/* go to next window */
      w = w->next;
      e = w->first;
    } else if (w->flags&%'ModuleName'_FLAGS_WINDOW_IS_MODAL) {   %>40/* start again in modal window */
      e = w->first;
    } else {                                                     %>40/* reached end of list, start over */
      w = screen->first;
      e = w->first;
    }
    if (e == NULL || w == NULL) {
      return;                                                    %>40/* something wrong here! */
    }
    /* advance eNext in chain of elements */
    if (e->prop.flags & %'ModuleName'_FLAGS_IS_SUBWINDOW) {      %>40/* sub-window */
      %'ModuleName'_Window *ew = (%'ModuleName'_Window*)((byte*)e+sizeof(%'ModuleName'_Element));

      weNext = ew;
      eNext = ew->first;
    } else if (e->next != NULL) {                                %>40/* iterate through elements in window */
      eNext = e->next;
    } else if (!(weNext->flags&%'ModuleName'_FLAGS_WINDOW_IS_MODAL) && weNext->next != NULL) {%>40/* go to first element in next window */
      weNext = weNext->next;
      eNext = weNext->first;
    } else if (weNext->flags&%'ModuleName'_FLAGS_WINDOW_IS_MODAL) {%>40/* go to first element in modal window */
      eNext = weNext->first;
    } else {                                                     %>40/* reached end of list, start over */                                                    %>40/* there are no elements any more */
      weNext = screen->first;
      eNext = weNext->first;
    }
    if (eNext == NULL || weNext == NULL) {
      return;                                                    %>40/* something wrong here! */
    }
    if (eNext == *ppElement) {                                   %>40/* found matching item */
      *ppWindow = w;
      *ppElement = e;
      return;                                                    %>40/* all ok! */
    }
  } /* while */
%endif %- SelectionEnabled='no'
}
#if defined(__HIWARE__)
  #pragma MESSAGE DEFAULT C1855 /* Recursive function call */
#endif

%-INTERNAL_METHOD_END PrevElement
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG NextElement
%define! Parscreen
%define! ParppWindow
%define! ParppElement
%include Common\GeneralInternalGlobal.inc (NextElement)
static void NextElement(%'ModuleName'_Screen *screen, %'ModuleName'_PWindow *ppWindow, %'ModuleName'_PElement *ppElement)
{
  /* precondition: screen != NULL, ppWindow != NULL, ppElement != NULL */
  if ((*ppElement)->prop.flags & %'ModuleName'_FLAGS_IS_SUBWINDOW) {%>40/* subwindow */
    %'ModuleName'_SubWindow *subWElem = (%'ModuleName'_SubWindow*)*ppElement;

    if (subWElem->subWindow.first!=NULL) { /* iterate through subwindow elements */
      *ppWindow = &subWElem->subWindow;
      *ppElement = subWElem->subWindow.first;
      return;
    }
  }
  if ((*ppElement)->next != NULL) {
    *ppElement = (*ppElement)->next;
  } else if (!((*ppWindow)->flags&%'ModuleName'_FLAGS_WINDOW_IS_MODAL) && (*ppWindow)->next != NULL) {%>40/* next window in chain */
    *ppWindow = (*ppWindow)->next;
    *ppElement = (*ppWindow)->first;
  } else if ((*ppWindow)->flags&%'ModuleName'_FLAGS_WINDOW_IS_MODAL) {%>40/* modal window */
    *ppElement = (*ppWindow)->first;                             %>40/* first element in modal window */
  } else {                                                       %>40/* first window in chain */
    *ppWindow = screen->first;
    *ppElement = (*ppWindow)->first;
  }
}

%-INTERNAL_METHOD_END NextElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN SelectNextElement
%ifdef SelectNextElement
%define! Parforward
%define! Parscreen
%include Common\UserInterfaceSelectNextElement.Inc
void %'ModuleName'%.%SelectNextElement(%'ModuleName'_Screen *screen, bool forward)
{
%if SelectionEnabled='yes'
  %'ModuleName'_Element *currE;                                  %>40/* currently selected element */
  %'ModuleName'_Window *currEW;                                  %>40/* window of currently selected element */
  %'ModuleName'_Element *startE;                                 %>40/* starting element of iteration */

  if (screen == NULL || screen->first == NULL) {                 %>40/* no screen or no windows at all? */
    return;
  }
  /* postcondition: screen->first != NULL */
  if (screen->selectedW != NULL && screen->selectedW->selectedE != NULL) {%>40/* we have an element already selected */
    currEW = screen->selectedW;
    currE = screen->selectedW->selectedE;
    if (currE != NULL && (currE->prop.flags&%'ModuleName'_FLAGS_IS_SUBWINDOW)) {%>40/* we are a subwindow */
      %'ModuleName'_SubWindow *subWElem = (%'ModuleName'_SubWindow*)currE;

      currEW = &subWElem->subWindow;
      currE = currEW->selectedE;
    }
    %'ModuleName'%.DeselectElement(screen, currEW, currE);
  } else if (screen->selectedW != NULL && (screen->selectedW->flags&%'ModuleName'_FLAGS_WINDOW_IS_MODAL)) {%>40/* modal window */
    currEW = screen->selectedW;
    currE = currEW->first;
  } else { /* we have no current selected element: use first in chain */
    currEW = screen->first;
    currE = currEW->first;
  }

  startE = currE;
  do {
    if (forward) {
      NextElement(screen, &currEW, &currE); /* select next element, we will go forward */
    } else {
      PrevElement(screen, &currEW, &currE); /* select previous element, we will go backward */
    }
    if (currE == NULL) {                                         %>40/* no element at all? */
      break;
    }
    if (currE == startE) {                                       %>40/* wrap over, no element to select? */
      if (screen->selectedW != NULL) {
        if (screen->selectedW->selectedE != NULL) {
          screen->selectedW->selectedE = NULL;
        }
        if (!(screen->selectedW->flags&%'ModuleName'_FLAGS_WINDOW_IS_MODAL)) {%>40/* only for non-modal windows */
          screen->selectedW = NULL;
        }
      }
      break;
    }
    if (currE->prop.flags&%'ModuleName'_FLAGS_CAN_SELECT) {      %>40/* ok, can select element: break out of loop */
      break;
    }
  } while (1);                                                   %>40/* iterate elements */
  if (currE != NULL && currE != startE && (currE->prop.flags&%'ModuleName'_FLAGS_CAN_SELECT)) {
    if (currEW->parentE != NULL && (currEW->parentE->prop.flags&%'ModuleName'_FLAGS_IS_SUBWINDOW)) {%>40/* we are a subwindow */
      %'ModuleName'_SubWindow *subWElem = (%'ModuleName'_SubWindow*)currEW->parentE;

      if (subWElem->parentWindow != NULL) {
        subWElem->parentWindow->selectedE = currEW->parentE;     %>40/* point to currently selected element */
      }
    }
    screen->selectedW = currEW;
    currEW->selectedE = currE;
    currE->prop.flags |= (%'ModuleName'_FLAGS_IS_SELECTED|%'ModuleName'_FLAGS_NEEDS_REPAINT);%>40/* select element and repaint it */
    UpdateElementNoRefresh(currEW, currEW->selectedE, FALSE);    %>40/* element needs update */
    %@Display@'ModuleName'%.UpdateRegion(
      (%'ModuleName'_PixelDim)(currEW->prop.x+currEW->selectedE->prop.x),
      (%'ModuleName'_PixelDim)(currEW->prop.y+currEW->selectedE->prop.y),
      currEW->selectedE->prop.width,
      currEW->selectedE->prop.height
      );
  }
%else
  (void)window; (void)forward;
  /* do nothing, as selection is not enabled in the bean properties */
%endif
}

%endif %- SelectNextElement
%-BW_METHOD_END SelectNextElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN SelectElement
%ifdef SelectElement
%define! Parwindow
%define! Parelement
%define! Parscreen
%include Common\UserInterfaceSelectElement.Inc
void %'ModuleName'%.%SelectElement(%'ModuleName'_Screen *screen, %'ModuleName'_Window *window, %'ModuleName'_Element *element)
{
%if SelectionEnabled='yes'
  if (window != NULL && screen != NULL && element!=NULL) {
    if (   (element->prop.flags&%'ModuleName'_FLAGS_CAN_SELECT)  %>40/* element can be selected */
        && !(element->prop.flags&%'ModuleName'_FLAGS_IS_SELECTED)%>40/* element is not currently selected */
       )
    {
      %if defined(OnEvent)
      %OnEvent(screen, window, element, %'ModuleName'_EVENT_ELEMENT_SELECT);%>40/* call user event */
      %endif
      element->prop.flags |= (%'ModuleName'_FLAGS_IS_SELECTED|%'ModuleName'_FLAGS_NEEDS_REPAINT);%>40/* select element, and it needs a repaint */
      screen->selectedW = window;
      window->selectedE = element;
      %'ModuleName'%.%UpdateElement(window, window->selectedE);  %>40/* element needs update */
    }
  }
%else
  (void)screen; (void)window; (void)element;
  /* do nothing, as selection is not enabled in the bean properties */
%endif
}

%endif %- SelectElement
%-BW_METHOD_END SelectElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN DeselectElement
%ifdef DeselectElement
%define! Parscreen
%define! Parwindow
%define! Parelement
%include Common\UserInterfaceDeselectElement.Inc
void %'ModuleName'%.%DeselectElement(%'ModuleName'_Screen *screen, %'ModuleName'_Window *window, %'ModuleName'_Element *element)
{
  if (window != NULL && screen != NULL && element!=NULL) {
    if (element->prop.flags&%'ModuleName'_FLAGS_IS_SELECTED) {   %>40/* element is currently selected */
      %if defined(OnEvent)
      %OnEvent(screen, window, element, %'ModuleName'_EVENT_ELEMENT_DESELECT);%>40/* call user event */
      %endif
      element->prop.flags &= ~%'ModuleName'_FLAGS_IS_SELECTED;   %>40/* unselect current selected element */
      element->prop.flags |= %'ModuleName'_FLAGS_NEEDS_REPAINT;  %>40/* need to repaint element */
      UpdateElementNoRefresh(window, element, FALSE);
      %@Display@'ModuleName'%.UpdateRegion(
        (%'ModuleName'_PixelDim)(window->prop.x+element->prop.x),
        (%'ModuleName'_PixelDim)(window->prop.y+element->prop.y),
        element->prop.width,
        element->prop.height
        );
      if (!(screen->selectedW->flags&%'ModuleName'_FLAGS_WINDOW_IS_MODAL)) {%>40/* if window is modal, we need to keep it selected */
        screen->selectedW = NULL;                                %>40/* no currently slected window */
      }
      window->selectedE = NULL;                                  %>40/* no currently selected element */
    }
  }
}

%endif %- DeselectElement
%-BW_METHOD_END DeselectElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN ClickElement
%ifdef ClickElement
%define! Parscreen
%define! Parwindow
%define! Parelement
%define! Parkind
%define! Pardata
%include Common\UserInterfaceClickElement.Inc
static bool FctButtonIsPressed(%'ModuleName'_Screen *screen, %'ModuleName'_Window *window, %'ModuleName'_Element *element, void *data) {
  (void)screen;
  (void)window;
  (void)data;
  return ((element->prop.type==%'ModuleName'_BUTTON) && ((%'ModuleName'_Button*)element)->isPressed);
}

void %'ModuleName'%.%ClickElement(%'ModuleName'_Screen *screen, %'ModuleName'_Window *window, %'ModuleName'_Element *element, %'ModuleName'_EventCallbackKind kind, %'ModuleName'_Pvoid data)
{
%if SelectionEnabled='yes'
  %'ModuleName'_Window *selWindow;
  %'ModuleName'_Element *selElement;

  if (screen==NULL) {
    return;                                                      %>40/* something wrong here */
  }
  if (window==NULL || element==NULL) {                           %>40/* click, but no window/element to click */
    if (%'ModuleName'%.%GetSelectedElement(screen, &selWindow, &selElement)) {
      /* there is an element selected? */
      %'ModuleName'%.%DeselectElement(screen, selWindow, selElement);
    }
    if (%'ModuleName'%.%FindElement(screen, &selWindow, &selElement, FctButtonIsPressed, NULL)) {%>40/* is there a button pressed? */
      %'ModuleName'%.%ReleaseButton(selWindow, (%'ModuleName'_Button*)selElement);
    }
    return;
  }
%if defined(OnEvent)
  %OnEvent(screen, window, element, kind);                       %>40/* call user event */
%endif
  if (kind == %'ModuleName'_EVENT_CLICK) {                       %>40/* click down */
  %if AnimatedButtons='yes'
    /* deselect an already selected element or button */
    if (%'ModuleName'%.%GetSelectedElement(screen, &selWindow, &selElement) && element!=selElement) {
      /* there is another element already selected: deselect it */
      %'ModuleName'%.%DeselectElement(screen, selWindow, selElement);
    }
    if (%'ModuleName'%.%FindElement(screen, &selWindow, &selElement, FctButtonIsPressed, NULL) && element!=selElement) {
      /* there is another button pressed: release it */
      %'ModuleName'%.%ReleaseButton(selWindow, (%'ModuleName'_Button*)selElement);
    }
    if (element->prop.type == %'ModuleName'_BUTTON) {
      %'ModuleName'%.%PressButton(window, (%'ModuleName'_Button*)element);
    } else {
      %'ModuleName'%.%SelectElement(screen, window, element);
    }
    return;                                                      %>40/* we call the callback at release time */
  %else
    if (element->prop.type == %'ModuleName'_CHECKBOX) {
      %'ModuleName'%.%CheckBoxSet((%'ModuleName'_CheckBox*)element,
        (bool)(!%'ModuleName'%.%CheckBoxIsChecked((%'ModuleName'_CheckBox*)element))
      );
      %'ModuleName'%.%UpdateElement(window, element);            %>40/* element needs update */
    } else if (element->prop.type == %'ModuleName'_SCROLLMENU) {
      %'ModuleName'%.%ScrollMenuSetSelection((%'ModuleName'_ScrollMenu*)element, (byte)(%'ModuleName'%.%ScrollMenuGetSelection((%'ModuleName'_ScrollMenu*)element)+1));
      %'ModuleName'%.%UpdateElement(window, element);            %>40/* element needs update */
    }
  %endif
  %if AnimatedButtons='yes'
  } else if (kind == %'ModuleName'_EVENT_CLICK_RELEASE || kind == %'ModuleName'_EVENT_CLICK_LONG) {
    if (element->prop.type == %'ModuleName'_BUTTON) {
      %'ModuleName'%.%ReleaseButton(window, (%'ModuleName'_Button*)element);
    } else {
      /* %'ModuleName'%.%DeselectElement(screen, window, element); */%>40/* do NOT deselect element (needed for keyboard support) */
      if (element->prop.type == %'ModuleName'_CHECKBOX) {
        %'ModuleName'%.%CheckBoxSet((%'ModuleName'_CheckBox*)element,
          (bool)(!%'ModuleName'%.%CheckBoxIsChecked((%'ModuleName'_CheckBox*)element))
        );
        %'ModuleName'%.%UpdateElement(window, element);          %>40/* element needs update */
      } else if (element->prop.type == %'ModuleName'_SCROLLMENU) {
        %'ModuleName'%.%ScrollMenuSetSelection((%'ModuleName'_ScrollMenu*)element, (byte)(%'ModuleName'%.%ScrollMenuGetSelection((%'ModuleName'_ScrollMenu*)element)+1));
        %'ModuleName'%.%UpdateElement(window, element);          %>40/* element needs update */
      }
    }
    kind = %'ModuleName'_EVENT_CLICK;
  %endif
  }
  if (window->eventCallback != NULL) {
    window->eventCallback(window, element, kind, data);
  }
%else
  /* do nothing, as selection is not enabled in the bean properties */
%endif
}

%endif %- ClickElement
%-BW_METHOD_END ClickElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN ClickSelectedElement
%ifdef ClickSelectedElement
%define! Parscreen
%define! Parkind
%define! Pardata
%include Common\UserInterfaceClickSelectedElement.Inc
void %'ModuleName'%.%ClickSelectedElement(%'ModuleName'_Screen *screen, %'ModuleName'_EventCallbackKind kind, %'ModuleName'_Pvoid data)
{
  %'ModuleName'_Window *window;
  %'ModuleName'_Element *element;

  (void)%'ModuleName'%.%GetSelectedElement(screen, &window, &element);
  %'ModuleName'%.%ClickElement(screen, window, element, kind, data);
}

%endif %- ClickSelectedElement
%-BW_METHOD_END ClickSelectedElement
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG PaintScrollMenu
%define! Parwindow
%define! Parelement
%define! RetVal
%include Common\GeneralInternalGlobal.inc (PaintScrollMenu)
static byte PaintScrollMenu(%'ModuleName'_Window *window, %'ModuleName'_Element *element)
{
  %'ModuleName'_ScrollMenu *scrollMenu;
  %'ModuleName'_PixelDim x, y, w, h;
  byte res;
  unsigned char buf[%ScrollMenuNofChars+1];
  struct {
    %'ModuleName'_Element element;
    %'ModuleName'_TextInfo textInfo;
  } info;                                                        %>40 /* temporary information for pressed button text */
  unsigned char *p;
  byte i;

  if (element == NULL) {
    return ERR_FAILED;
  }
  if (element->prop.type != %'ModuleName'_SCROLLMENU) {
    return ERR_FAILED;
  }
  scrollMenu = (%'ModuleName'_ScrollMenu*)element;
  if (scrollMenu->textInfo.text == NULL) {
    return ERR_FAILED;
  }
  i = scrollMenu->selectedItem;
  p = scrollMenu->textInfo.text;
  while(i>0 && *p!='\0') {                                       %>40/* find start of menu string */
    if(*p=='\r') {
      i--;
    }
    p++;
  }
  i = 0;
  while(i<%ScrollMenuNofChars && *p!='\r' && *p!='\0') {
    buf[i++] = *p++;
  }
  buf[i] = '\0';
  /* draw text */
  (void)memcpy(&info, element, sizeof(%'ModuleName'_Element)+sizeof(%'ModuleName'_TextInfo));
  /* because of the shift below, we need to fill the remaining part */
  info.textInfo.text = buf;
  res = %'ModuleName'%.PaintText(window, (%'ModuleName'_Element*)&info);
  if (res != ERR_OK) {
    return res;
  }
  x = element->prop.x;
  y = element->prop.y;
  w = element->prop.width;
  h = element->prop.height;
  /* draw lines around the menu */
  %'ModuleName'%.DrawBox(window, x, y, w, h, %'ModuleName'%.SCROLLMENU_LINE_WIDTH, scrollMenu->boxLineColor);
  %'ModuleName'%.DrawFilledBox(window,
    (%'ModuleName'_PixelDim)(x+%'ModuleName'%.SCROLLMENU_LINE_WIDTH),
    (%'ModuleName'_PixelDim)(y+%'ModuleName'%.SCROLLMENU_LINE_WIDTH),
    (%'ModuleName'_PixelDim)(h-2*%'ModuleName'%.SCROLLMENU_LINE_WIDTH),
    (%'ModuleName'_PixelDim)(h-2*%'ModuleName'%.SCROLLMENU_LINE_WIDTH),
    scrollMenu->boxBgColor);
  /* draw the 'V' */
  %'ModuleName'%.DrawLine(window,
    (%'ModuleName'_PixelDim)(x+%'ModuleName'%.SCROLLMENU_LINE_WIDTH),
    (%'ModuleName'_PixelDim)(y+%'ModuleName'%.SCROLLMENU_LINE_WIDTH),
    (%'ModuleName'_PixelDim)(x+(h/2)),
    (%'ModuleName'_PixelDim)(y+h-%'ModuleName'%.SCROLLMENU_LINE_WIDTH),
    scrollMenu->boxLineColor);
  %'ModuleName'%.DrawLine(window,
    (%'ModuleName'_PixelDim)(x+(h/2)),
    (%'ModuleName'_PixelDim)(y+h-%'ModuleName'%.SCROLLMENU_LINE_WIDTH),
    (%'ModuleName'_PixelDim)(x+h-(2*%'ModuleName'%.SCROLLMENU_LINE_WIDTH)),
    (%'ModuleName'_PixelDim)(y+%'ModuleName'%.SCROLLMENU_LINE_WIDTH),
    scrollMenu->boxLineColor);
  %'ModuleName'%.DrawFilledBox(window,
    (%'ModuleName'_PixelDim)(x+h-%'ModuleName'%.SCROLLMENU_LINE_WIDTH),
    (%'ModuleName'_PixelDim)(y+%'ModuleName'%.SCROLLMENU_LINE_WIDTH),
    %'ModuleName'%.SCROLLMENU_LINE_WIDTH,
    (%'ModuleName'_PixelDim)(h-(2*%'ModuleName'%.SCROLLMENU_LINE_WIDTH)),
    scrollMenu->boxLineColor);
  return ERR_OK;
}

%-INTERNAL_METHOD_END PaintScrollMenu
%-************************************************************************************************************
%-BW_METHOD_BEGIN CreateScrollMenu
%ifdef CreateScrollMenu
%define! Parwindow
%define! ParscrollMenu
%define! Parx
%define! Pary
%define! Parwidth
%define! Parheight
%define! Partext
%define! Parfont
%define! ParlineColor
%define! ParbgColor
%define! ParboxBgColor
%define! RetVal
%include Common\UserInterfaceCreateScrollMenu.Inc
byte %'ModuleName'%.%CreateScrollMenu(%'ModuleName'_Window *window, %'ModuleName'_ScrollMenu *scrollMenu, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim width, %'ModuleName'_PixelDim height, byte *text, %'ModuleName'_FontCallbacks *font, %'ModuleName'_PixelColor bgColor, %'ModuleName'_PixelColor lineColor, %'ModuleName'_PixelColor boxBgColor)
{
  if (window == NULL || scrollMenu == NULL) {
    return ERR_FAILED;
  }
%ifdef FixedFont
  font = %@FixedFont@'ModuleName'%.GetFont();
%endif
  if (height == 0) {                                             %>40/* auto size */
    height =  (%'ModuleName'_PixelDim)(%@FontDisplay@'ModuleName'%.GetStringHeight(text, font, NULL)
             + 2*%'ModuleName'%.SCROLLMENU_LINE_WIDTH            %>40/* top and lower lines */
             + 2*%'ModuleName'%.SCROLLMENU_TEXT_BORDER_WIDTH);   %>40/* space border around text */
  }
  if (width == 0) {                                              %>40/* auto size */
    width =  (%'ModuleName'_PixelDim)(%@FontDisplay@'ModuleName'%.GetStringWidth(text, font, NULL)
           + height                                              %>40/* the UI cue on the left is quadratic */
           + 3*%'ModuleName'%.SCROLLMENU_LINE_WIDTH              %>40/* left, middle and right right border lines */
           + 2*%'ModuleName'%.SCROLLMENU_TEXT_BORDER_WIDTH);     %>40/* space border around menu text */
  }
  %'ModuleName'%.ElementInitCommon((%'ModuleName'_Element*)scrollMenu, %'ModuleName'_SCROLLMENU,
    x, y, width, height,
    bgColor, (%'ModuleName'%.painterCallback)PaintScrollMenu);
  scrollMenu->textInfo.deltaX = (%'ModuleName'_PixelDim)(height+%'ModuleName'%.SCROLLMENU_TEXT_BORDER_WIDTH);
  scrollMenu->textInfo.deltaY = (%'ModuleName'_PixelDim)(%'ModuleName'%.SCROLLMENU_LINE_WIDTH+%'ModuleName'%.SCROLLMENU_TEXT_BORDER_WIDTH);
  scrollMenu->textInfo.text = text;
%ifndef FixedFont
  scrollMenu->textInfo.font = font;
%endif
%ifndef FixedTextForegroundColor
  scrollMenu->textInfo.txtColor = %@Display@'ModuleName'%.COLOR_%DefaultScrollMenuTextForegroundColor;
%endif
  scrollMenu->boxBgColor = boxBgColor;
  scrollMenu->boxLineColor = lineColor;
  scrollMenu->selectedItem = 0;
  if (%'ModuleName'%.WindowAddElement(window, (%'ModuleName'%.Element*)scrollMenu) != ERR_OK) {
    return ERR_FAILED;
  }
  return ERR_OK;
}

%endif %- CreateScrollMenu
%-BW_METHOD_END CreateScrollMenu
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScrollMenuNofItems
%ifdef ScrollMenuNofItems
%define! ParscrollMenu
%define! RetVal
%include Common\UserInterfaceScrollMenuNofItems.Inc
byte %'ModuleName'%.%ScrollMenuNofItems(%'ModuleName'_ScrollMenu *scrollMenu)
{
  unsigned char *p;
  byte cntr;

  p = scrollMenu->textInfo.text;
  if (p == NULL) {
    return 0;
  }
  /* items are separated by \r, so simply count the number of '\r' */
  cntr = 0;
  while (*p != '\0') {
    if (*p == '\r') {
      cntr++;
    }
    p++;
  }
  return cntr;
}

%endif %- ScrollMenuNofItems
%-BW_METHOD_END ScrollMenuNofItems
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScrollMenuSetSelection
%ifdef ScrollMenuSetSelection
%define! ParscrollMenu
%define! ParnewSelection
%include Common\UserInterfaceScrollMenuSetSelection.Inc
void %'ModuleName'%.%ScrollMenuSetSelection(%'ModuleName'_ScrollMenu *scrollMenu, byte newSelection)
{
  byte nofItems;

  if (newSelection == scrollMenu->selectedItem) {
    return;                                                      %>40/* noting to do */
  }
  nofItems = %'ModuleName'%.%ScrollMenuNofItems(scrollMenu);
  if (newSelection > nofItems) {
    newSelection = 0;                                            %>40/* wrap over */
  }
  scrollMenu->selectedItem = newSelection;
}

%endif %- ScrollMenuSetSelection
%-BW_METHOD_END ScrollMenuSetSelection
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScrollMenuGetSelection
%ifdef ScrollMenuGetSelection
%define! ParscrollMenu
%define! RetVal
%include Common\UserInterfaceScrollMenuGetSelection.Inc
#if 0
byte %'ModuleName'%.%ScrollMenuGetSelection(%'ModuleName'_ScrollMenu *scrollMenu)
{
  /* method is implemented as macro in the header file*/
}
#endif

%endif %- ScrollMenuGetSelection
%-BW_METHOD_END ScrollMenuGetSelection
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetElementWidth
%ifdef GetElementWidth
%define! Parelem
%define! RetVal
%include Common\UserInterfaceGetElementWidth.Inc
#if 0
%'ModuleName'_PixelDim %'ModuleName'%.%GetElementWidth(%'ModuleName'_Element *elem)
{
  /* method is implemented as macro in the header file */
}
#endif

%endif %- GetElementWidth
%-BW_METHOD_END GetElementWidth
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetElementHeight
%ifdef GetElementHeight
%define! Parelem
%define! RetVal
%include Common\UserInterfaceGetElementHeight.Inc
#if 0
%'ModuleName'_PixelDim %'ModuleName'%.%GetElementHeight(%'ModuleName'_Element *elem)
{
  /* method is implemented as macro in the header file */
}
#endif

%endif %- GetElementHeight
%-BW_METHOD_END GetElementHeight
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetElementPosX
%ifdef GetElementPosX
%define! Parelem
%define! RetVal
%include Common\UserInterfaceGetElementPosX.Inc
#if 0
%'ModuleName'_PixelDim %'ModuleName'%.%GetElementPosX(%'ModuleName'_Element *elem)
{
  /* method is implemented as macro in the header file */
}
#endif

%endif %- GetElementPosX
%-BW_METHOD_END GetElementPosX
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetElementPosY
%ifdef GetElementPosY
%define! Parelem
%define! RetVal
%include Common\UserInterfaceGetElementPosY.Inc
#if 0
%'ModuleName'_PixelDim %'ModuleName'%.%GetElementPosY(%'ModuleName'_Element *elem)
{
  /* method is implemented as macro in the header file */
}
#endif

%endif %- GetElementPosY
%-BW_METHOD_END GetElementPosY
%-************************************************************************************************************
%-************************************************************************************************************
%-************************************************************************************************************
%-************************************************************************************************************
%-************************************************************************************************************
%-************************************************************************************************************
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG PaintIcon
%define! Parwindow
%define! Parelement
%define! RetVal
%include Common\GeneralInternalGlobal.inc (PaintIcon)
static byte PaintIcon(%'ModuleName'_Window *window, %'ModuleName'_Element *element)
{
  %'ModuleName'_PixelDim x, y, w, h;
  %'ModuleName'_Icon *icon = (%'ModuleName'_Icon *)element;
  %'ModuleName'_PixelColor fgColor, bgColor;

%if SelectionEnabled='yes'
  if (element->prop.flags&%'ModuleName'_FLAGS_IS_SELECTED) {
    fgColor = element->prop.color;
    bgColor = icon->fgColor;
  } else {
    bgColor = element->prop.color;
    fgColor = icon->fgColor;
  }
%else
  bgColor = element->prop.color;
  fgColor = icon->fgColor;
%endif
  x = element->prop.x;
  y = element->prop.y;
  w = element->prop.width;
  h = element->prop.height;
  %if IconBox='yes'
  %'ModuleName'%.DrawBox(window, x, y, w, h, 1, fgColor);        %>40/* paint box */
  x++; y++; w -= 2; h -= 2;
  %endif
  %'ModuleName'%.DrawFilledBox(window, x, y, w, h, bgColor);     %>40/* fill background */
  x++; y++; w -= 2; h -= 2;
  if (icon->type == %'ModuleName'_ICON_CLOSE) {                  %>40/* paint an X */
    %'ModuleName'%.DrawLine(window, x, y, (%'ModuleName'_PixelDim)(x+w-1), (%'ModuleName'_PixelDim)(y+h-1), fgColor);
    %'ModuleName'%.DrawLine(window, x, (%'ModuleName'_PixelDim)(y+h-1), (%'ModuleName'_PixelDim)(x+w-1), y, fgColor);
  } else if (icon->type == %'ModuleName'_ICON_ARROW_LEFT) {      %>40/* paint <- */
    %'ModuleName'%.DrawHLine(window, x, (%'ModuleName'_PixelDim)(y+(h/2)), w, fgColor);
    %'ModuleName'%.DrawLine(window, x, (%'ModuleName'_PixelDim)(y+(h/2)), (%'ModuleName'_PixelDim)(x+(w/2)), y, fgColor);
    %'ModuleName'%.DrawLine(window, x, (%'ModuleName'_PixelDim)(y+(h/2)), (%'ModuleName'_PixelDim)(x+(w/2)), (%'ModuleName'_PixelDim)(y+h-1), fgColor);
  } else if (icon->type == %'ModuleName'_ICON_ARROW_RIGHT) {     %>40/* paint -> */
    %'ModuleName'%.DrawHLine(window, x, (%'ModuleName'_PixelDim)(y+(h/2)), w, fgColor);
    %'ModuleName'%.DrawLine(window, (%'ModuleName'_PixelDim)(x+(w/2)), y, (%'ModuleName'_PixelDim)(x+w-1), (%'ModuleName'_PixelDim)(y+(h/2)), fgColor);
    %'ModuleName'%.DrawLine(window, (%'ModuleName'_PixelDim)(x+(w/2)), (%'ModuleName'_PixelDim)(y+h-1), (%'ModuleName'_PixelDim)(x+w-1), (%'ModuleName'_PixelDim)(y+(h/2)), fgColor);
  } else if (icon->type == %'ModuleName'_ICON_ARROW_UP) {        %>40/* paint up arrow */
    %'ModuleName'%.DrawVLine(window, (%'ModuleName'_PixelDim)(x+(w/2)), y, h, fgColor);
    %'ModuleName'%.DrawLine(window, (%'ModuleName'_PixelDim)(x+(w/2)), y, x, (%'ModuleName'_PixelDim)(y+(h/2)), fgColor);
    %'ModuleName'%.DrawLine(window, (%'ModuleName'_PixelDim)(x+(w/2)), y, (%'ModuleName'_PixelDim)(x+w-1), (%'ModuleName'_PixelDim)(y+(h/2)), fgColor);
  } else if (icon->type == %'ModuleName'_ICON_ARROW_DOWN) {      %>40/* paint down arrow */
    %'ModuleName'%.DrawVLine(window, (%'ModuleName'_PixelDim)(x+(w/2)), y, h, fgColor);
    %'ModuleName'%.DrawLine(window, x, (%'ModuleName'_PixelDim)(y+(h/2)), (%'ModuleName'_PixelDim)(x+(w/2)), (%'ModuleName'_PixelDim)(y+h-1), fgColor);
    %'ModuleName'%.DrawLine(window, (%'ModuleName'_PixelDim)(x+(w/2)),(%'ModuleName'_PixelDim)(y+h-1), (%'ModuleName'_PixelDim)(x+w-1), (%'ModuleName'_PixelDim)(y+(h/2)), fgColor);
  }
  return ERR_OK;
}

%-INTERNAL_METHOD_END PaintIcon
%-************************************************************************************************************
%-BW_METHOD_BEGIN CreateIcon
%ifdef CreateIcon
%define! Parwindow
%define! Paricon
%define! Parx
%define! Pary
%define! Parwidth
%define! Parheight
%define! Partype
%define! RetVal
%include Common\UserInterfaceCreateIcon.Inc
byte %'ModuleName'%.%CreateIcon(%'ModuleName'_Window *window, %'ModuleName'_Icon *icon, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim width, %'ModuleName'_PixelDim height, %'ModuleName'_IconType type)
{
  if (window == NULL || icon == NULL) {
    return ERR_FAILED;
  }
  %'ModuleName'%.ElementInitCommon((%'ModuleName'_Element*)icon, %'ModuleName'_ICON,
    x, y, width, height,
    window->prop.color, (%'ModuleName'%.painterCallback)PaintIcon);
  icon->type = type;
  icon->fgColor = %@Display@'ModuleName'%.COLOR_BLACK;
  icon->rightOffset = x;
  if (%'ModuleName'%.WindowAddElement(window, (%'ModuleName'%.Element*)icon) != ERR_OK) {
    return ERR_FAILED;
  }
  return ERR_OK;
}

%endif %- CreateIcon
%-BW_METHOD_END CreateIcon
%-************************************************************************************************************
%-BW_METHOD_BEGIN ChangeIconFgColor
%ifdef ChangeIconFgColor
%define! ParfgColor
%define! Paricon
%include Common\UserInterfaceChangeIconFgColor.Inc
#if 0
void %'ModuleName'%.%ChangeIconFgColor(%'ModuleName'_Icon *icon, %'ModuleName'_PixelColor fgColor)
{
  /* method is implemented as macro in the header file */
}
#endif

%endif %- ChangeIconFgColor
%-BW_METHOD_END ChangeIconFgColor
%-************************************************************************************************************
%-BW_METHOD_BEGIN CreateScreen
%ifdef CreateScreen
%define! Parscreen
%define! ParbgColor
%include Common\UserInterfaceCreateScreen.Inc
void %'ModuleName'%.%CreateScreen(%'ModuleName'_Screen *screen, %'ModuleName'_PixelColor bgColor)
{
  screen->first = NULL;
%if SelectionEnabled='yes'
  screen->selectedW = NULL;
%endif
  screen->bgColor = bgColor;
  screen->updateAll = TRUE;
  currentScreen = screen;
}

%endif %- CreateScreen
%-BW_METHOD_END CreateScreen
%-************************************************************************************************************
%-BW_METHOD_BEGIN UpdateScreen
%ifdef UpdateScreen
%define! Parscreen
%include Common\UserInterfaceUpdateScreen.Inc
void %'ModuleName'%.%UpdateScreen(%'ModuleName'_Screen *screen)
{
  %'ModuleName'%.Window *window;

  if (screen != NULL) {
    window = screen->first;
    if (screen->updateAll) {                                     %>40/* start with drawing the background */
      if (   window != NULL
          && window->prop.x == 0 && window->prop.y == 0
          && window->prop.width == %'ModuleName'%.%GetWidth()
          && window->prop.height == %'ModuleName'%.%GetHeight()
         )
      {
        /* first window is filling whole screen: no need to paint screen backgound */
      } else {
        %@Display@'ModuleName'%.DrawFilledBox(0, 0, %'ModuleName'%.%GetWidth(), %'ModuleName'%.%GetHeight(), screen->bgColor);
      }
    }
    while (window != NULL) {
      if (screen->updateAll) {
        window->updateAll = TRUE;
      }
      %'ModuleName'%.%UpdateWindow(window);
      window = window->next;                                     %>40/* process next window */
    } /* while */
    screen->updateAll = FALSE;
    %@Display@'ModuleName'%.UpdateFull();
  } /* if */
}

%endif %- UpdateScreen
%-BW_METHOD_END UpdateScreen
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetWindowEventCallback
%ifdef SetWindowEventCallback
%define! Parwindow
%define! Parcallback
%include Common\UserInterfaceSetWindowEventCallback.Inc
#if 0
void %'ModuleName'%.%SetWindowEventCallback(%'ModuleName'_Window *window, void (*eventCallback)(%'ModuleName'_Window *window, %'ModuleName'_Element *element, %'ModuleName'_EventCallbackKind event, void *data))
{
  /* method is implemented in the header file as macro */
}
#endif

%endif %- SetWindowEventCallback
%-BW_METHOD_END SetWindowEventCallback
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawHLine
%ifdef DrawHLine
%define! Parwindow
%define! Parx
%define! Pary
%define! Parw
%define! Parcolor
%include Common\UserInterfaceDrawHLine.Inc
#if 0
void %'ModuleName'%.%DrawHLine(%'ModuleName'_Window *window, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim w, %'ModuleName'_PixelColor color)
{
  /* method is implemented as macro in the header file */
}
#endif

%endif %- DrawHLine
%-BW_METHOD_END DrawHLine
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawVLine
%ifdef DrawVLine
%define! Parwindow
%define! Parx
%define! Pary
%define! Parh
%define! Parcolor
%include Common\UserInterfaceDrawVLine.Inc
#if 0
void %'ModuleName'%.%DrawVLine(%'ModuleName'_Window *window, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim h, %'ModuleName'_PixelColor color)
{
  /* method is implemented as macro in the header file */
}
#endif

%endif %- DrawVLine
%-BW_METHOD_END DrawVLine
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawFilledBox
%ifdef DrawFilledBox
%define! Parwindow
%define! Parx
%define! Pary
%define! Parw
%define! Parh
%define! Parcolor
%include Common\UserInterfaceDrawFilledBox.Inc
void %'ModuleName'%.%DrawFilledBox(%'ModuleName'_Window *window, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim w, %'ModuleName'_PixelDim h, %'ModuleName'_PixelColor color)
{
%ifdef _OPTIMIZE_CLEARED_BACKGROUND
  if ((window->flags&%'ModuleName'_FLAGS_WINDOW_BG_CLEARED) && color==window->prop.color) {
    /* nothing to do, as window background just has been cleared with our color */
  } else {
    %@Display@'ModuleName'%.DrawFilledBox((%'ModuleName'_PixelDim)(window->prop.x+x), (%'ModuleName'_PixelDim)(window->y+y), w, h, color);
  }
%else
  %@Display@'ModuleName'%.DrawFilledBox((%'ModuleName'_PixelDim)(window->prop.x+x), (%'ModuleName'_PixelDim)(window->prop.y+y), w, h, color);
%endif
}

%endif %- DrawFilledBox
%-BW_METHOD_END DrawFilledBox
%-************************************************************************************************************
%-BW_METHOD_BEGIN CreateDialogWindow
%ifdef CreateDialogWindow
%define! Parscreen
%define! Parwindow
%define! ParbgColor
%define! Parx
%define! Pary
%define! Parwidth
%define! Parheight
%define! RetVal
%include Common\UserInterfaceCreateDialogWindow.Inc
byte %'ModuleName'%.%CreateDialogWindow(%'ModuleName'_Screen *screen, %'ModuleName'_Window *window, %'ModuleName'_PixelColor bgColor, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim width, %'ModuleName'_PixelDim height)
{
  if (%'ModuleName'%.%CreateWindow(screen, window, bgColor, x, y, width, height) != ERR_OK) {
    return ERR_FAILED;
  }
  window->flags |= %'ModuleName'_FLAGS_WINDOW_IS_MODAL;          %>40/* mark window as modal */
%if SelectionEnabled='yes'
  if (screen->selectedW != NULL && screen->selectedW->selectedE!=NULL) {%>40/* if there is something selected, then deselect it */
    %'ModuleName'%.%DeselectElement(screen, screen->selectedW, screen->selectedW->selectedE);
  }
  screen->selectedW = window;                                    %>40/* as the window is modal, it is the only one selected */
%endif
  return ERR_OK;
}

%endif %- CreateDialogWindow
%-BW_METHOD_END CreateDialogWindow
%-************************************************************************************************************
%-BW_METHOD_BEGIN CloseDialogWindow
%ifdef CloseDialogWindow
%define! Parscreen
%define! Parwindow
%define! RetVal
%include Common\UserInterfaceCloseDialogWindow.Inc
byte %'ModuleName'%.%CloseDialogWindow(%'ModuleName'_Screen *screen, %'ModuleName'_Window *window)
{
  (void)%'ModuleName'%.%RemoveWindow(screen, window);
  screen->selectedW = NULL;
  %'ModuleName'%.%UpdateScreen(screen);
  return ERR_OK;
}

%endif %- CloseDialogWindow
%-BW_METHOD_END CloseDialogWindow
%-************************************************************************************************************
%-BW_METHOD_BEGIN RemoveWindow
%ifdef RemoveWindow
%define! Parscreen
%define! Parwindow
%define! RetVal
%include Common\UserInterfaceRemoveWindow.Inc
byte %'ModuleName'%.%RemoveWindow(%'ModuleName'_Screen *screen, %'ModuleName'_Window *window)
{
  %'ModuleName'_Window *w;
  %'ModuleName'_Window **pw;                                     %>40/* pointer to previous window */

  screen->updateAll = TRUE;                                      %>40/* will need to update all elements of the screen */
  if (screen->selectedW == window) {
    screen->selectedW = NULL;                                    %>40/* remove pointer to selected window */
  }
  w = screen->first;
  pw = &screen->first;
  while(w != NULL) {
    if (w == window) {
      *pw = w->next;                                             %>40/* unlink window */
%if SelectionEnabled='yes'
    } else if (w->selectedE != NULL) {                           %>40/* we do have a window with a selection: update screen */
      screen->selectedW = w;
%endif
    }
    pw = &w->next;
    w = w->next;
  }
  return ERR_OK;                                                 %>40/* window not found? */
}

%endif %- RemoveWindow
%-BW_METHOD_END RemoveWindow
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG UpdateElementNoRefresh
%define! Parwindow
%define! Parelement
%define! ParupdateAll
%include Common\GeneralInternalGlobal.inc (UpdateElementNoRefresh)
static void UpdateElementNoRefresh(%'ModuleName'_Window *window, %'ModuleName'_Element *element, byte updateAll)
{
  if (element->prop.flags&%'ModuleName'_FLAGS_IS_SUBWINDOW) {
     %'ModuleName'_SubWindow *subW = (%'ModuleName'_SubWindow*)element;

     subW->subWindow.updateAll = updateAll;
%ifdef _OPTIMIZE_CLEARED_BACKGROUND
     if (   window->flags&%'ModuleName'_FLAGS_WINDOW_BG_CLEARED
         && window->prop.color == subW->subWindow.bgColor
        )
     {                                                           %>40/* propagage clear flag */
       subW->subWindow.flags |= %'ModuleName'_FLAGS_WINDOW_BG_CLEARED;
     }
%endif
     %'ModuleName'%.%UpdateWindow(&subW->subWindow);
  } else if (updateAll || (element->prop.flags&%'ModuleName'_FLAGS_NEEDS_REPAINT)) {
    if (element->painter == NULL) {
      /* call user callback */
      if (window->eventCallback != NULL) {
        window->eventCallback(window, element, %'ModuleName'_EVENT_PAINT, NULL);
      }
    } else {
      (void)(*element->painter)(window, element);
    }
    element->prop.flags &= ~%'ModuleName'_FLAGS_NEEDS_REPAINT;
  }
}

%-INTERNAL_METHOD_END UpdateElementNoRefresh
%-************************************************************************************************************
%-BW_METHOD_BEGIN WindowSetBorder
%ifdef WindowSetBorder
%define! Parwindow
%include Common\UserInterfaceWindowSetBorder.Inc
#if 0
void %'ModuleName'%.%WindowSetBorder(%'ModuleName'_Window *window)
{
  /* method implemented as macro in the header file */
}
#endif

%endif %- WindowSetBorder
%-BW_METHOD_END WindowSetBorder
%-************************************************************************************************************
%-BW_METHOD_BEGIN HeaderSetLine
%ifdef HeaderSetLine
%define! Parheader
%define! RetVal
%include Common\UserInterfaceHeaderSetLine.Inc
#if 0
byte %'ModuleName'%.%HeaderSetLine(%'ModuleName'_Header *header)
{
  /* Implemented as macro in the header file */
}
#endif

%endif %- HeaderSetLine
%-BW_METHOD_END HeaderSetLine
%-************************************************************************************************************
%-BW_METHOD_BEGIN RefreshDialogWindow
%ifdef RefreshDialogWindow
%define! Parwindow
%include Common\UserInterfaceRefreshDialogWindow.Inc
void %'ModuleName'%.%RefreshDialogWindow(%'ModuleName'_Window *window)
{
  %'ModuleName'%.%UpdateWindow(window);
  %@Display@'ModuleName'%.UpdateRegion(window->prop.x, window->prop.y, window->prop.width, window->prop.height);
}

%endif %- RefreshDialogWindow
%-BW_METHOD_END RefreshDialogWindow
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawBox
%ifdef DrawBox
%define! Parwindow
%define! Parx
%define! Pary
%define! Parw
%define! Parh
%define! ParlineWidth
%define! Parcolor
%include Common\UserInterfaceDrawBox.Inc
void %'ModuleName'%.%DrawBox(%'ModuleName'_Window *window, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim w, %'ModuleName'_PixelDim h, %'ModuleName'_PixelDim lineWidth, %'ModuleName'_PixelColor color)
{
%ifdef _OPTIMIZE_CLEARED_BACKGROUND
  if ((window->flags&%'ModuleName'_FLAGS_WINDOW_BG_CLEARED) && color==window->prop.color) {
    /* nothing to do, as window background just has been cleared with our color */
  } else {
    %@Display@'ModuleName'%.DrawBox((%'ModuleName'_PixelDim)(window->prop.x+x), (%'ModuleName'_PixelDim)(window->prop.y+y), w, h, lineWidth, color);
  }
%else
  %@Display@'ModuleName'%.DrawBox((%'ModuleName'_PixelDim)(window->prop.x+x), (%'ModuleName'_PixelDim)(window->prop.y+y), w, h, lineWidth, color);
%endif
}

%endif %- DrawBox
%-BW_METHOD_END DrawBox
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawLine
%ifdef DrawLine
%define! Parwindow
%define! Parx0
%define! Pary0
%define! Parx1
%define! Pary1
%define! Parcolor
%include Common\UserInterfaceDrawLine.Inc
void %'ModuleName'%.%DrawLine(%'ModuleName'_Window *window, %'ModuleName'_PixelDim x0, %'ModuleName'_PixelDim y0, %'ModuleName'_PixelDim x1, %'ModuleName'_PixelDim y1, %'ModuleName'_PixelColor color)
{
  %@Display@'ModuleName'%.DrawLine(
   (%'ModuleName'_PixelDim)(window->prop.x+x0),
   (%'ModuleName'_PixelDim)(window->prop.y+y0),
   (%'ModuleName'_PixelDim)(window->prop.x+x1),
   (%'ModuleName'_PixelDim)(window->prop.y+y1),
   color);
}

%endif %- DrawLine
%-BW_METHOD_END DrawLine
%-************************************************************************************************************
%-BW_METHOD_BEGIN ChangeElementColor
%ifdef ChangeElementColor
%define! Parelem
%define! Parcolor
%include Common\UserInterfaceChangeElementColor.Inc
#if 0
void %'ModuleName'%.%ChangeElementColor(%'ModuleName'_Element *elem, %'ModuleName'_PixelColor color)
{
  /* Method is implemented as macro in the header file "%'ModuleName'.h"  */
}
#endif

%endif %- ChangeElementColor
%-BW_METHOD_END ChangeElementColor
%-************************************************************************************************************
%-BW_METHOD_BEGIN CreateSpace
%ifdef CreateSpace
%define! Parwindow
%define! Parspace
%define! Parx
%define! Pary
%define! Parwidth
%define! Parheight
%define! RetVal
%include Common\UserInterfaceCreateSpace.Inc
byte %'ModuleName'%.%CreateSpace(%'ModuleName'_Window *window, %'ModuleName'_Space *space, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim width, %'ModuleName'_PixelDim height)
{
  if (window == NULL || space == NULL) {
    return ERR_FAILED;
  }
  %'ModuleName'%.ElementInitCommon((%'ModuleName'%.Element*)space, %'ModuleName'%.SPACE,
    x, y, width, height,
    window->prop.color, NULL);
  if (%'ModuleName'%.WindowAddElement(window, (%'ModuleName'%.Element *)space) != ERR_OK) {
    return ERR_FAILED;
  }
  return ERR_OK;
}

%endif %- CreateSpace
%-BW_METHOD_END CreateSpace
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetScreen
%ifdef GetScreen
%define! RetVal
%include Common\UserInterfaceGetScreen.Inc
%'ModuleName'_PScreen %'ModuleName'%.%GetScreen(void)
{
  return currentScreen;
}

%endif %- GetScreen
%-BW_METHOD_END GetScreen
%-************************************************************************************************************
%-BW_METHOD_BEGIN EqualElement
%ifdef EqualElement
%define! Parelem1
%define! Parelem2
%define! RetVal
%include Common\UserInterfaceEqualElement.Inc
#if 0
bool %'ModuleName'%.%EqualElement(%'ModuleName'_Element *elem1, %'ModuleName'_Element *elem2)
{
  /* method is implemented as macro in '%'ModuleName'.h' */
}
#endif

%endif %- EqualElement
%-BW_METHOD_END EqualElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetSelectedElement
%ifdef GetSelectedElement
%define! Parscreen
%define! ParpWindow
%define! ParpElement
%define! RetVal
%include Common\UserInterfaceGetSelectedElement.Inc
bool %'ModuleName'%.%GetSelectedElement(%'ModuleName'_Screen *screen, %'ModuleName'_PWindow *pWindow, %'ModuleName'_PElement *pElement)
{
  *pWindow = NULL;
  *pElement = NULL;
  if (screen!=NULL && screen->selectedW!=NULL) {
    *pWindow = screen->selectedW;
    *pElement = (*pWindow)->selectedE;
    while (*pWindow != NULL && *pElement != NULL && ((*pElement)->prop.flags&%'ModuleName'_FLAGS_IS_SUBWINDOW)) {
      *pWindow = &(((%'ModuleName'_SubWindow*)*pElement)->subWindow);
      *pElement = (*pWindow)->selectedE;
    } /* while */
  }
  return (bool)((*pElement)!=NULL);
}

%endif %- GetSelectedElement
%-BW_METHOD_END GetSelectedElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN FindElement
%ifdef FindElement
%define! Parscreen
%define! ParpWindow
%define! ParpElement
%define! Parcompare
%define! Pardata
%define! RetVal
%include Common\UserInterfaceFindElement.Inc
bool %'ModuleName'%.%FindElement(%'ModuleName'_Screen *screen, %'ModuleName'_PWindow *pWindow, %'ModuleName'_PElement *pElement, %'ModuleName'_ElementFindFct compare, %'ModuleName'_Pvoid data)
{
  %'ModuleName'%.Window *window;
  %'ModuleName'%.Element *element, *startElement;

  *pWindow = NULL;
  *pElement = NULL;
  if (screen != NULL) {
    if (screen->selectedW != NULL && (screen->selectedW->flags&%'ModuleName'_FLAGS_WINDOW_IS_MODAL)) {%>40/* modal window */
      window = screen->selectedW;                                %>40/* limit search to current modal window */
    } else {
      window = screen->first;
    }
    element = window->first;
    startElement = element;
    for(;;) {                                                    %>40/* will break */
      NextElement(screen, &window, &element);                    %>40/* select previous element, we will go forward */
      if (element==startElement) {                               %>40/* wrap over */
        break;                                                   %>40/* no element found */
      }
      if (element==NULL && window->parentE!=NULL) {              %>40/* we are in a subwindow: go up in chain */
        continue;
      }
      if (element==NULL || window==NULL) {                       %>40/* no element at all? */
        break;
      }
      if (compare(screen, window, element, data)) {
        *pWindow = window;
        *pElement = element;
        return TRUE;                                             %>40/* done, return element found */
      }
    } /* for */
  } /* if */
  return FALSE;                                                  %>40/* no element touched */
}

%endif %- FindElement
%-BW_METHOD_END FindElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetDisplayOrientation
%ifdef GetDisplayOrientation
%define! RetVal
%include Common\UserInterfaceGetDisplayOrientation.Inc
/*
%'ModuleName'_DisplayOrientation %'ModuleName'%.%GetDisplayOrientation(void)
  ** This method is implemented as macro
*/

%endif %- GetDisplayOrientation
%-BW_METHOD_END GetDisplayOrientation
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetWidth
%ifdef GetWidth
%define! RetVal
%include Common\UserInterfaceGetWidth.Inc
/*
%'ModuleName'_PixelDim %'ModuleName'%.%GetWidth(void)
  ** This method is implemented as macro
*/

%endif %- GetWidth
%-BW_METHOD_END GetWidth
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetHeight
%ifdef GetHeight
%define! RetVal
%include Common\UserInterfaceGetHeight.Inc
/*
%'ModuleName'_PixelDim %'ModuleName'%.%GetHeight(void)
  ** This method is implemented as macro
*/

%endif %- GetHeight
%-BW_METHOD_END GetHeight
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetDisplayOrientation
%ifdef SetDisplayOrientation
%define! ParnewOrientation
%include Common\UserInterfaceSetDisplayOrientation.Inc
void %'ModuleName'%.%SetDisplayOrientation(%'ModuleName'_DisplayOrientation newOrientation)
{
  %'ModuleName'%.Screen *screen;
  %'ModuleName'%.Window *window;
  %'ModuleName'_DisplayOrientation currOrientation = %'ModuleName'%.%GetDisplayOrientation();

  /* inform UI about change */
  screen = %'ModuleName'%.%GetScreen();
  if (screen==NULL) {
    return;                                                      %>40/* no screen? something is wrong? */
  }
  /* adopt UI elements for new orientation */
  if (newOrientation == currOrientation) {
    return; /* nothing to do */
  }
  if (  (   (currOrientation==%'ModuleName'%.ORIENTATION_PORTRAIT || currOrientation==%'ModuleName'%.ORIENTATION_PORTRAIT180)
         && (newOrientation==%'ModuleName'%.ORIENTATION_LANDSCAPE || newOrientation==%'ModuleName'%.ORIENTATION_LANDSCAPE180)
        )
      ||
        (   (newOrientation==%'ModuleName'%.ORIENTATION_PORTRAIT || newOrientation==%'ModuleName'%.ORIENTATION_PORTRAIT180)
         && (currOrientation==%'ModuleName'%.ORIENTATION_LANDSCAPE || currOrientation==%'ModuleName'%.ORIENTATION_LANDSCAPE180)
        )
     ) /* changing from landscape to portrait or vice versa: adopt UI coordinates */
  {
    window = screen->first;
    while(window != NULL) {
      if (   window->prop.x==0 && window->prop.y==0
          && window->prop.width == %'ModuleName'%.GetWidth()
          && window->prop.height == %'ModuleName'%.GetHeight()
         )
      { /* full screen window: swap width/height */
        window->prop.width = %'ModuleName'%.GetHeight();
        window->prop.height = %'ModuleName'%.GetWidth();
        %'ModuleName'%.OnWindowResize(window);
      }
      window = window->next;
    } /* while */
  } /* if */
  /* Calling inherited method */
%ifdef OnEvent
  %OnEvent(screen, NULL, NULL, %'ModuleName'_EVENT_PRE_ORIENTATION_CHANGE);%>40/* call user event */
%endif
  %@Display@'ModuleName'%.SetDisplayOrientation(newOrientation);
%ifdef OnEvent
  %OnEvent(screen, NULL, NULL, %'ModuleName'_EVENT_ORIENTATION_CHANGE);%>40/* call user event */
%endif
  screen->updateAll = TRUE;                                      %>40/* update whole screen */
  %'ModuleName'%.%UpdateScreen(screen);
%ifdef OnEvent
  %OnEvent(screen, NULL, NULL, %'ModuleName'_EVENT_POST_ORIENTATION_CHANGE);%>40/* call user event */
%endif
}

%endif %- SetDisplayOrientation
%-BW_METHOD_END SetDisplayOrientation
%-************************************************************************************************************
%-BW_METHOD_BEGIN OnWindowResize
%ifdef OnWindowResize
%define! Parwindow
%include Common\UserInterfaceOnWindowResize.Inc
void %'ModuleName'%.%OnWindowResize(%'ModuleName'_Window *window)
{
  %'ModuleName'_Element *element;

  while(window!=NULL) {
    element = window->first;
    while(element != NULL) {
      if (element->prop.type==%'ModuleName'_ICON) {
        if (element->prop.flags&%'ModuleName'_FLAGS_ALIGN_RIGHT) {
          element->prop.x = (%'ModuleName'_PixelDim)(window->prop.width
              - ((%'ModuleName'_Icon *)element)->rightOffset
              - element->prop.width);
        }
      } else if (element->prop.type==%'ModuleName'_HEADER) {
        if (window->flags&%'ModuleName'_FLAGS_WINDOW_HAS_BORDER) {
          element->prop.width = (%'ModuleName'_PixelDim)(window->prop.width-2);
        } else {
          element->prop.width = window->prop.width;
        }
      }
      element = element->next;
    } /* while */
    window = window->next;
  } /* while */
}

%endif %- OnWindowResize
%-BW_METHOD_END OnWindowResize
%-************************************************************************************************************
%-BW_METHOD_BEGIN RemoveWindowPaintBackground
%ifdef RemoveWindowPaintBackground
%define! Parscreen
%define! Parwindow
%include Common\UserInterfaceRemoveWindowPaintBackground.Inc
void %'ModuleName'%.%RemoveWindowPaintBackground(%'ModuleName'_Screen *screen, %'ModuleName'_Window *window)
{
  /* paint window area in screen background color, assuming no overlapping windows */
  %@Display@'ModuleName'%.DrawFilledBox(window->prop.x, window->prop.y, window->prop.width, window->prop.height, screen->bgColor);
  /* now remove the window from the data structure */
  %'ModuleName'%.%RemoveWindow(screen, window);
  /* the above call has marked our display content for refresh: no need as we have done this above with the background color */
  screen->updateAll = FALSE;
}

%endif %- RemoveWindowPaintBackground
%-BW_METHOD_END RemoveWindowPaintBackground
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_METHOD_BEGIN OnEvent
%ifdef OnEvent
%IMPLEMENTATION OnEvent
%define! Parscreen
%define! Parwindow
%define! Parelement
%define! Parevent
%include Common\UserInterfaceOnEvent.Inc
void %OnEvent(%'ModuleName'_Screen *screen, %'ModuleName'_Window *window, %'ModuleName'_Element *element, %'ModuleName'_EventCallbackKind event)
{
  /* Write your code here ... */
}

%endif %- OnEvent
%-BW_METHOD_END OnEvent
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This bean is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
