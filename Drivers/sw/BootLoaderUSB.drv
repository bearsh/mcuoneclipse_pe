%-Driver generated by the Component Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Component Wizard
%- If you change these lines, Component Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    19.03.2011
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\BootLoaderUSBSettings.Inc
%define! Abstract Common\BootLoaderUSBAbstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited beans */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-
%-BW_CUSTOM_USERTYPE_END


%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN PollAndProcessUSB
%ifdef PollAndProcessUSB
void %'ModuleName'%.%PollAndProcessUSB(%@S19@'ModuleName'%.FileStatus *fileStatus);
%define! ParfileStatus
%include Common\BootLoaderUSBPollAndProcessUSB.Inc

%endif %- PollAndProcessUSB
%-BW_METHOD_END PollAndProcessUSB
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadAndProcessS19
%ifdef ReadAndProcessS19
void %'ModuleName'%.%ReadAndProcessS19(%@S19@'ModuleName'%.FileStatus *fileStatus);
%define! ParfileStatus
%include Common\BootLoaderUSBReadAndProcessS19.Inc

%endif %- ReadAndProcessS19
%-BW_METHOD_END ReadAndProcessS19
%-************************************************************************************************************
%-BW_METHOD_BEGIN InitUSB
%ifdef InitUSB
void %'ModuleName'%.%InitUSB(void);
%include Common\BootLoaderUSBInitUSB.Inc

%endif %- InitUSB
%-BW_METHOD_END InitUSB
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\BootLoaderUSBSettings.Inc
%define! Abstract Common\BootLoaderUSBAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M
/* USB command */
#define mGET_STATUS           0
#define mCLR_FEATURE          1
#define mSET_FEATURE          3
#define mSET_ADDR             5
#define mGET_DESC             6
#define mSET_DESC             7
#define mGET_CONFIG           8
#define mSET_CFG              9
#define mGET_INTF             10
#define mSET_INTF             11
#define mSYNC_FRAME           12
#define mGET_MAXLUN           0xFE    /* Mass Storage command */

/* Descriptor Types */
#define mDESC_DEV     0x01
#define mDESC_CFG     0x02
#define mDESC_STR     0x03

/* Endpoint0 Token define */
#define mEP0_OUT      0x00
#define mEP0_IN       0x08
#define mEP1_IN       0x18
#define mEP2_OUT      0x20
#define mSETUP_TOKEN  0b00001101

#define mMCU      0x00
#define mUDATA0   0x88
#define mUDATA1   0xC8

#define mEP0_BUFF_SIZE  64
#define cEP1_BUFF_SIZE  64
#define cEP2_BUFF_SIZE  64

#define STALL_EP2     (ENDPT2 |= ENDPT2_EP_STALL_MASK)

/* USB state machine */
enum _USB_States {
  cDETACH,
  cATTACH,
  cPOWER,
  cDEFAULT,
  cADR_PENDING,
  cADDRESS,
  cCONFIGURE,
  cSUSPEND
};

/* Control transfer state machine */
enum _USBCTL_States {
  cCBW,
  cCSW,
  cEP1Tx,
  cEP2Rx,
  mICP_WAIT,
  mICP_TX,
  mICP_RX
};

typedef union _tBDT_STAT {
  byte _byte;
  struct{
    byte  :2;       /* bit 0-1 reserved */
    byte BSTALL:1;  /* BDT stall */
    byte DTS:1;     /* Data Toggle Synch Enable */
    byte NINC:1;    /* Address Increment Disable */
    byte KEEP:1;    /* BD Keep Enable */
    byte DATA:1;    /* Data Toggle Synch Value */
    byte UOWN:1;    /* USB Ownership */
  } CtlBit;
  struct{
    byte    :2;
    byte PID:4;     /* Packet Identifier */
    byte    :2;
  } RecPid;
} tBDT_STAT;        /* Buffer Descriptor Status Register */

typedef struct _tBDT  {
  tBDT_STAT BDT_Stat;
  byte      Rev;
  byte      Cnt;
  byte      Rev2;
  byte      Addr0;
  byte      Addr1;
  byte      Addr2;
  byte      Addr3;
} tBDT;

typedef struct _tUSB_Setup {
  byte bmRequestType;
  byte bRequest;
  byte wValue_l;
  byte wValue_h;
  byte wIndex_l;
  byte wIndex_h;
  byte wLength_l;
  byte wLength_h;
} tUSB_Setup;

typedef struct _tICPSTR {
  byte Byte;
  struct {
    byte AddrPend     :1;
    byte none         :1;
    byte Prog         :1;
    byte Verify       :1;
    byte none2        :1;
    byte none3        :1;
    byte none4        :1;
    byte none5        :1;
  } Bits;
} tICPSTR;

/***********************************************
**    USB Command Block Wrapper CBW Command
************************************************/
#define kCBWSignature0      0     /* dCBWSignature byte 0 position */
#define kCBWSignature1      1     /* dCBWSignature byte 1 position */
#define kCBWSignature2      2     /* dCBWSignature byte 2 position */
#define kCBWSignature3      3     /* dCBWSignature byte 3 position */
#define kCBWTag0            4     /* dgUSBMSCBWTage byte 0 position */
#define kCBWTag1            5     /* dgUSBMSCBWTage byte 0 position */
#define kCBWTag2            6     /* dgUSBMSCBWTage byte 0 position */
#define kCBWTag3            7     /* dgUSBMSCBWTage byte 0 position */
#define kCBWXferLength0     8     /* dCBWDataTransferLength byte 0 position */
#define kCBWXferLength1     9     /* dCBWDataTransferLength byte 1 position */
#define kCBWXferLength2     10    /* dCBWDataTransferLength byte 2 position */
#define kCBWXferLength3     11    /* dCBWDataTransferLength byte 3 position */
#define kCBWFlags           12    /* bmCBWFlags byte position */
#define kCBWDirection       0x80  /* direction */
#define kHost2Device        0     /* 0-host to device, 1-device to host */
#define kCBWLUN             13    /* bCBWLUN byte position */
#define kCBWCBLength        14    /* bCBWCBLength byte position */
#define kCBWSCSICommand     15    /* CBWCB byte position */

#define kSCSI10LBAByte3     17    /* LBA byte 3 */
#define kSCSI10LBAByte2     18    /* LBA byte 2 */
#define kSCSI10LBAByte1     19    /* LBA byte 1 */
#define kSCSI10LBAByte0     20    /* LBA byte 0 */
#define kSCSI10XferLength1  22    /* Transfer Length byte 1 */
#define kSCSI10XferLength0  23    /* Transfer Length byte 0 */

#define kSCSI1EPrevent      19    /* Prevent byte in 1E command */

#define kCSWPass            0     /* command completed successfully */
#define kCSWFailed          1     /* command failed */

#define SCSICapacitySize    8
#define SCSICapacityFormatSize  20
/************************************************************************************
* Private memory declarations
************************************************************************************/
static byte  vCBW_Buf[31];       /* CBW command buffer */
static byte  vUSBCBWTag[4];      /* CBW tag */
static byte  vIdx;               /* Local index */
static byte  v_Bnum;             /* Block number */
static dword v_LBA;              /* BLock address */
static dword v_END_LBA;          /* BLock address */
static byte  MultiLBAToken;

static bool  SCSI_BlockWriteDone;
static byte  SCSI_vCSWResult;    /* CSW result */
/*------------------------------------------------- */
static tICPSTR _ICP_VAR;
#define ICP_VAR               _ICP_VAR.Byte
#define ICP_AddrPend          _ICP_VAR.Bits.AddrPend

/* USB Buffer Descriptor Tables and buffers */
/* RAM locations for USB Buffers:
   you need to have this area reserved in the .lcf/CPU configuration */
#define USB_BUFFER_START        0x%#l%USBBufferStart /* USB RAM buffer as defined by the user in the component properties */
#define MSD_BUFFER_SIZE         512
#define USB_BDT_START           (USB_BUFFER_START + 2*MSD_BUFFER_SIZE)
#define BDT_SIZE                16
#define ICP_BUFFER_SIZE         64

static volatile byte EP1Tx_Data[MSD_BUFFER_SIZE]        @USB_BUFFER_START;
static volatile byte EP2Rx_Data[MSD_BUFFER_SIZE]        @(USB_BUFFER_START + MSD_BUFFER_SIZE);
static volatile tBDT EP0Rx[2]  @(USB_BUFFER_START + 2*MSD_BUFFER_SIZE);
static volatile tBDT EP0Tx[2]  @(USB_BUFFER_START + 2*MSD_BUFFER_SIZE + BDT_SIZE);
static volatile tBDT DummyBDT  @(USB_BUFFER_START + 2*MSD_BUFFER_SIZE + 2*BDT_SIZE);
static volatile tBDT EP1Tx[2]  @(USB_BUFFER_START + 2*MSD_BUFFER_SIZE + 3*BDT_SIZE);
static volatile tBDT EP2Rx[2]  @(USB_BUFFER_START + 2*MSD_BUFFER_SIZE + 4*BDT_SIZE);
static volatile tUSB_Setup Setup_Pkt  @(USB_BUFFER_START + 2*MSD_BUFFER_SIZE + 5*BDT_SIZE);

static volatile byte ICP_OUT_Data[ICP_BUFFER_SIZE]       @(USB_BUFFER_START + 2*MSD_BUFFER_SIZE + 6*BDT_SIZE);
static volatile byte ICP_IN_Data[ICP_BUFFER_SIZE]        @(USB_BUFFER_START + 2*MSD_BUFFER_SIZE + 6*BDT_SIZE + ICP_BUFFER_SIZE);

/* Variables used with USB buffers and USB controller */
static byte *pEP0IN_Data;
static byte vEP0IN_DataCnt;
static word vEP1Idx;
static word vEP2Idx;
static byte vEP1Data[MSD_BUFFER_SIZE];
static byte vEP2Data[MSD_BUFFER_SIZE];

#define USB_BufferAddress vEP2Data
#define USB_BufferSize    MSD_BUFFER_SIZE
#define USB_BufferEnd     (USB_BufferAddress + USB_BufferSize)

static word vEP1_Cnt;
static byte vEP0RxData;   /* data0/1 toggle */
static byte vEP0TxData;   /* data0/1 toggle */
static byte vEP1TxData;   /* data0/1 toggle */
static byte vEP2RxData;   /* data0/1 toggle */
static byte vEP0RxBuf;    /* odd buf and even buf */
static byte vEP0TxBuf;
static byte vEP1TxBuf;    /* odd buf and even buf */
static byte vEP2RxBuf;    /* odd buf and even buf */

/* USB Stack Variables */
static byte ICP_USB_State;
static byte vCBWBuf_flag;

/* ReEnumeration Status */
#define SCSI_ENUMERATE_NO    0
#define SCSI_ENUMERATE_YES   1
#define SCSI_ENUMERATE_DONE  2

static unsigned char SCSI_ReEnumerateNow = SCSI_ENUMERATE_NO;
/********************************************************************
*       ICP Device Descriptor
********************************************************************/
static const byte Device_Descriptor[18]=  {
  0x12,         //blength
  0x01,         //bDescriptor
  0x00,0x02,    //bcdUSB ver R=2.00
  0x00,         //bDeviceClass
  0x00,         //bDeviceSubClass
  0x00,         //bDeviceProtocol
  0x40,         //bMaxPacketSize0
  0xA2,0x15,    //idVendor - 0x15A2(freescale Vendor ID)
  0x3F,0x00,    //idProduct - 0x003F
  0x00,0x01,    //bcdDevice - Version 1.00
  0x01,         //iManufacturer - Index to string descriptor
  0x02,         //iProduct - Index to string descriptor
  0x00,         //iSerialNumber - Index to string descriptor
  0x01          //bNumConfigurations - # of config. at current speed,
};

/********************************************************************
*       ICP Configuration Descriptor
********************************************************************/
static const byte Configuration_Descriptor[32] = {
  0x09,         //blength
  0x02,         //bDescriptor
  0x20,0x00,    //wTotalLength - # of bytes including interface and endpoint descpt.
  0x01,         //bNumInterfaces - at least 1 data interface
  0x01,         //bConfigurationValue -
  0x00,         //iConfiguration - index to string descriptor
  0x80,         //bmAttributes - 0x?0 bit 7-bus powered
                //                    bit 6-self powered
                //                    bit 5-remote wakeup
                //                    bit 4-0-reserved
  0x64,         //bMaxPower - 200mA
// ======================================================
//    Standard Interface Descriptor
// ======================================================
  0x09,         //blength
  0x04,         //bDescriptorType - Interface descriptor
  0x00,         //bInterfaceNumber - Zero based value identifying the index of the config.
  0x00,         //bAlternateSetting;
  0x02,         //bNumEndpoints - 2 endpoints
  0x08,         //bInterfaceClass - mass storage
  0x06,         //bInterfaceSubClass - SCSI Transparent command Set
  0x50,         //bInterfaceProtocol - Bulk-Only transport
  0x00,         //iInterface - Index to String descriptor
// ======================================================
//    Standard Endpoint Descriptor
//      Bulk IN Endpoint
// ======================================================
  0x07,         //bLength;
  0x05,         //bDescriptorType - Endpoint descriptor
  0x81,         //bEndpointAddress - bit 3..0 endpoint number
                //                   bit 6..4 Reserved reset to zero
                //                   bit 7  0-OUT, 1-IN
  0x02,         //bmAttributes _ Bulk endpoint
  0x40,0x00,    //wMaxPacketSize - 64 byte packet size
  0x00,         //bInterval - do not apply to BULK endpoint
// ======================================================
//    Standard Endpoint Descriptor
//      Bulk OUT Endpoint
// ======================================================
  0x07,         //bLength;
  0x05,         //bDescriptorType - Endpoint descriptor
  0x02,         //bEndpointAddress - bit 3..0 endpoint number
                //                   bit 6..4 Reserved reset to zero
                //                   bit 7  0-OUT, 1-IN
  0x02,         //bmAttributes _ Bulk endpoint
  0x40,0x00,    //wMaxPacketSize - 64 byte packet size
  0x00,         //bInterval - do not apply to BULK endpoint
};

// ======================================================
//    String Descriptor Zero
// ======================================================
static const byte String_Descriptor0[4] = {
  0x04,         //bLength;
  0x03,         //bDescriptorType - STRING descriptor
  0x09,0x04,    //wLANDID0 - English (American)
};

// ======================================================
//    String Descriptor one
// ======================================================
static const byte String_Descriptor1[] = {
  0x14,         //bLength; 11 bytes
  0x03,         //bDescriptorType - STRING descriptor
  'F',0x00,     // "F"
  'r',0x00,     // "r"
  'e',0x00,     // "e"
  'e',0x00,     // "e"
  's',0x00,     // "s"
  'c',0x00,     // "c"
  'a',0x00,     // "a"
  'l',0x00,     // "l"
  'e',0x00,     // "e"
};

// ======================================================
//    String Descriptor two
// ======================================================
static const byte String_Descriptor2[] = {
  0x0C,         //bLength;
  0x03,         //bDescriptorType - STRING descriptor
  'J',0x00,     // JM128
  'M',0x00,
  '1',0x00,
  '2',0x00,
  '8',0x00,
};

/************************************************************************************
*                                    Functions                                 *
************************************************************************************/
static void EP1_Load(void);
static void SCSI_PollUSB(void);

/********************************************************************
*       Capacity Info
********************************************************************/
static const byte SCSI_ReadCapacity[SCSICapacitySize]=
{
  0x00, /* Last Logical Block0 */
  0x1E, /* Last Logical Block1 */
  0x45, /* Last Logical Block2 */
  0xFF, /* Last Logical Block3 */
  0x00, /* Bytes per Sector0 */
  0x00, /* Bytes per Sector1 */
  0x02, /* Bytes per Sector2 */
  0x00  /* Bytes per Sector3 */
};

/********************************************************************
*       Format Capacity Info
********************************************************************/
static const byte SCSI_ReadFormatCapacity[SCSICapacityFormatSize]=
{
  0x00, /* Reserved */
  0x00, /* Reserved */
  0x00, /* Reserved */
  0x10, /* Capacity List Length */
  0x00, /* Number of Blocks0 */
  0x1E, /* Number of Blocks1 */
  0x46, /* Number of Blocks2 */
  0x00, /* Number of Blocks3 */
  0x02, /* Formatted Media */
  0x00, /* Bytes per Sector0 */
  0x02, /* Bytes per Sector1 */
  0x00, /* Bytes per Sector2 */
  0x00, /* Number of Blocks0 */
  0x1E, /* Number of Blocks1 */
  0x46, /* Number of Blocks2 */
  0x00, /* Number of Blocks3 */
  0x00, /* Reserved */
  0x00, /* Bytes per Sector0 */
  0x02, /* Bytes per Sector1 */
  0x00, /* Bytes per Sector2 */
};

/*********************************************************
* Name: SCSI_GetUSBOutFileData
* Desc: Waits for USB to read file data to write
* Parameter: None
* Return: None
**********************************************************/
static void SCSI_GetUSBOutFileData(void) {
  vEP2Idx =0;

  if(v_LBA == v_END_LBA) {
    SCSI_BlockWriteDone = TRUE;
  } else {
    v_LBA++;
    while(vEP2Idx !=512) {
      SCSI_PollUSB();
    }
  }
}

/*********************************************************
* Name: SCSI_Send_CSW
* Desc: Send CSW back to Host
* Parameter: None
* Return: None
**********************************************************/
static void SCSI_Send_CSW(void) {
  SCSI_vCSWResult = kCSWPass;

  vEP1Data[0] = 0x55;          /* 00 byte0-3 Signature 0x55 0x53 0x42 0x52 */
  vEP1Data[1] = 0x53;                      /* 01 */
  vEP1Data[2] = 0x42;          /* 02 */
  vEP1Data[3] = 0x53;          /* 03 */
  vEP1Data[4] = vUSBCBWTag[0]; /* 04 byte4-7 USB CBW Tag */
  vEP1Data[5] = vUSBCBWTag[1]; /* 05 */
  vEP1Data[6] = vUSBCBWTag[2]; /* 06 */
  vEP1Data[7] = vUSBCBWTag[3]; /* 07 */
  vEP1Data[8] = 0x00;          /* 08 byte8-11 USB byte residue */
  vEP1Data[9] = 0x00;          /* 09 */
  vEP1Data[10] = 0x00;         /* 10 */
  vEP1Data[11] = 0x00;         /* 11 */
  vEP1Data[12] = SCSI_vCSWResult; /* 12 Status */

  vEP1Idx =0;
  vEP1_Cnt = 13;
  EP1_Load();

  ICP_USB_State = mICP_WAIT;
}

/*********************************************************
* Name: SCSIList00
* Desc: SCSI command 0x00 (Test unit ready) handler
* Parameter: None
* Return: None
**********************************************************/
static void SCSIList00(void) {
  SCSI_vCSWResult = kCSWPass;
  SCSI_Send_CSW();
}

/*********************************************************
* Name: SCSIList03
* Desc: SCSI command 0x03 (Request Sense) handler
* Parameter: None
* Return: None
**********************************************************/
static void SCSIList03(void) {
  vIdx=0;

  vEP1Data[vIdx++] = 0x70;  /* 00 error code */
  vEP1Data[vIdx++] = 0x00;  /* 01 reserved */
  vEP1Data[vIdx++] = 0x05;  /* 02 sense key */
  vEP1Data[vIdx++] = 0x00;  /* 03 03-06 information */
  vEP1Data[vIdx++] = 0x00;  /* 04 */
  vEP1Data[vIdx++] = 0x00;  /* 05 */
  vEP1Data[vIdx++] = 0x00;  /* 06 */
  vEP1Data[vIdx++] = 0x0c;  /* 07 additional sense length */
  vEP1Data[vIdx++] = 0x00;  /* 08 08-11 command specific information */
  vEP1Data[vIdx++] = 0x00;  /* 09 */
  vEP1Data[vIdx++] = 0x00;  /* 10 */
  vEP1Data[vIdx++] = 0x00;  /* 11 */
  vEP1Data[vIdx++] = 0x24;  /* 12 additional sense code */
  vEP1Data[vIdx++] = 0x00;  /* 13 additional sense code qualifier */
  vEP1Data[vIdx++] = 0x00;  /* 14 file replaceable unit code */
  vEP1Data[vIdx++] = 0x00;  /* 15 15-17 sense key specific */
  vEP1Data[vIdx++] = 0x00;  /* 16 */
  vEP1Data[vIdx++] = 0x00;  /* 17 */

  SCSI_vCSWResult =kCSWPass;
  vEP1_Cnt = vIdx;
  EP1_Load();
  ICP_USB_State = cCSW;
}

/*********************************************************
* Name: SCSIList12
* Desc: SCSI command 0x12 (Inquiry) handler
* Parameter: None
* Return: None
**********************************************************/
static void SCSIList12(void) {
  vIdx=0;

  vEP1Data[0] = 0x00;  /* 00 device type */
  vEP1Data[1] = 0x80;  /* 01 removable */
  vEP1Data[2] = 0x00;  /* 02 SCSI 2 compatible */
  vEP1Data[3] = 0x02;  /* 03 data format */
  vEP1Data[4] = 0x1F;  /* 04 additional length=31 */
  vEP1Data[5] = 0x00;  /* 05 */
  vEP1Data[6] = 0x00;  /* 06 */
  vEP1Data[7] = 0x00;  /* 07 */
  vEP1Data[8] = 'F';
  vEP1Data[9] = 'S';
  vEP1Data[10] ='L';
  vEP1Data[11] =' ';
  vEP1Data[12] =' ';
  vEP1Data[13] ='U';
  vEP1Data[14] ='S';
  vEP1Data[15] ='B';
  vEP1Data[16] =' ';
  vEP1Data[17] ='B';
  vEP1Data[18] ='o';
  vEP1Data[19] ='o';
  vEP1Data[20] ='t';
  vEP1Data[21] ='l';
  vEP1Data[22] ='o';
  vEP1Data[23] ='a';
  vEP1Data[24] ='d';
  vEP1Data[25] ='e';
  vEP1Data[26] ='r';
  vEP1Data[27] =' ';
  vEP1Data[28] =' ';
  vEP1Data[29] =' ';
  vEP1Data[30] =' ';
  vEP1Data[31] =' ';
  vEP1Data[32] = 0x30;  /* 32 '0' */
  vEP1Data[33] = 0x30;  /* 33 '0' */
  vEP1Data[34] = 0x30;  /* 34 '0' */
  vEP1Data[35] = 0x31;  /* 35 '1' */

  SCSI_vCSWResult = kCSWPass;
  vEP1_Cnt = 36;
  EP1_Load();

  ICP_USB_State = cCSW;
}

/*********************************************************
* Name: SCSIList1A
* Desc: SCSI command 0x1A (Mode Sense) handler
* Parameter: None
* Return: None
**********************************************************/
static void SCSIList1A(void) {
  vEP1Data[0] = 0x03; /* page mode */
  vEP1Data[1] = 0x00;
  vEP1Data[2] = 0x00; /* unprotect, protect is 0x80 */
  vEP1Data[3] = 0x00;

  SCSI_vCSWResult = kCSWPass;
  vEP1_Cnt = 4;
  EP1_Load();
  ICP_USB_State = cCSW;
}

/*********************************************************
* Name: SCSIList23
* Desc: SCSI command 0x23 (Read Format Capacity) handler
* Parameter: None
* Return: None
**********************************************************/
static void SCSIList23(void) {
  byte i;

  /* Copy Read Format Capacity info to USB buffer */
  for(i=0;i<SCSICapacityFormatSize;i++) {
    vEP1Data[i] = SCSI_ReadFormatCapacity[i];
  }
  SCSI_vCSWResult = kCSWPass;
  vEP1_Cnt = SCSICapacityFormatSize;
  EP1_Load();
  ICP_USB_State = cCSW;
}

/*********************************************************
* Name: SCSIList25
* Desc: SCSI command 0x25 (Read Capacity) handler
* Parameter: None
* Return: None
**********************************************************/
static void SCSIList25(void)  {
  byte i;

  /* Copy Read Capacity info to USB buffer */
  for(i=0;i<SCSICapacitySize;i++) {
    vEP1Data[i] = SCSI_ReadCapacity[i];
  }
  SCSI_vCSWResult = kCSWPass;
  vEP1_Cnt = 8;
  EP1_Load();
  ICP_USB_State = cCSW;
}

/*********************************************************
* Name: SCSIList28
* Desc: SCSI command 0x28 (Read ) handler
* Parameter: None
* Return: None
**********************************************************/
static void SCSIList28(%@S19@'ModuleName'%.FileStatus *fileStatus) {
  byte i;

  v_LBA  = (dword)(vCBW_Buf[kSCSI10LBAByte3])<<24;
  v_LBA |= (dword)(vCBW_Buf[kSCSI10LBAByte2])<<16;
  v_LBA |= (dword)(vCBW_Buf[kSCSI10LBAByte1])<<8;
  v_LBA |= (dword)(vCBW_Buf[kSCSI10LBAByte0]);

  v_Bnum = vCBW_Buf[kSCSI10XferLength0];

  SCSI_vCSWResult = kCSWPass;
  MultiLBAToken = 0;

  for (i=0;i<v_Bnum;i++) {
    BLD1_ReadLBA(v_LBA, vEP1Data, fileStatus);
    ICP_USB_State = cEP1Tx;
    vEP1Idx =0;
    vEP1_Cnt=512;
    if(i == 0) { /* for first LBA, load buffer */
      EP1_Load();
    } else {
      while(MultiLBAToken) { /* wait for TOKDNEF to be processed */
        SCSI_PollUSB();
      }
    }
    while(vEP1_Cnt) {
      SCSI_PollUSB();  /* Check for interrupt flags */
    }
    MultiLBAToken = 1;
    v_LBA++;
  } /* for */
  ICP_USB_State = cCSW;
}

/*********************************************************
* Name: SCSIList2A
* Desc: SCSI command 0x2A (Write) handler
* Parameter: None
* Return: error code or ERR_OK
**********************************************************/
static void SCSIList2A(%@S19@'ModuleName'%.FileStatus *fileStatus) {
  v_LBA  = (dword)(vCBW_Buf[kSCSI10LBAByte3])<<24;
  v_LBA |= (dword)(vCBW_Buf[kSCSI10LBAByte2])<<16;
  v_LBA |= (dword)(vCBW_Buf[kSCSI10LBAByte1])<<8;
  v_LBA |= (dword)(vCBW_Buf[kSCSI10LBAByte0]);

  v_Bnum = vCBW_Buf[kSCSI10XferLength0];
  v_END_LBA = v_LBA + v_Bnum - 1;
  SCSI_BlockWriteDone = FALSE;

  while(vEP2Idx !=512) {
    SCSI_PollUSB();
  }
  if (*fileStatus == %@S19@'ModuleName'%.FILE_STATUS_NOT_STARTED) { /* not started reading file yet */
    while (!SCSI_BlockWriteDone) { /* Receive all USB data */
      if (    (v_LBA >= BLD1_FATDataSec0)
           && (*fileStatus == %@S19@'ModuleName'%.FILE_STATUS_NOT_STARTED)  /* Host writing first file to Data sector of drive */
           && vEP2Data[0]=='S'  /* Need to check as well for starting S record, otherwise we might get garbage here */
          )
      {
        *fileStatus = %@S19@'ModuleName'%.FILE_STATUS_READING; /* reset flag */
        return;
      } else { /* Host trying to write to FAT table */
        SCSI_GetUSBOutFileData();
      }
    }
    SCSI_vCSWResult = kCSWPass; /* Send Status transaction */
    SCSI_Send_CSW();
  }
}

/*********************************************************
* Name: SCSI_NotSupport
* Desc: Handle Not support SCSI command
* Parameter: None
* Return: None
**********************************************************/
static void SCSI_NotSupport(void) {
  byte count;

  SCSI_vCSWResult= kCSWFailed;
  count=(byte)(vCBW_Buf[kCBWXferLength0] | vCBW_Buf[kCBWXferLength1] | vCBW_Buf[kCBWXferLength2] | vCBW_Buf[kCBWXferLength3]);
  if (count) {
    if ((vCBW_Buf[kCBWFlags] & kCBWDirection) == kHost2Device) {
      STALL_EP2; /* STALL OUT endpoint */
      SCSI_Send_CSW();
    } else { /* device to host */
      vEP1_Cnt = 0;
      EP1_Load();
      ICP_USB_State = cCSW;
    }
  } else { /* zero data */
    SCSI_Send_CSW();
  }
}

/*********************************************************
* Name: SCSI_Process
* Desc: SCSI command handler
* Parameter: None
* Return: error code, or ERR_OK
**********************************************************/
static void SCSI_Process(%@S19@'ModuleName'%.FileStatus *fileStatus) {
  vUSBCBWTag[0]=vCBW_Buf[kCBWTag0];
  vUSBCBWTag[1]=vCBW_Buf[kCBWTag1];
  vUSBCBWTag[2]=vCBW_Buf[kCBWTag2];
  vUSBCBWTag[3]=vCBW_Buf[kCBWTag3];
  vEP1Idx =0;
  /* Check if write complete and should re-enumerate */
  if (SCSI_ReEnumerateNow != SCSI_ENUMERATE_DONE) {
    if ((*fileStatus != %@S19@'ModuleName'%.FILE_STATUS_NOT_STARTED) && (*fileStatus != %@S19@'ModuleName'%.FILE_STATUS_READING)){
      /* File was already written */
      if (vCBW_Buf[kCBWSCSICommand] != 0x2A) {
        /* SCSI Command received was not another write */
        SCSI_ReEnumerateNow = SCSI_ENUMERATE_YES;
      }
    }
  }
  switch(vCBW_Buf[kCBWSCSICommand]) {
    case 0x00:
      SCSIList00();
      break;
    case 0x03:
      SCSIList03();
      break;
    case 0x12:
      SCSIList12();
      break;
    case 0x1A:
      SCSIList1A();
      break;
    case 0x25:
      SCSIList25();
      break;
    case 0x28:
      SCSIList28(fileStatus);
      break;
    case 0x2A:
      SCSIList2A(fileStatus);
      break;
    default:
      SCSI_NotSupport();
      break;
  } /* switch */
}

/*********************************************************
* Name: USB_InitBulk
* Desc: Initialize EP1 and EP2 as Bulk only endpoint
*       EP1- IN  EP2-OUT
* Parameter: None
* Return: None
**********************************************************/
static void USB_InitBulk(void)  {
  ENDPT1=0x05;                          // endpoint 1 for IN only
  ENDPT2=0x09;                          // endpoint 2 for OUT only

  EP1Tx[0].BDT_Stat._byte= mUDATA0;
  EP1Tx[0].Cnt = cEP1_BUFF_SIZE;
  EP1Tx[0].Addr0 = (byte) (((dword)&EP1Tx_Data) >>  0);          // EP1 IN buffer;
  EP1Tx[0].Addr1 = (byte) (((dword)&EP1Tx_Data) >>  8);          // EP1 IN buffer;
  EP1Tx[0].Addr2 = (byte) (((dword)&EP1Tx_Data) >> 16);          // EP1 IN buffer;
  EP1Tx[0].Addr3 = (byte) (((dword)&EP1Tx_Data) >> 24);          // EP1 IN buffer;

  EP1Tx[1].BDT_Stat._byte= mUDATA1;
  EP1Tx[1].Cnt = cEP1_BUFF_SIZE;
  EP1Tx[1].Addr0 = (byte) (((dword)&EP1Tx_Data) >>  0);          // EP1 IN buffer;
  EP1Tx[1].Addr1 = (byte) (((dword)&EP1Tx_Data) >>  8);          // EP1 IN buffer;
  EP1Tx[1].Addr2 = (byte) (((dword)&EP1Tx_Data) >> 16);          // EP1 IN buffer;
  EP1Tx[1].Addr3 = (byte) (((dword)&EP1Tx_Data) >> 24);          // EP1 IN buffer;
  vEP1TxBuf = 0;
  vEP1TxData = mUDATA0;

  EP2Rx[0].BDT_Stat._byte = mUDATA0;
  EP2Rx[0].Cnt  = cEP2_BUFF_SIZE;
  EP2Rx[0].Addr0 = (byte) (((dword)&EP2Rx_Data) >>  0);          // EP2 buffer;
  EP2Rx[0].Addr1 = (byte) (((dword)&EP2Rx_Data) >>  8);          // EP2 buffer;
  EP2Rx[0].Addr2 = (byte) (((dword)&EP2Rx_Data) >> 16);          // EP2 buffer;
  EP2Rx[0].Addr3 = (byte) (((dword)&EP2Rx_Data) >> 24);          // EP2 buffer;

  EP2Rx[1].BDT_Stat._byte = mMCU;
  EP2Rx[1].Cnt  = cEP2_BUFF_SIZE;
  EP2Rx[1].Addr0 = (byte) (((dword)&EP2Rx_Data) >>  0);          // EP2 buffer;
  EP2Rx[1].Addr1 = (byte) (((dword)&EP2Rx_Data) >>  8);          // EP2 buffer;
  EP2Rx[1].Addr2 = (byte) (((dword)&EP2Rx_Data) >> 16);          // EP2 buffer;
  EP2Rx[1].Addr3 = (byte) (((dword)&EP2Rx_Data) >> 24);          // EP2 buffer;
  vEP2RxBuf = 0;
  vEP2RxData = mUDATA0;

  vEP2Idx = 0;
}

static void EP0_Load(void) {
  byte *pDst;

  if(vEP0IN_DataCnt==0) {
    return;
  }
  pDst=(byte *)&ICP_IN_Data;
  EP0Tx[vEP0TxBuf].Cnt = vEP0IN_DataCnt;
  while(vEP0IN_DataCnt) {
   *pDst = *pEP0IN_Data;
   pDst++;
   pEP0IN_Data++;
   vEP0IN_DataCnt--;
  }
  EP0Tx[vEP0TxBuf].BDT_Stat._byte = vEP0TxData;
  vEP0TxData ^=0x40;
  vEP0TxBuf ^=0x01;
}

/*********************************************************
* Name: EP0_Stall
* Desc: Stalls Endpoint 0
* Parameter: None
* Return: None
**********************************************************/
static void EP0_Stall(void) {
  ENDPT0_EP_STALL = 1;   /* stall EP0 */
}

/*********************************************************
* Name: EP1_Load
* Desc: Load data to Endpoint 1 buffer
* Parameter: None
* Return: None
**********************************************************/
static void EP1_Load(void) {
  byte i,counter;
  byte *pBuffer;

  pBuffer=(byte *)&EP1Tx_Data;

  if(vEP1_Cnt > cEP1_BUFF_SIZE) {
    counter = cEP1_BUFF_SIZE;
  } else {
    counter = (byte)vEP1_Cnt;
  }
  for(i=0;i<counter;i++,vEP1Idx++){
    pBuffer[i]=vEP1Data[vEP1Idx];
  }

  EP1Tx[vEP1TxBuf].Cnt = counter;
  EP1Tx[vEP1TxBuf].BDT_Stat._byte= vEP1TxData;
  vEP1TxData ^=0x40;
  vEP1TxBuf  ^=0x01;

  vEP1_Cnt = (word)(vEP1_Cnt - counter);
}

static void ICP_USB_Wait(void) {
  CTL_ODD_RST = 1;

  vEP0RxBuf = 0;
  vEP0TxBuf = 0;
  vEP0RxData = mUDATA0;
  vEP0TxData = mUDATA0;

  CTL_ODD_RST = 0;

  EP0Rx[0].BDT_Stat._byte = mUDATA0;
  EP0Rx[0].Cnt = mEP0_BUFF_SIZE;

  EP0Rx[1].BDT_Stat._byte = mMCU;
  EP0Rx[1].Cnt = mEP0_BUFF_SIZE;

  EP0Tx[0].BDT_Stat._byte = mMCU;
  EP0Tx[0].Cnt = mEP0_BUFF_SIZE;
  EP0Tx[1].BDT_Stat._byte = mMCU;
  EP0Tx[1].Cnt = mEP0_BUFF_SIZE;

  EP1Tx[0].BDT_Stat._byte= mUDATA0;
  EP1Tx[0].Cnt = cEP1_BUFF_SIZE;

  EP1Tx[1].BDT_Stat._byte= mUDATA1;
  EP1Tx[1].Cnt = cEP1_BUFF_SIZE;
  vEP1TxBuf = 0;
  vEP1TxData = mUDATA0;

  EP2Rx[0].BDT_Stat._byte = mUDATA0;
  EP2Rx[0].Cnt  = cEP2_BUFF_SIZE;

  EP2Rx[1].BDT_Stat._byte = mMCU;
  EP2Rx[0].Cnt  = cEP2_BUFF_SIZE;
  vEP2RxBuf = 0;
  vEP2RxData = mUDATA0;

  CTL_TXSUSPEND_TOKENBUSY = 0;

  ICP_USB_State = mICP_WAIT;
}

/*********************************************************
* Name: USB_CLsReq_Handler
* Desc: Handle USB class request
* Parameter: None
* Return: None
**********************************************************/
static void USB_ClsReq_Handler(void) {
  if(mGET_MAXLUN == Setup_Pkt.bRequest) {
    EP0_Stall();
  } else {
    ICP_USB_Wait();
  }
}

static void ICP_Setup_Handler(void) {
  byte length;

  vEP0IN_DataCnt= 0;
  ICP_USB_State = mICP_WAIT;

  if(0x00 == (Setup_Pkt.bmRequestType & 0x60)) {
    switch(Setup_Pkt.bRequest) {
      case mGET_STATUS:
        pEP0IN_Data = (byte*)&Device_Descriptor+4;
        vEP0IN_DataCnt = 0x02;
        break;

      case mSET_ADDR:
        ICP_AddrPend = 1;
        break;

      case mGET_DESC:

          switch(Setup_Pkt.wValue_h)
          {
            case mDESC_DEV:
              pEP0IN_Data = (byte*)&Device_Descriptor;
              vEP0IN_DataCnt = sizeof(Device_Descriptor);
              break;

            case mDESC_CFG:
              pEP0IN_Data = (byte*)&Configuration_Descriptor;
              vEP0IN_DataCnt = sizeof(Configuration_Descriptor);
              break;

            case mDESC_STR:
                    switch (Setup_Pkt.wValue_l) {
                        case 0:
                            pEP0IN_Data = (byte*)String_Descriptor0;
                            break;
                        case 1:
                            pEP0IN_Data = (byte*)String_Descriptor1;
                            break;
                        case 2:
                            pEP0IN_Data = (byte*)String_Descriptor2;
                            break;
                    }
                    vEP0IN_DataCnt = *pEP0IN_Data;
                    break;

            default:
              EP0_Stall();
              break;
          }

          break;

      case mSET_CFG:
            if(Setup_Pkt.wValue_h+Setup_Pkt.wValue_l) { // value is not zero
              USB_InitBulk();                         // init EP1 and EP2
            } else {
              ICP_AddrPend = 1;
            }
            break;

      default:                         // not support
          EP0_Stall();
          break;

    }
  } else if(0x20 == (Setup_Pkt.bmRequestType & 0x60)) {
    USB_ClsReq_Handler();
  } else {                              // not supported
    EP0_Stall();
  }
  if(Setup_Pkt.bmRequestType &0x80) { /* Device to Host */
   length = Setup_Pkt.wLength_l;
   if(length < vEP0IN_DataCnt) {
     vEP0IN_DataCnt = length;
   }
   vEP0TxData = mUDATA1;
   EP0_Load();
   ICP_USB_State   = mICP_TX;
  } else {
   ICP_USB_State   = mICP_RX;
   EP0Tx[vEP0TxBuf].Cnt = 0x00;                              // return zero IN data
   EP0Tx[vEP0TxBuf].BDT_Stat._byte = mUDATA1;
  }

  vEP0RxData ^= 0x40;
  vEP0RxBuf ^= 0x01;
  EP0Rx[vEP0RxBuf].Cnt = mEP0_BUFF_SIZE;

  EP0Rx[vEP0RxBuf].BDT_Stat._byte = vEP0RxData;
  CTL_TXSUSPEND_TOKENBUSY = 0;
}

static void ICP_In_Handler(void) {
  if(ICP_AddrPend ==1) {
    ADDR = Setup_Pkt.wValue_l;
    ICP_AddrPend =0;
  }
  if(ICP_USB_State == mICP_TX) {
    EP0_Load();
  } else {
    ICP_USB_Wait();
  }
}

static void ICP_Reset_Handler(void) {
  INT_STAT = 0xFF;              // clear all flag
  INT_ENB = 0x00;
  ADDR = 0x00;
  ICP_USB_Wait();
}

/*********************************************************
* Name: USB_EP1_IN_Handler
* Desc: Handle USB Endpoint1 IN token
* Parameter: None
* Return: None
**********************************************************/
static void USB_EP1_IN_Handler(void) {
  if( ICP_USB_State == cCSW) {
    SCSI_Send_CSW();
  } else if(ICP_USB_State == cEP1Tx) {
    EP1_Load();
    if(vEP1_Cnt == 0) {
      ICP_USB_State=mICP_WAIT;
    }
  } else {
    EP1Tx[0].Cnt = 0;
    EP1Tx[0].BDT_Stat._byte= mMCU;
    EP1Tx[1].Cnt = 0;
    EP1Tx[1].BDT_Stat._byte= mMCU;
  }
}

/*********************************************************
* Name: USB_EP2_OUT_Handler
* Desc: Handle USB Endpoint2 OUT token
* Parameter: None
* Return: None
**********************************************************/
static void USB_EP2_OUT_Handler(void) {
  byte i;
  byte *pCBW_Pkt;

  pCBW_Pkt=(byte *)&EP2Rx_Data;
  if(EP2Rx[vEP2RxBuf].Cnt ==31) { /* CBW should be 31 bytes */
    ICP_USB_State = cCBW;
    vCBWBuf_flag=1;
    for(i=0;i<EP2Rx[vEP2RxBuf].Cnt;i++) {
      vCBW_Buf[i]= pCBW_Pkt[i];
    }
    vEP2RxData ^=0x40;
    vEP2RxBuf  ^=0x01;
    EP2Rx[vEP2RxBuf].BDT_Stat._byte=vEP2RxData;
    EP2Rx[vEP2RxBuf].Cnt  = cEP2_BUFF_SIZE;
  } else {
    for(i=0;i<EP2Rx[vEP2RxBuf].Cnt;i++,vEP2Idx++) {
     vEP2Data[vEP2Idx]= pCBW_Pkt[i];
    }
    if(vEP2Idx == 512) {
      ICP_USB_State = cEP2Rx;
      vEP2RxData ^=0x40;
      vEP2RxBuf  ^=0x01;
      EP2Rx[vEP2RxBuf].Cnt  = cEP2_BUFF_SIZE;
      EP2Rx[vEP2RxBuf].BDT_Stat._byte=vEP2RxData;
    } else {
      vEP2RxData ^=0x40;
      vEP2RxBuf  ^=0x01;
      EP2Rx[vEP2RxBuf].BDT_Stat._byte=vEP2RxData;
      EP2Rx[vEP2RxBuf].Cnt  = cEP2_BUFF_SIZE;
    }
  }
}

/*********************************************************
* Name: USB_Stall_Handler
* Desc: Handles Endpoint 0 Stall
* Parameter: None
* Return: None
**********************************************************/
static void USB_Stall_Handler(void) {
  if(ENDPT0_EP_STALL) {
    ENDPT0_EP_STALL = 0;
  }
  INT_STAT_STALL = 1;         // clear stall flag
}

/*********************************************************
* Name: SCSI_PollUSB
* Desc: Polls USB flags instead of using interrupts
* Parameter: None
* Return: None
**********************************************************/
static void SCSI_PollUSB(void) {
  byte stat, odd;

  if(INT_STAT_USB_RST) {
    ICP_Reset_Handler();
  }
  if(INT_STAT_STALL) {
    USB_Stall_Handler();
  }
  if(INT_STAT_TOK_DNE) {
    stat=(byte)(STAT &0xF8);
    odd = STAT_ODD;
    /* OUT or SETUP token */
    if(stat == mEP0_OUT) {
      /* SETUP token */
      if(EP0Rx[odd].BDT_Stat.RecPid.PID == mSETUP_TOKEN) {
        ICP_Setup_Handler();
        asm (nop);
      } else { /* OUT token */
        ICP_USB_Wait();
      }
    } else if(stat == mEP0_IN) {
      /* IN token */
      ICP_In_Handler();
    } else if (stat==mEP1_IN){
      USB_EP1_IN_Handler();
    } else if (stat==mEP2_OUT) {
      USB_EP2_OUT_Handler();
    }
    /* Clear token flag */
    INT_STAT_TOK_DNE = 1;
    MultiLBAToken = 0;
  }
}

/*********************************************************
* Name: GetUSBchar
* Desc: Gets next character out of buffer used for USB data
* Parameter: unsigned char, Next character in buffer
* Return: error code or ERR_OK
**********************************************************/
static unsigned char *USB_CharPointer;

static unsigned char SCSI_GetUSBchar(unsigned char *p, void *fileStatus) {
  unsigned char c;

  c = *USB_CharPointer;
  USB_CharPointer++;
  if(USB_CharPointer==USB_BufferEnd) { /* Pointer at end of USB buffer: initiate new USB transfer to load new buffer content */
    if(!SCSI_BlockWriteDone) { /* if more USB data coming in same write transfer */
      SCSI_GetUSBOutFileData(); /* Put USB data into buffer */
    }
    if (SCSI_BlockWriteDone) {
      SCSI_vCSWResult = kCSWPass;
      SCSI_Send_CSW(); /* finish current USB transfer */
      if(*((%@S19@'ModuleName'%.FileStatus*)fileStatus)==%@S19@'ModuleName'%.FILE_STATUS_READING){  /* Not finished reading yet, need to get next USB transfer started */
        while(SCSI_BlockWriteDone) { /* Wait to receive new block of write data */
          SCSI_PollUSB(); /* Wait for USB data to come and fill buffer */
          if(vCBWBuf_flag==1) {
            SCSI_Process((%@S19@'ModuleName'%.FileStatus*)fileStatus);
            vCBWBuf_flag=0;
          }
        }
      }
    }
    USB_CharPointer = USB_BufferAddress;    // reset pointer to beginning of buffer
  }
  *p = c;
  return ERR_OK;
}

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
%-
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN PollAndProcessUSB
%ifdef PollAndProcessUSB
%define! ParfileStatus
%include Common\BootLoaderUSBPollAndProcessUSB.Inc
void %'ModuleName'%.%PollAndProcessUSB(%@S19@'ModuleName'%.FileStatus *fileStatus)
{
  SCSI_PollUSB();
  if(vCBWBuf_flag==1) {
    SCSI_Process(fileStatus);
    vCBWBuf_flag=0;
    /* Force re-enumeration to update file displayed to host */
    /* after file has been written */
    if(SCSI_ReEnumerateNow == SCSI_ENUMERATE_YES) {
      /* Force Re-enumeration */
      CTL_USB_EN_SOF_EN = 0; /* Disable USB controller */
      USBTRC0 = 0;           /* Disable PHY and Pull-Up */
      %@Wait@'ModuleName'%.Waitms(200);
      %'ModuleName'%.%InitUSB(); /* Enumerate again */
      SCSI_ReEnumerateNow = SCSI_ENUMERATE_DONE;
    }
  }
}

%endif %- PollAndProcessUSB
%-BW_METHOD_END PollAndProcessUSB
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadAndProcessS19
%ifdef ReadAndProcessS19
%define! ParfileStatus
%include Common\BootLoaderUSBReadAndProcessS19.Inc
void %'ModuleName'%.%ReadAndProcessS19(%@S19@'ModuleName'%.FileStatus *fileStatus)
{
  uint8_t res;

  USB_CharPointer = USB_BufferAddress;
  res = %@S19@'ModuleName'%.Parse(SCSI_GetUSBchar, fileStatus);
  if (res==ERR_OK && *fileStatus==%@S19@'ModuleName'%.FILE_STATUS_READING) {
    *fileStatus = %@S19@'ModuleName'%.FILE_STATUS_FINISHED;
  }
  while(!SCSI_BlockWriteDone) { /* Finish USB transfer */
    SCSI_GetUSBOutFileData();
  }
  SCSI_Send_CSW();    /* finish current USB transfer */
}

%endif %- ReadAndProcessS19
%-BW_METHOD_END ReadAndProcessS19
%-************************************************************************************************************
%-BW_METHOD_BEGIN InitUSB
%ifdef InitUSB
%include Common\BootLoaderUSBInitUSB.Inc
void %'ModuleName'%.%InitUSB(void)
{
  long *ptr;
  byte i;

  /* clear ram */
  ICP_VAR = 0x00;
  vEP0IN_DataCnt = 0x00;
  vEP0RxData = 0x00;
  vEP0TxData = 0x00;
  vEP1TxData = 0x00;
  vEP2RxData = 0x00;
  vEP0RxBuf = 0x00;
  vEP0TxBuf = 0x00;
  vEP1TxBuf = 0x00;
  vEP2RxBuf = 0x00;

  SCSI_ReEnumerateNow = SCSI_ENUMERATE_NO;
  vCBWBuf_flag = 0x00;

  v_LBA = 0; /*Initialize SCSI StateMachine */
  SCSI_BlockWriteDone = FALSE;

  SOPT2_USB_BIGEND = 0; /* in CW for MCU 6.3 (originally coming with PE 3.06) this was done in the init_hardware(), now we need to do it here */

  USBTRC0_USBRESET = 1;
  while(USBTRC0_USBRESET){};

  // Clear all BDTs
  ptr= (long *) &EP0Rx;
  for(i=0; i<24;i++) {
    *(ptr+i)=0;
  }

  EP0Rx[0].BDT_Stat._byte = mUDATA0;
  EP0Rx[0].Cnt = mEP0_BUFF_SIZE;
  EP0Rx[0].Addr0 = (byte) (((dword)&Setup_Pkt) >>  0);
  EP0Rx[0].Addr1 = (byte) (((dword)&Setup_Pkt) >>  8);
  EP0Rx[0].Addr2 = (byte) (((dword)&Setup_Pkt) >> 16);
  EP0Rx[0].Addr3 = (byte) (((dword)&Setup_Pkt) >> 24);

  EP0Rx[1].BDT_Stat._byte = mUDATA1;
  EP0Rx[1].Cnt = mEP0_BUFF_SIZE;
  EP0Rx[1].Addr0 = (byte) (((dword)&ICP_OUT_Data) >>  0);
  EP0Rx[1].Addr1 = (byte) (((dword)&ICP_OUT_Data) >>  8);
  EP0Rx[1].Addr2 = (byte) (((dword)&ICP_OUT_Data) >> 16);
  EP0Rx[1].Addr3 = (byte) (((dword)&ICP_OUT_Data) >> 24);

  EP0Tx[0].BDT_Stat._byte = mUDATA0;
  EP0Tx[0].Cnt = mEP0_BUFF_SIZE;
  EP0Tx[0].Addr0 = (byte) (((dword)&ICP_IN_Data) >>  0);
  EP0Tx[0].Addr1 = (byte) (((dword)&ICP_IN_Data) >>  8);
  EP0Tx[0].Addr2 = (byte) (((dword)&ICP_IN_Data) >> 16);
  EP0Tx[0].Addr3 = (byte) (((dword)&ICP_IN_Data) >> 24);

  EP0Tx[1].BDT_Stat._byte = mUDATA1;
  EP0Tx[1].Cnt = mEP0_BUFF_SIZE;
  EP0Tx[1].Addr0 = (byte) (((dword)&ICP_IN_Data) >>  0);
  EP0Tx[1].Addr1 = (byte) (((dword)&ICP_IN_Data) >>  8);
  EP0Tx[1].Addr2 = (byte) (((dword)&ICP_IN_Data) >> 16);
  EP0Tx[1].Addr3 = (byte) (((dword)&ICP_IN_Data) >> 24);

  USB_CTRL = 0x03;              // system clock

  BDT_PAGE_01 = (byte) (((dword)USB_BDT_START) >>  8);
  BDT_PAGE_02 = (byte) (((dword)USB_BDT_START) >> 16);
  BDT_PAGE_03 = (byte) (((dword)USB_BDT_START) >> 24);

  ENDPT0 = 0x0D;                // enable endpoint

  INT_ENB = 0x00;               // disable all interrupt
  OTG_INT_EN = 0x00;            // disable all OTG interrupt
  ERR_ENB = 0x00;               // disable all error interrupt
  INT_STAT = 0xFF;

  USB_OTG_CONTROL_DPPULLUP_NONOTG = 1;

  CTL = 0x01;                   // USB module enable

  USBTRC0 = 0x44;               // enable USB vreg and pullup resistor
}

%endif %- InitUSB
%-BW_METHOD_END InitUSB
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
%CODE_BEGIN
  /* Write code here ... */
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This component is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
