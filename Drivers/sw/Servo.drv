%-Driver generated by the Component Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Component Wizard
%- If you change these lines, Component Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    08.07.2011
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%define! Description_DoSteps Method is called by MovePos() and Trigger to move the servo.
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\ServoSettings.Inc
%define! Abstract Common\ServoAbstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited beans */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-
%ifdef ParseCommand
#define %'ModuleName'%.PARSE_COMMAND_ENABLED  1  /* set to 1 if method ParseCommand() is present, 0 otherwise */
%else
#define %'ModuleName'%.PARSE_COMMAND_ENABLED  0 /* set to 1 if method ParseCommand() is present, 0 otherwise */
%endif %- ParseCommand
%-BW_CUSTOM_USERTYPE_END


%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseCommand
%ifdef ParseCommand
byte %'ModuleName'%.%ParseCommand(const unsigned char *cmd, bool *handled, const %@Shell@'ModuleName'%.StdIOType *io);
%define! Parcmd
%define! Parhandled
%define! Pario
%define! RetVal
%include Common\ServoParseCommand.Inc

%endif %- ParseCommand
%-BW_METHOD_END ParseCommand
%-************************************************************************************************************
%-BW_METHOD_BEGIN MovePos
%ifdef MovePos
void %'ModuleName'%.%MovePos(byte pos, int16_t timeMs);
%define! Parpos
%define! PartimeMs
%include Common\ServoMovePos.Inc

%endif %- MovePos
%-BW_METHOD_END MovePos
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetPos
%ifdef SetPos
void %'ModuleName'%.%SetPos(byte pos);
%define! Parpos
%include Common\ServoSetPos.Inc

%endif %- SetPos
%-BW_METHOD_END SetPos
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetPWMDuty
%ifdef SetPWMDuty
void %'ModuleName'%.%SetPWMDuty(word dutyUs);
%define! PardutyUs
%include Common\ServoSetPWMDuty.Inc

%endif %- SetPWMDuty
%-BW_METHOD_END SetPWMDuty
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
void %'ModuleName'%.%Init(void);
%include Common\ServoInit.Inc

%endif %- Init
%-BW_METHOD_END Init
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\ServoSettings.Inc
%define! Abstract Common\ServoAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
#include <string.h> /* for strcmp() and strncmp() */

/* Hitec HS-422: 0.9ms is left, 1.5ms is midpoint, 2.1ms is right */
#define %'ModuleName'%.MIN_PWM_US       %MinPWMvalue /*!< minimal duty cycle for servo */
#define %'ModuleName'%.MAX_PWM_US       %MaxPWMvalue /*!< maximal duty cycle for servo */
#define %'ModuleName'%.PWM_STEP_RES_1K  ((%'ModuleName'%.MAX_PWM_US-%'ModuleName'%.MIN_PWM_US)*1024L/256) /*!< PWM resolution per step, scaled by 1k */
#define %'ModuleName'%.POS_TO_PWM(pos)  (uint16_t)(%'ModuleName'%.MIN_PWM_US+(((pos)*%'ModuleName'%.PWM_STEP_RES_1K)/1024)) /*!< Position to PWM transformation */
#define %'ModuleName'%.PWM_TO_POS(pwm)  (uint8_t)(((((pwm)-%'ModuleName'%.MIN_PWM_US)*1024L)/%'ModuleName'%.PWM_STEP_RES_1K)) /*!< PWM to position transformation */
#define %'ModuleName'%.SHELL_NAME_STR   "%'ModuleName'" /*!< Name used for servo in shell */

#define %'ModuleName'%.MOVE_TRIGGER_MS     20 /* we move the servo with a speed of 20 ms/50 Hz*/
#define %'ModuleName'%.MOVE_TRIGGER_TICKS  (%'ModuleName'%.MOVE_TRIGGER_MS/%@Trigger@'ModuleName'%.TICK_PERIOD_MS)

/* inverted PWM: if set to 1, then a duty value of 0xffff means signal is all time low, where 0x0000 means signal is high all time */
%if %invertedPWM='yes'
#define %'ModuleName'%.INVERTED_PWM   1
%else
#define %'ModuleName'%.INVERTED_PWM   0
%endif
#define %'ModuleName'%.PWM_PERIOD_US  20000 /* PWM period in micro seconds */

typedef struct %'ModuleName'%.ServoDescTag {
  uint16_t currPWM; /* current duty in microseconds */
  uint16_t targetPWM; /* target duty in microseconds */
  int16_t cnt; /* tick counter, >0 means ticks are still going on */
  int16_t pwmDeltaPerStep; /* pwm difference per move step */
} %'ModuleName'%.ServoDesc;

/* \brief Descriptor about the status of the servo */
static %'ModuleName'%.ServoDesc Servo;
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
%-
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-UNLOCKED
/* Internal method prototypes */
%-INTERNAL_LOC_METHOD_BEG DoSteps
static void DoSteps(void);
%-INTERNAL_LOC_METHOD_END DoSteps
%-

%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetPWMDuty
%ifdef SetPWMDuty
%define! PardutyUs
%include Common\ServoSetPWMDuty.Inc
void %'ModuleName'%.%SetPWMDuty(word dutyUs)
{
  /* avoid out of range pwm-duty cycles */
  if (dutyUs>%'ModuleName'%.MAX_PWM_US) {
    dutyUs = %'ModuleName'%.MAX_PWM_US;
  } else if (dutyUs<%'ModuleName'%.MIN_PWM_US) {
    dutyUs = %'ModuleName'%.MIN_PWM_US;
  }
  /* write new duty cycle */
#if %'ModuleName'%.INVERTED_PWM
  %@PWM@'ModuleName'%.SetDutyUS(%'ModuleName'%.PWM_PERIOD_US-dutyUs); /* 20 ms is nominal period */
#else
  %@PWM@'ModuleName'%.SetDutyUS(dutyUs);
#endif
  /* update current duty cycle value */
  Servo.currPWM = (uint16_t)dutyUs;
}

%endif %- SetPWMDuty
%-BW_METHOD_END SetPWMDuty
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetPos
%ifdef SetPos
%define! Parpos
%include Common\ServoSetPos.Inc
void %'ModuleName'%.%SetPos(byte pos)
{
  %'ModuleName'%.SetPWMDuty((uint16_t)%'ModuleName'%.POS_TO_PWM(pos));
}

%endif %- SetPos
%-BW_METHOD_END SetPos
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG DoSteps
%include Common\GeneralInternalGlobal.inc (DoSteps)
static void DoSteps(void)
{
  /* Write new duty cycle */
#if %'ModuleName'%.INVERTED_PWM
  %@PWM@'ModuleName'%.SetDutyUS((uint16_t)(%'ModuleName'%.PWM_PERIOD_US-(Servo.currPWM+Servo.pwmDeltaPerStep)));
#else
  %@PWM@'ModuleName'%.SetDutyUS((uint16_t)(Servo.currPWM+Servo.pwmDeltaPerStep));
#endif
  /* update current duty cycle value */
  Servo.currPWM += Servo.pwmDeltaPerStep;
  Servo.cnt--;
  /* if necessary, call next step by trigger */
  if(Servo.cnt>0) {
    %@Trigger@'ModuleName'%.AddTrigger(%@Trigger@'ModuleName'%.%'ModuleName', %'ModuleName'%.MOVE_TRIGGER_TICKS, DoSteps);
  }
}

%-INTERNAL_METHOD_END DoSteps
%-************************************************************************************************************
%-BW_METHOD_BEGIN MovePos
%ifdef MovePos
%define! Parpos
%define! PartimeMs
%include Common\ServoMovePos.Inc
/*!
 * \brief Moves a servo to a given position over a given time.
 * \param pos Position where to move the servo, must be in servo boundaries (in us)
 * \param timeMs Time to be used for the move, in milliseconds
**/
void %'ModuleName'%.%MovePos(byte pos, int16_t timeMs)
{
  /* calculate required steps*/
  Servo.cnt = timeMs/%'ModuleName'%.MOVE_TRIGGER_MS;
  if(Servo.cnt < 1) {
    Servo.cnt = 1; /* avoid division by zero */
  }
  Servo.targetPWM = %'ModuleName'%.POS_TO_PWM(pos);
  /* calculate increment / decrement per step */
  Servo.pwmDeltaPerStep=(int16_t)((Servo.targetPWM-Servo.currPWM)/Servo.cnt);
  DoSteps();
}

%endif %- MovePos
%-BW_METHOD_END MovePos
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseCommand
%ifdef ParseCommand
%define! Parcmd
%define! Parhandled
%define! Pario
%define! RetVal
%include Common\ServoParseCommand.Inc
/*!
 * \brief Parses a command
 * \param cmd Command string to be parsed
 * \param handled Sets this variable to TRUE if command was handled
 * \param io I/O stream to be used for input/output
 * \return Error code, ERR_OK if everything was fine
 */
byte %'ModuleName'%.%ParseCommand(const unsigned char *cmd, bool *handled, const %@Shell@'ModuleName'%.StdIOType *io)
{
  /* handling our own commands */
  int32_t val;
  const unsigned char *p;
  uint8_t res=ERR_OK;

  if (%@Util@'ModuleName'%.strcmp((const char*)cmd, %@Shell@'ModuleName'%.CMD_HELP)==0 || %@Util@'ModuleName'%.strcmp((const char *)cmd, %'ModuleName'%.SHELL_NAME_STR " help")==0) {
    %@Shell@'ModuleName'%.SendHelpStr((const unsigned char*)%'ModuleName'%.SHELL_NAME_STR, (const unsigned char*)"Servo command group\r\n", io->stdOut);
    %@Shell@'ModuleName'%.SendHelpStr((const unsigned char*)"  help|status", (const unsigned char*)"Print help or status information\r\n", io->stdOut);
    %@Shell@'ModuleName'%.SendHelpStr((const unsigned char*)"  init", (const unsigned char*)"Moves the servo to the initialisation position\r\n", io->stdOut);
    %@Shell@'ModuleName'%.SendHelpStr((const unsigned char*)"  pos <pos>", (const unsigned char*)"Move servo to a position (0 (%'ModuleName'%.MIN_PWM_US us)..255 (%'ModuleName'%.MAX_PWM_US))\r\n", io->stdOut);
    %@Shell@'ModuleName'%.SendHelpStr((const unsigned char*)"  move <pos> <ms>", (const unsigned char*)"Move servo to a position (0..255) using a moving time in milli seconds\r\n", io->stdOut);
    %@Shell@'ModuleName'%.SendHelpStr((const unsigned char*)"  pwm <pwm>", (const unsigned char*)"Set servo pwm duty value in microseconds\r\n", io->stdOut);
    *handled = TRUE;
  } else if (%@Util@'ModuleName'%.strcmp((const char*)cmd, %@Shell@'ModuleName'%.CMD_STATUS)==0 || %@Util@'ModuleName'%.strcmp((const char*)cmd, %'ModuleName'%.SHELL_NAME_STR " status")==0) {
    %@Shell@'ModuleName'%.SendStr((const unsigned char*)%'ModuleName'%.SHELL_NAME_STR ":\r\n", io->stdOut);
    %@Shell@'ModuleName'%.SendStatusStr((const unsigned char*)"  pos", (const unsigned char*)"", io->stdOut);
    %@Shell@'ModuleName'%.SendNum8u(%'ModuleName'%.PWM_TO_POS(Servo.currPWM), io->stdOut);
    %@Shell@'ModuleName'%.SendStr((const unsigned char*)"\r\n", io->stdOut);

    %@Shell@'ModuleName'%.SendStatusStr((const unsigned char*)"  pwm", (const unsigned char*)"", io->stdOut);
    %@Shell@'ModuleName'%.SendNum16u(Servo.currPWM, io->stdOut);
    %@Shell@'ModuleName'%.SendStr((const unsigned char*)" microseconds duty\r\n", io->stdOut);

    %@Shell@'ModuleName'%.SendStatusStr((const unsigned char*)"  pwm range", (const unsigned char*)"", io->stdOut);
    %@Shell@'ModuleName'%.SendNum16u(%'ModuleName'%.MIN_PWM_US, io->stdOut);
    %@Shell@'ModuleName'%.SendStr((const unsigned char*)"-", io->stdOut);
    %@Shell@'ModuleName'%.SendNum16u(%'ModuleName'%.MAX_PWM_US, io->stdOut);
    %@Shell@'ModuleName'%.SendStr((const unsigned char*)" microseconds duty\r\n", io->stdOut);
    *handled = TRUE;
  } else if (%@Util@'ModuleName'%.strcmp((const char*)cmd, %'ModuleName'%.SHELL_NAME_STR " init")==0) {
    %'ModuleName'%.Init();
    *handled = TRUE;
  } else if (strncmp((const char*)cmd, (const char*)%'ModuleName'%.SHELL_NAME_STR " pos", sizeof(%'ModuleName'%.SHELL_NAME_STR " pos")-1)==0) {
    p = cmd+sizeof(%'ModuleName'%.SHELL_NAME_STR " pos");
    if (%@Util@'ModuleName'%.xatoi(&p, &val)==ERR_OK && val>=0 && val<=255) {
      %'ModuleName'%.%MovePos((uint8_t)val, (int16_t)0);
      *handled = TRUE;
    } else {
      %@Shell@'ModuleName'%.SendStr((const unsigned char*)"Wrong pos argument, must be in the range 0..255\r\n", io->stdErr);
      res = ERR_FAILED;
    }
  } else if (strncmp((const char*)cmd, (const char*)%'ModuleName'%.SHELL_NAME_STR " move", sizeof(%'ModuleName'%.SHELL_NAME_STR " move")-1)==0) {
    p = cmd+sizeof(%'ModuleName'%.SHELL_NAME_STR " move");
    if (%@Util@'ModuleName'%.xatoi(&p, &val)==ERR_OK && val>=0 && val<=255) {
      int32_t time;

      if (%@Util@'ModuleName'%.xatoi(&p, &time)==ERR_OK) {
        %'ModuleName'%.%MovePos((uint8_t)val, (int16_t)time);
      } else {
        %@Shell@'ModuleName'%.SendStr((const unsigned char*)"Wrong time argument\r\n", io->stdErr);
      }
      *handled = TRUE;
    } else {
      %@Shell@'ModuleName'%.SendStr((const unsigned char*)"Wrong pos argument, must be in the range 0..255\r\n", io->stdErr);
      res = ERR_FAILED;
    }
  } else if (strncmp((const char*)cmd, %'ModuleName'%.SHELL_NAME_STR " pwm", sizeof(%'ModuleName'%.SHELL_NAME_STR " pwm")-1)==0) {
    p = cmd+sizeof(%'ModuleName'%.SHELL_NAME_STR " pwm");
    if (%@Util@'ModuleName'%.xatoi(&p, &val)==ERR_OK)
    {
      %'ModuleName'%.%SetPWMDuty((uint16_t)val);
      *handled = TRUE;
    } else {
      %@Shell@'ModuleName'%.SendStr((const unsigned char*)"Failed to read pwm value\r\n", io->stdErr);
      %@Shell@'ModuleName'%.SendNum16u(%'ModuleName'%.MIN_PWM_US, io->stdOut);
      %@Shell@'ModuleName'%.SendStr((const unsigned char*)"..", io->stdErr);
      %@Shell@'ModuleName'%.SendNum16u(%'ModuleName'%.MAX_PWM_US, io->stdOut);
      %@Shell@'ModuleName'%.SendStr((const unsigned char*)"\r\n", io->stdErr);
      res = ERR_FAILED;
    }
  }
  return res;
}

%endif %- ParseCommand
%-BW_METHOD_END ParseCommand
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%include Common\ServoInit.Inc
void %'ModuleName'%.%Init(void)
{
  /* init servo at mid-position*/
  %'ModuleName'_SetPWMDuty(%InitPWM);
  Servo.currPWM = %InitPWM;
}

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
  %'ModuleName'%.Init();
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This component is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
