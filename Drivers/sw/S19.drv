%-Driver generated by the Component Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Component Wizard
%- If you change these lines, Component Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    13.03.2011
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%define! Description_TextToHex Converts a text character to the corresponding hexadecimal value.
%define! Description_Get_S Skip all characters until an 'S' is received. It returns the next character.
%define! Description_Get_S_Pair Gets a pair of characters and converts it to a hex value.
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\S19Settings.Inc
%define! Abstract Common\S19Abstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited beans */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
typedef enum {
  %'ModuleName'_FILE_STATUS_NOT_STARTED, /* not started reading file yet */
  %'ModuleName'_FILE_STATUS_READING,     /* in progress reading file */
  %'ModuleName'_FILE_STATUS_ERROR,       /* generic error reading file */
  %'ModuleName'_FILE_INVALID_ADDRESS,    /* invalid address in file */
  %'ModuleName'_FILE_ERASE_FAILED,       /* failed to erase flash memory */
  %'ModuleName'_FILE_FLASH_FAILED,       /* failed to program flash memory */
  %'ModuleName'_FILE_STATUS_FINISHED     /* finished reading file and everything ok */
} %'ModuleName'_FileStatus;
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

#ifndef __BWUserType_%'ModuleName'_GetCharIterator
#define __BWUserType_%'ModuleName'_GetCharIterator
  typedef uint8_t (*%'ModuleName'%.GetCharIterator)(uint8_t*, void*);%>40/* Iterator to read from input stream. Input is stored into the first argument. With the second argument a data pointer can be passed. Returns ERR_OK or error code. */
#endif

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-
%-BW_CUSTOM_USERTYPE_END


%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN Parse
%ifdef Parse
byte %'ModuleName'%.%Parse(%'ModuleName'_GetCharIterator getChar, void *data);
%define! PargetChar
%define! Pardata
%define! RetVal
%include Common\S19Parse.Inc

%endif %- Parse
%-BW_METHOD_END Parse
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetCurrentAddress
%ifdef GetCurrentAddress
dword %'ModuleName'%.%GetCurrentAddress(void);
%define! RetVal
%include Common\S19GetCurrentAddress.Inc

%endif %- GetCurrentAddress
%-BW_METHOD_END GetCurrentAddress
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_METHOD_BEGIN OnSRecord
%ifdef OnSRecord
%INTERFACE OnSRecord
void %OnSRecord(byte *returnCode, byte type, dword addr, byte *dataBuf, byte dataBufSize, void *data);
%define! Partype
%define! PardataBuf
%define! Paraddr
%define! ParreturnCode
%define! PardataBufSize
%define! Pardata
%include Common\S19OnSRecord.Inc

%endif %- OnSRecord
%-BW_METHOD_END OnSRecord
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\S19Settings.Inc
%define! Abstract Common\S19Abstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
static dword S19_currAddress; /* current or last address read from the file */
%-
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-UNLOCKED
/* Internal method prototypes */
%-INTERNAL_LOC_METHOD_BEG TextToHex
static byte TextToHex(byte ch);
%-INTERNAL_LOC_METHOD_END TextToHex
%-INTERNAL_LOC_METHOD_BEG Get_S
static byte Get_S(%'ModuleName'_GetCharIterator getChar, void *data, byte *p);
%-INTERNAL_LOC_METHOD_END Get_S
%-INTERNAL_LOC_METHOD_BEG Get_S_Pair
static byte Get_S_Pair(%'ModuleName'_GetCharIterator getChar, void *data, byte *p);
%-INTERNAL_LOC_METHOD_END Get_S_Pair
%-

%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG TextToHex
%define! Parch
%define! RetVal
%include Common\GeneralInternalGlobal.inc (TextToHex)
static byte TextToHex(byte ch)
{
  switch (ch) {
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      return (byte)(ch-'0');
    case 'A':
    case 'a':
      return 10;
    case 'B':
    case 'b':
      return 11;
    case 'C':
    case 'c':
      return 12;
    case 'D':
    case 'd':
      return 13;
    case 'E':
    case 'e':
      return 14;
    case 'F':
    case 'f':
      return 15;
    default:
      return 0xFF;
  } /* switch */
}

%-INTERNAL_METHOD_END TextToHex
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG Get_S
%define! PargetChar
%define! Pardata
%define! Parp
%define! RetVal
%include Common\GeneralInternalGlobal.inc (Get_S)
static byte Get_S(%'ModuleName'_GetCharIterator getChar, void *data, byte *p)
{
  uint8_t c;

  for(;;) {
    if (getChar(&c, data)!=ERR_OK) { /* iterator failed? */
      return ERR_FAILED;
    }
    if (c=='S') {
      break;
    }
    if (c=='\0') { /* zero byte? something is wrong or file is not complete */
      return ERR_FAILED;
    }
  }
  /* Get type of S-record */
  if (getChar(&c, data)!=ERR_OK) {
    return ERR_FAILED;
  }
  *p = c; /* store character */
  return ERR_OK;
}

%-INTERNAL_METHOD_END Get_S
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG Get_S_Pair
%define! PargetChar
%define! Pardata
%define! Parp
%define! RetVal
%include Common\GeneralInternalGlobal.inc (Get_S_Pair)
static byte Get_S_Pair(%'ModuleName'_GetCharIterator getChar, void *data, byte *p)
{
  unsigned char ch, upper;

  if (getChar(&ch, data)!=ERR_OK) {
    return ERR_FAILED;
  }
  upper = (unsigned char)(TextToHex(ch));
  if(upper == 0xFF) { /* Not a proper S19 file */
    return ERR_FAILED;
  } else {
    upper = (byte)(upper << 4);
  }
  if (getChar(&ch, data)!=ERR_OK) {
    return ERR_FAILED;
  }
  ch = (unsigned char)(TextToHex(ch));
  if(ch == 0xFF) {   /* Not a proper S19 file */
    return ERR_FAILED;
  }
  *p = (byte)(upper | ch);
  return ERR_OK;
}

%-INTERNAL_METHOD_END Get_S_Pair
%-************************************************************************************************************
%-BW_METHOD_BEGIN Parse
%ifdef Parse
%define! PargetChar
%define! Pardata
%define! RetVal
%include Common\S19Parse.Inc
byte %'ModuleName'%.%Parse(%'ModuleName'_GetCharIterator getChar, void *data)
{
  static unsigned char srec_buffer[252]; /* here we store the data which will be flashed */
  unsigned char length, checksum, val, i, offset, type;
%if defined(OnSRecord)
  byte res;
%endif

  S19_currAddress = 0;
  for(;;) {
    /* Get start of S-record */
    if (Get_S(getChar, data, &type)!=ERR_OK) { /* not a valid S19 file */
      return ERR_FAILED;
    }
    /* Get record length */
    if (Get_S_Pair(getChar, data, &length)!=ERR_OK) { /* not a valid S19 file */
      return ERR_FAILED;
    }
    checksum = length;
    /* Take appropriate action  */
    switch (type) {
      case '1':
      case '2':
      case '3':
        S19_currAddress = 0;
        type -= '0';
        for (i = 0; i <= type ; i++) {
          /* Formulate address */
          /* Address needs to be word aligned for successful flash program  */
          if (Get_S_Pair(getChar, data, &val)!=ERR_OK) { /* not a valid S19 file */
            return ERR_FAILED;
          }
          S19_currAddress = (S19_currAddress << 8) | val;
          /* Maintain 8-bit checksum  */
          checksum = (unsigned char)((val + checksum) & 0x00FF);
          length--;
        }
      %if %AlignTo32Bit='yes'
        /* 32-bit cores program flash in 32-bit words */
        /* Therefore S19 address needs to be adjusted to be word aligned */
        /* Pad beginning of buffer if address not word aligned */
        offset = (byte) (S19_currAddress & 0x0003);
        S19_currAddress = (dword) (S19_currAddress & 0xFFFFFFFC);
        length += offset;
        for (i = 0; i < offset; i++) {
          srec_buffer[i] = 0xFF;
        }
      %else
        /* 8-bit cores program flash in 8-bit bytes */
        /* S19 address does not need to be adjusted */
        offset = 0;
      %endif
        /* Get data and put into buffer */
        for (i = offset; i < (length - 1); i++) {
          if (Get_S_Pair(getChar, data, &srec_buffer[i])!=ERR_OK) { /* not a valid S19 file */
            return ERR_FAILED;
          }
        }
        /* Calculate checksum  */
        for (i = offset; i < (length - 1); i++) {
          checksum = (unsigned char)((srec_buffer[i] + checksum) & 0x00FF);
        }
        /* Get checksum byte */
        if (Get_S_Pair(getChar, data, &val)!=ERR_OK) { /* not a valid S19 file */
          return ERR_FAILED;
        }
        if (((val - ~checksum) & 0x00FF) != 0) {
          return ERR_FAILED;
        }
      %if %AlignTo32Bit='yes'
        /* For 32-bit cores Flash_Prog writes 32-bit words, not bytes. */
        /* if last 32-bit word in s-record is not complete, finish word */
        if((i & 0x0003) != 0x0000) {  /* 32-bit word not complete */
          srec_buffer[i++] = 0xFF;    /* pad end of word  */
          srec_buffer[i++] = 0xFF;    /* pad end of word  */
          srec_buffer[i++] = 0xFF;    /* pad end of word  */
        }
      %endif
        /* NOTE: 8-bit core does not need to pad the end */
      %if defined(OnSRecord)
        res = ERR_OK;
        %OnSRecord(&res, type+'0', S19_currAddress, &srec_buffer[0], (byte)(i >> 2), data);
        if (res!=ERR_OK) {
          return ERR_FAILED;
        }
      %endif
        break;
      case '7':
      case '8':
      case '9': /* S7, S8 or S9 mark the end of the block/s-record file */
        S19_currAddress = 0;
        type = (unsigned char)(type - '0');
        type = (unsigned char)(10 - type);
        /* Get Address */
        for (i = 0; i <= type ; i++) {
          if (Get_S_Pair(getChar, data, &val)!=ERR_OK) { /* not a valid S19 file */
            return ERR_FAILED;
          }
          checksum = (unsigned char)((val + checksum) & 0x00FF);
          S19_currAddress = (S19_currAddress << 8) | val;
          length--;
        }
        /* Get Data */
        while (length-- > 1) {
          if (Get_S_Pair(getChar, data, &val)!=ERR_OK) { /* not a valid S19 file */
            return ERR_FAILED;
          }
          checksum = (unsigned char)((val + checksum) & 0x00FF);
        }
        /* Read checksum value */
        if (Get_S_Pair(getChar, data, &val)!=ERR_OK) { /* not a valid S19 file */
          return ERR_FAILED;
        }
        if (((val - ~checksum) & 0x00FF) != 0) {
          return ERR_FAILED;
        } else { /* File completely read successfully */
          return ERR_OK;
        }
        break;
      case '0':
      case '4':
      case '5':
      case '6':
      default:
        break;
    } /* switch */
  } /* while */
  return ERR_FAILED; /* we should exit this method through an S7, S8 or S9 record. This seems not be the case, so something is wrong? */
}

%endif %- Parse
%-BW_METHOD_END Parse
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetCurrentAddress
%ifdef GetCurrentAddress
%define! RetVal
%include Common\S19GetCurrentAddress.Inc
dword %'ModuleName'%.%GetCurrentAddress(void)
{
  return S19_currAddress;
}

%endif %- GetCurrentAddress
%-BW_METHOD_END GetCurrentAddress
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_METHOD_BEGIN OnSRecord
%ifdef OnSRecord
%IMPLEMENTATION OnSRecord
%define! Partype
%define! PardataBuf
%define! Paraddr
%define! ParreturnCode
%define! PardataBufSize
%define! Pardata
%include Common\S19OnSRecord.Inc
void %OnSRecord(byte *returnCode, byte type, dword addr, byte *dataBuf, byte dataBufSize, void *data)
{
  /* Write your code here ... */
}

%endif %- OnSRecord
%-BW_METHOD_END OnSRecord
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
  /* Write code here ... */
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This component is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
