%-Driver generated by the Component Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Component Wizard
%- If you change these lines, Component Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    10.12.2012
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%ifdef I2C
  %ifdef @I2C@OnRequestBus
    %define! Description_%@I2C@OnRequestBus User event which will be called before accessing the I2C bus. Useful for starting a critical section. The event services the event of the inherited component and eventually invokes other events.
  %endif %- @I2C@OnRequestBus
%endif %- I2C
%ifdef I2C
  %ifdef @I2C@OnReleaseBus
    %define! Description_%@I2C@OnReleaseBus User event which will be called after accessing the I2C bus. Useful for ending a critical section. The event services the event of the inherited component and eventually invokes other events.
  %endif %- @I2C@OnReleaseBus
%endif %- I2C
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\I2CSpySettings.Inc
%define! Abstract Common\I2CSpyAbstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited beans */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%ifdef ParseCommand
#define %'ModuleName'%.PARSE_COMMAND_ENABLED  1  /* set to 1 if method ParseCommand() is present, 0 otherwise */
%else
#define %'ModuleName'%.PARSE_COMMAND_ENABLED  0 /* set to 1 if method ParseCommand() is present, 0 otherwise */
%endif %- ParseCommand
%-
%-BW_CUSTOM_USERTYPE_END


%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
byte %'ModuleName'%.%Init(void);
%define! RetVal
%include Common\I2CSpyInit.Inc

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
void %'ModuleName'%.%Deinit(void);
%include Common\I2CSpyDeinit.Inc

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetDeviceAddress
%ifdef SetDeviceAddress
byte %'ModuleName'%.%SetDeviceAddress(byte addr);
%define! Paraddr
%define! RetVal
%include Common\I2CSpySetDeviceAddress.Inc

%endif %- SetDeviceAddress
%-BW_METHOD_END SetDeviceAddress
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetAddressSize
%ifdef SetAddressSize
byte %'ModuleName'%.%SetAddressSize(byte size);
%define! Parsize
%define! RetVal
%include Common\I2CSpySetAddressSize.Inc

%endif %- SetAddressSize
%-BW_METHOD_END SetAddressSize
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetBytesPerLine
%ifdef SetBytesPerLine
byte %'ModuleName'%.%SetBytesPerLine(byte nofBytesPerLine);
%define! ParnofBytesPerLine
%define! RetVal
%include Common\I2CSpySetBytesPerLine.Inc

%endif %- SetBytesPerLine
%-BW_METHOD_END SetBytesPerLine
%-INHERITED_EVENT_BEGIN I2C OnRequestBus
%ifdef @I2C@OnRequestBus
void %@I2C@OnRequestBus(void);

%endif %- @I2C@OnRequestBus
%-INHERITED_EVENT_END I2C OnRequestBus
%-INHERITED_EVENT_BEGIN I2C OnReleaseBus
%ifdef @I2C@OnReleaseBus
void %@I2C@OnReleaseBus(void);

%endif %- @I2C@OnReleaseBus
%-INHERITED_EVENT_END I2C OnReleaseBus
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadRegData
%ifdef ReadRegData
byte %'ModuleName'%.%ReadRegData(dword addr, byte *data, word dataSize);
%define! Paraddr
%define! Pardata
%define! PardataSize
%define! RetVal
%include Common\I2CSpyReadRegData.Inc

%endif %- ReadRegData
%-BW_METHOD_END ReadRegData
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteRegData
%ifdef WriteRegData
byte %'ModuleName'%.%WriteRegData(dword addr, byte *data, word dataSize);
%define! Paraddr
%define! Pardata
%define! PardataSize
%define! RetVal
%include Common\I2CSpyWriteRegData.Inc

%endif %- WriteRegData
%-BW_METHOD_END WriteRegData
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseCommand
%ifdef ParseCommand
byte %'ModuleName'%.%ParseCommand(const unsigned char *cmd, bool *handled, const %@Shell@'ModuleName'%.StdIOType *io);
%define! Parcmd
%define! Parhandled
%define! Pario
%define! RetVal
%include Common\I2CSpyParseCommand.Inc

%endif %- ParseCommand
%-BW_METHOD_END ParseCommand
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetDeviceAddress
%ifdef GetDeviceAddress
byte %'ModuleName'%.%GetDeviceAddress(void);
%define! RetVal
%include Common\I2CSpyGetDeviceAddress.Inc

%endif %- GetDeviceAddress
%-BW_METHOD_END GetDeviceAddress
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\I2CSpySettings.Inc
%define! Abstract Common\I2CSpyAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
#define %'ModuleName'%.DEFAULT_I2C_ADDR        %DefaultI2CAddr
#define %'ModuleName'%.DEFAULT_ADDR_SIZE       %DefaultAddrSize
#define %'ModuleName'%.DEFAULT_BYTES_PER_LINE  %DefaultBytesPerLine

typedef struct {
  uint8_t deviceAddr; /* I2C 7bit device address */
  uint8_t addrSize; /* number of address bytes, e.g. 1, 2, 3 or 4 bytes */
  uint8_t bytesPerLine; /* number of bytes per line for dump */
} %'ModuleName'%.TDataState;

static %'ModuleName'%.TDataState %'ModuleName'%.deviceData;

#define MAX_NOF_BYTES_PER_LINE 32 /* maximum number of bytes per line */
%if defined(Shell)

static void strcatAddress(unsigned char *buf, size_t bufSize, uint32_t addr) {
  if (%'ModuleName'%.deviceData.addrSize==1) {
    %@Utility@'ModuleName'%.strcatNum8Hex(buf, bufSize, (byte)addr);
  } else if (%'ModuleName'%.deviceData.addrSize==2) {
    %@Utility@'ModuleName'%.strcatNum16Hex(buf, bufSize, (word)addr);
  } else if (%'ModuleName'%.deviceData.addrSize==3) {
    %@Utility@'ModuleName'%.strcatNum24Hex(buf, bufSize, addr);
  } else if (%'ModuleName'%.deviceData.addrSize==4) {
    %@Utility@'ModuleName'%.strcatNum32Hex(buf, bufSize, addr);
  }
}

static uint8_t Dump(unsigned long startAddr, unsigned long endAddr, const %@Shell@'ModuleName'%.StdIOType *io) {
  #define NOF_BYTES_PER_LINE 32 /* how many bytes are shown on a line. This defines as well the chunk size we read from memory */
  static uint8_t buf[MAX_NOF_BYTES_PER_LINE]; /* this is the chunk of data we get (per line in output) */
  static uint8_t str[3*MAX_NOF_BYTES_PER_LINE+((MAX_NOF_BYTES_PER_LINE+1)/8)+1]; /* maximum string for output:
                                              - '3*' because each byte is 2 hex digits plus a space
                                              - '(NOF_BYTES_PER_LINE+1)/8' because we add a space between every 8 byte block
                                              - '+1' for the final zero byte */
  unsigned long addr;
  uint8_t res=0, j, bufSize;
  uint8_t ch;

  if (endAddr<startAddr) {
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n*** End address must be larger or equal than start address\r\n", io->stdErr);
    return ERR_RANGE;
  }
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"device", (unsigned char*)"0x", io->stdOut);
  str[0]='\0';
  strcatAddress(str, sizeof(str), %'ModuleName'%.deviceData.deviceAddr);
  %@Utility@'ModuleName'%.strcat(str, sizeof(str), (unsigned char*)"\r\n");
  %@Shell@'ModuleName'%.SendStr((unsigned char*)str, io->stdOut);

  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"start", (unsigned char*)"0x", io->stdOut);
  str[0]='\0';
  strcatAddress(str, sizeof(str), startAddr);
  %@Utility@'ModuleName'%.strcat(str, sizeof(str), (unsigned char*)"\r\n");
  %@Shell@'ModuleName'%.SendStr((unsigned char*)str, io->stdOut);

  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"end", (unsigned char*)"0x", io->stdOut);
  str[0]='\0';
  strcatAddress(str, sizeof(str), endAddr);
  %@Utility@'ModuleName'%.strcat(str, sizeof(str), (unsigned char*)"\r\n");
  %@Shell@'ModuleName'%.SendStr((unsigned char*)str, io->stdOut);

  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"Addr Size", (unsigned char*)"", io->stdOut);
  %@Shell@'ModuleName'%.SendNum8u(%'ModuleName'%.deviceData.addrSize, io->stdOut);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);

  for(addr=startAddr; addr<=endAddr; /* nothing */ ) {
    if (endAddr-addr+1 >= %'ModuleName'%.deviceData.bytesPerLine) { /* read only part of buffer */
      bufSize = %'ModuleName'%.deviceData.bytesPerLine; /* read full buffer */
    } else {
      bufSize = (uint8_t)(endAddr-addr+1);
    }
    if (%'ModuleName'%.ReadRegData(addr, buf, bufSize)!=ERR_OK) {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n*** Read failed!\r\n", io->stdErr);
      return ERR_FAILED;
    }
    if (res != ERR_OK) {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n*** Failure reading memory block!\r\n", io->stdErr);
      return ERR_FAULT;
    }
    /* write address */
    %@Utility@'ModuleName'%.strcpy(str, sizeof(str), (unsigned char*)"0x");
    strcatAddress(str, sizeof(str), addr);
    %@Utility@'ModuleName'%.chcat(str, sizeof(str), ':');
    %@Shell@'ModuleName'%.SendStr((unsigned char*)str, io->stdOut);
    /* write data in hex */
    str[0] = '\0';
    for (j=0; j<bufSize; j++) {
      if ((j%%8)==0) {
        %@Utility@'ModuleName'%.chcat(str, sizeof(str), ' ');
      }
      %@Utility@'ModuleName'%.strcatNum8Hex(str, sizeof(str), buf[j]);
      %@Utility@'ModuleName'%.chcat(str, sizeof(str), ' ');
    }
    for (/*empty*/; j<%'ModuleName'%.deviceData.bytesPerLine; j++) { /* fill up line */
      %@Utility@'ModuleName'%.strcat(str, sizeof(str), (unsigned char*)"-- ");
    }
    %@Shell@'ModuleName'%.SendStr((unsigned char*)str, io->stdOut);
    /* write in ASCII */
    io->stdOut(' ');
    for (j=0; j<bufSize; j++) {
      ch = buf[j];
      if (ch >= ' ' && ch <= 0x7f) {
        io->stdOut(ch);
      } else {
        io->stdOut('.'); /* place holder */
      }
    }
    for (/*empty*/; j<%'ModuleName'%.deviceData.bytesPerLine; j++) { /* fill up line */
      %@Utility@'ModuleName'%.strcat(str, sizeof(str), (unsigned char*)"-- ");
    }
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
    addr += %'ModuleName'%.deviceData.bytesPerLine;
  }
  %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
  return ERR_OK;
}

static uint8_t Read(uint32_t addr, const %@Shell@'ModuleName'%.StdIOType *io) {
  uint8_t val;
  uint8_t hexBuf[3];

  if (%'ModuleName'%.ReadRegData(addr, &val, 1)!=ERR_OK) {
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n*** read failed!\r\n", io->stdErr);
    return ERR_FAILED;
  }
  %@Shell@'ModuleName'%.SendStr((unsigned char*)"value: 0x", io->stdOut);
  hexBuf[0] = '\0';
  %@Utility@'ModuleName'%.strcatNum8Hex(hexBuf, sizeof(hexBuf), val);
  %@Shell@'ModuleName'%.SendStr(hexBuf, io->stdOut);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
  return ERR_OK;
}

static void ScanDevices(const %@Shell@'ModuleName'%.StdIOType *io) {
  uint8_t addr, oldAddr;
  uint8_t buf[3];
  uint8_t val;

  oldAddr = %'ModuleName'%.GetDeviceAddress();
  for (addr=0; addr<0x7f; addr++) {
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"probing I2C device addr 0x", io->stdOut);
    buf[0] = '\0';
    %@Utility@'ModuleName'%.strcatNum8Hex(buf, sizeof(buf), addr);
    %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
    if (%'ModuleName'%.SetDeviceAddress(addr)!=ERR_OK) {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)": failed selecting device\r\n", io->stdErr);
      break; /* get out of for loop */
    }
    if (%'ModuleName'%.ReadRegData(addr, &val, 1)!=ERR_OK) {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)": timeout\r\n", io->stdErr);
    } else {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)": Device responded!\r\n", io->stdErr);
    }
  } /* for */
  (void)%'ModuleName'%.SetDeviceAddress(oldAddr); /* restore old device address */
}

static uint8_t PrintStatus(const %@Shell@'ModuleName'%.StdIOType *io) {
  unsigned char buf[3];

  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"%'ModuleName'", (unsigned char*)"\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  deviceAddr", (unsigned char*)"0x", io->stdOut);
  buf[0] = '\0';
  %@Utility@'ModuleName'%.strcatNum8Hex(buf, sizeof(buf), %'ModuleName'%.GetDeviceAddress());
  %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  addrSize", (unsigned char*)"", io->stdOut);
  %@Shell@'ModuleName'%.SendNum8u(%'ModuleName'%.deviceData.addrSize, io->stdOut);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  bytes/Line", (unsigned char*)"", io->stdOut);
  %@Shell@'ModuleName'%.SendNum8u(%'ModuleName'%.deviceData.bytesPerLine, io->stdOut);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
  return ERR_OK;
}

static uint8_t PrintHelp(const %@Shell@'ModuleName'%.StdIOType *io) {
  /* list your local help here */
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"%'ModuleName'", (unsigned char*)"Group of %'ModuleName' commands\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  help|status", (unsigned char*)"Print help or status information\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  bytesPerLine <number>", (unsigned char*)"Number of bytes per line for dump command (1..32)\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  scan", (unsigned char*)"Scans device addresses\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  device 0x<addr>", (unsigned char*)"Set the I2C device address\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  addrSize <size>", (unsigned char*)"Address size used for device memory map (1, 2, 3 or 4)\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  read 0x<addr>", (unsigned char*)"Read a byte from an address\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  write 0x<addr> 0x<data>", (unsigned char*)"Write a data to an address. 0x<data> can be multiple items.\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  dump 0x<start>..0x<end>", (unsigned char*)"Read data from an address range\r\n", io->stdOut);
  return ERR_OK;
}

%endif
%-
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseCommand
%if defined(Shell) & defined(ParseCommand)
%define! Parcmd
%define! Parhandled
%define! Pario
%define! RetVal
%include Common\I2CSpyParseCommand.Inc
byte %'ModuleName'%.%ParseCommand(const unsigned char *cmd, bool *handled, const %@Shell@'ModuleName'%.StdIOType *io)
{
  uint8_t addr8, value8;
  uint32_t addr32, end32;
  const unsigned char *p;
  uint8_t cnt;
  uint8_t buf[16];

  if (%@Utility@'ModuleName'%.strcmp((char*)cmd, %@Shell@'ModuleName'%.CMD_HELP)==0 || %@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' help")==0) {
    *handled = TRUE;
    return PrintHelp(io);
  } else if ((%@Utility@'ModuleName'%.strcmp((char*)cmd, %@Shell@'ModuleName'%.CMD_STATUS)==0) || (%@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' status")==0)) {
    *handled = TRUE;
    return PrintStatus(io);
  } else if (%@Utility@'ModuleName'%.strncmp((char*)cmd, "%'ModuleName' bytesPerLine ", sizeof("%'ModuleName' bytesPerLine ")-1)==0) {
    p = cmd+sizeof("%'ModuleName' bytesPerLine ")-1;
    if (%@Utility@'ModuleName'%.ScanDecimal8uNumber(&p, &value8)==ERR_OK && value8>=1 && value8<=MAX_NOF_BYTES_PER_LINE) {
      %'ModuleName'%.%SetBytesPerLine(value8);
    } else {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"**** wrong bytes per line, must be 1..32\r\n", io->stdErr);
    }
    *handled = TRUE;
  } else if (%@Utility@'ModuleName'%.strncmp((char*)cmd, "%'ModuleName' device ", sizeof("%'ModuleName' device ")-1)==0) {
    p = cmd+sizeof("%'ModuleName' device ")-1;
    if (%@Utility@'ModuleName'%.ScanHex8uNumber(&p, &addr8)==ERR_OK && addr8<=0x7F) {
      (void)%'ModuleName'%.SetDeviceAddress(addr8);
    } else {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"**** wrong device address\r\n", io->stdErr);
    }
    *handled = TRUE;
  } else if (%@Utility@'ModuleName'%.strncmp((char*)cmd, "%'ModuleName' read ", sizeof("%'ModuleName' read ")-1)==0) {
    p = cmd+sizeof("%'ModuleName' read ")-1;
    if (%@Utility@'ModuleName'%.ScanHex32uNumber(&p, &addr32)==ERR_OK) {
      (void)Read(addr32, io);
    } else {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"**** wrong address\r\n", io->stdErr);
    }
    *handled = TRUE;
  } else if (%@Utility@'ModuleName'%.strncmp((char*)cmd, "%'ModuleName' addrSize ", sizeof("%'ModuleName' addrSize ")-1)==0) {
    p = cmd+sizeof("%'ModuleName' addrSize ")-1;
    if (%@Utility@'ModuleName'%.ScanDecimal8uNumber(&p, &value8)==ERR_OK && value8>=1 && value8<=4) {
      %'ModuleName'%.%SetAddressSize(value8);
    } else {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"**** addrSize of range (1-4)\r\n", io->stdErr);
    }
    *handled = TRUE;
  } else if (%@Utility@'ModuleName'%.strncmp((char*)cmd, "%'ModuleName' write ", sizeof("%'ModuleName' write ")-1)==0) {
    p = cmd+sizeof("%'ModuleName' write ")-1;
    if (%@Utility@'ModuleName'%.ScanHex32uNumber(&p, &addr32)==ERR_OK) {
      for(cnt=0; cnt<sizeof(buf) && *p!='\0'; cnt++) { /* breaks */
        if (%@Utility@'ModuleName'%.ScanHex8uNumber(&p, &buf[cnt])!=ERR_OK) {
          %@Shell@'ModuleName'%.SendStr((unsigned char*)"**** wrong data format\r\n", io->stdErr);
          cnt = 0;
          break;
        }
      } /* for */
      if (cnt>=1) {
        (void)%'ModuleName'%.WriteRegData(addr32, &buf[0], cnt);
      }
    } /* if */
    *handled = TRUE;
  } else if (%@Utility@'ModuleName'%.strncmp((char*)cmd, "%'ModuleName' dump ", sizeof("%'ModuleName' dump ")-1)==0) {
    p = cmd+sizeof("%'ModuleName' dump ")-1;
    if (%@Utility@'ModuleName'%.ScanHex32uNumber(&p, &addr32)==ERR_OK) {
      if (%@Utility@'ModuleName'%.strncmp((char*)p, "..", sizeof("..")-1)==0) {
        p = p+sizeof("..")-1;
        if (%@Utility@'ModuleName'%.ScanHex32uNumber(&p, &end32)==ERR_OK) {
          (void)Dump(addr32, end32, io);
        } else {
          %@Shell@'ModuleName'%.SendStr((unsigned char*)"**** wrong end address\r\n", io->stdErr);
        }
      } else {
        %@Shell@'ModuleName'%.SendStr((unsigned char*)"**** wrong format, '..' expected.\r\n", io->stdErr);
      }
    } else {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"**** wrong start address\r\n", io->stdErr);
    }
    *handled = TRUE;
  } else if (%@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' scan")==0) {
    ScanDevices(io);
    *handled = TRUE;
  }
  return ERR_OK;
}

%endif %- ParseCommand
%-BW_METHOD_END ParseCommand
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetDeviceAddress
%ifdef SetDeviceAddress
%define! Paraddr
%define! RetVal
%include Common\I2CSpySetDeviceAddress.Inc
byte %'ModuleName'%.%SetDeviceAddress(byte addr)
{
  %'ModuleName'%.deviceData.deviceAddr = addr;
  return ERR_OK;
}

%endif %- SetDeviceAddress
%-BW_METHOD_END SetDeviceAddress
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetDeviceAddress
%ifdef GetDeviceAddress
%define! RetVal
%include Common\I2CSpyGetDeviceAddress.Inc
byte %'ModuleName'%.%GetDeviceAddress(void)
{
  return %'ModuleName'%.deviceData.deviceAddr;
}

%endif %- GetDeviceAddress
%-BW_METHOD_END GetDeviceAddress
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetAddressSize
%ifdef SetAddressSize
%define! Parsize
%define! RetVal
%include Common\I2CSpySetAddressSize.Inc
byte %'ModuleName'%.%SetAddressSize(byte size)
{
  %'ModuleName'%.deviceData.addrSize = size;
  return ERR_OK;
}

%endif %- SetAddressSize
%-BW_METHOD_END SetAddressSize
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetBytesPerLine
%ifdef SetBytesPerLine
%define! ParnofBytesPerLine
%define! RetVal
%include Common\I2CSpySetBytesPerLine.Inc
byte %'ModuleName'%.%SetBytesPerLine(byte nofBytesPerLine)
{
  %'ModuleName'%.deviceData.bytesPerLine = nofBytesPerLine;
  return ERR_OK;
}

%endif %- SetBytesPerLine
%-BW_METHOD_END SetBytesPerLine
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%define! RetVal
%include Common\I2CSpyInit.Inc
byte %'ModuleName'%.%Init(void)
{
  if (%'ModuleName'%.%SetDeviceAddress(%'ModuleName'%.DEFAULT_I2C_ADDR)!=ERR_OK) {
    return ERR_FAILED;
  }
  if (%'ModuleName'%.%SetBytesPerLine(%'ModuleName'%.DEFAULT_BYTES_PER_LINE)!=ERR_OK) {
    return ERR_FAILED;
  }
  if (%'ModuleName'%.%SetAddressSize(%'ModuleName'%.DEFAULT_ADDR_SIZE)!=ERR_OK) {
    return ERR_FAILED;
  }
  return ERR_OK;
}

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
%include Common\I2CSpyDeinit.Inc
void %'ModuleName'%.%Deinit(void)
{
  /* nothing to do */
}

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-INHERITED_EVENT_BEGIN I2C OnRequestBus
%ifdef @I2C@OnRequestBus
%include Common\GeneralInternal.inc (OnRequestBus)
void %@I2C@OnRequestBus(void)
{
  /* Write your code here ... */
}

%endif %- @I2C@OnRequestBus
%-INHERITED_EVENT_END I2C OnRequestBus
%-INHERITED_EVENT_BEGIN I2C OnReleaseBus
%ifdef @I2C@OnReleaseBus
%include Common\GeneralInternal.inc (OnReleaseBus)
void %@I2C@OnReleaseBus(void)
{
  /* Write your code here ... */
}

%endif %- @I2C@OnReleaseBus
%-INHERITED_EVENT_END I2C OnReleaseBus
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadRegData
%ifdef ReadRegData
%define! Paraddr
%define! Pardata
%define! PardataSize
%define! RetVal
%include Common\I2CSpyReadRegData.Inc
byte %'ModuleName'%.%ReadRegData(dword addr, byte *data, word dataSize)
{
  uint8_t addrBuf[4];

  addrBuf[3] = (uint8_t)(addr&0xff);
  addrBuf[2] = (uint8_t)((addr&0xff00)>>8);
  addrBuf[1] = (uint8_t)((addr&0xff0000)>>16);
  addrBuf[0] = (uint8_t)((addr&0xff000000)>>24);
  return %@I2C@'ModuleName'%.ReadAddress(%'ModuleName'%.deviceData.deviceAddr, &addrBuf[4-%'ModuleName'%.deviceData.addrSize],
     %'ModuleName'%.deviceData.addrSize, data, dataSize);
}

%endif %- ReadRegData
%-BW_METHOD_END ReadRegData
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteRegData
%ifdef WriteRegData
%define! Paraddr
%define! Pardata
%define! PardataSize
%define! RetVal
%include Common\I2CSpyWriteRegData.Inc
byte %'ModuleName'%.%WriteRegData(dword addr, byte *data, word dataSize)
{
  uint8_t addrBuf[4];

  addrBuf[3] = (uint8_t)(addr&0xff);
  addrBuf[2] = (uint8_t)((addr&0xff00)>>8);
  addrBuf[1] = (uint8_t)((addr&0xff0000)>>16);
  addrBuf[0] = (uint8_t)((addr&0xff000000)>>24);
  return %@I2C@'ModuleName'%.WriteAddress(%'ModuleName'%.deviceData.deviceAddr, &addrBuf[4-%'ModuleName'%.deviceData.addrSize],
     %'ModuleName'%.deviceData.addrSize, data, dataSize);
}

%endif %- WriteRegData
%-BW_METHOD_END WriteRegData
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
  (void)%'ModuleName'%.%Init();
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This component is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
