%-Driver generated by the Bean Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Bean Wizard
%- If you change these lines, Bean Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    09.07.2008
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%define! Description_Init 
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\SSECSettings.Inc
%define! Abstract Common\SSECAbstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited beans */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"
%include sw\CommonSupport.prg
%-

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-
%-BW_CUSTOM_USERTYPE_END


%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN Encrypt
%ifdef Encrypt
byte %'ModuleName'%.%Encrypt(byte *pu8Buffer, byte u8Length);
%define! Parpu8Buffer
%define! Paru8Length
%define! RetVal
%include Common\SSECEncrypt.Inc

%endif %- Encrypt
%-BW_METHOD_END Encrypt
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetKey
%ifdef SetKey
void %'ModuleName'%.%SetKey(byte *pBuffer, byte u8Length);
%define! ParpBuffer
%define! Paru8Length
%include Common\SSECSetKey.Inc

%endif %- SetKey
%-BW_METHOD_END SetKey
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG Init
void %'ModuleName'%.Init(void);
%include Common\GeneralInternal.inc (Init)

%-INTERNAL_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN Decrypt
%ifdef Decrypt
byte %'ModuleName'%.%Decrypt(byte *pu8Buffer, byte *u8Length);
%define! Parpu8Buffer
%define! Paru8Length
%define! RetVal
%include Common\SSECDecrypt.Inc

%endif %- Decrypt
%-BW_METHOD_END Decrypt
%-************************************************************************************************************
%-BW_METHOD_BEGIN AdjustPacketSize
%ifdef AdjustPacketSize
byte %'ModuleName'%.%AdjustPacketSize(byte *buf, byte bufSize, byte *dataSize);
%define! Parbuf
%define! ParbufSize
%define! PardataSize
%define! RetVal
%include Common\SSECAdjustPacketSize.Inc

%endif %- AdjustPacketSize
%-BW_METHOD_END AdjustPacketSize
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\SSECSettings.Inc
%define! Abstract Common\SSECAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
%-
%ifdef SetKey
%- we have a function to set the key: use variables
static byte *%'ModuleName'%.pu8SECKey = (byte*)"%SecurityDefaultKey";        %>%CTAB /*!< the security key */
static byte %'ModuleName'%.u8SECKeyLength = sizeof("%SecurityDefaultKey")-1; %>%CTAB /*!< the lenght of the security key */
%else
%- no function to set key: use the constant key only
#define %'ModuleName'%.pu8SECKey "%SecurityDefaultKey"                  %>%CTAB /*!< the security key */
#define %'ModuleName'%.u8SECKeyLength (sizeof("%SecurityDefaultKey")-1) %>%CTAB /*!< the lenght of the security key */
%endif %- SetKey
%if %3DESSecurity='yes'
static %@3DES@'ModuleName'%.TCryptParam %'ModuleName'%.cp; /* crypt parameter block */
static const TData64 %'ModuleName'%.iv = {0x%#l%IV1, 0x%#l%IV2}; /* initialization vector */
%endif
%if %SerpentSecurity='yes'
static %@Serpent@'ModuleName'%.TCryptParam %'ModuleName'%.cp; /* crypt parameter block */
static const TData128 %'ModuleName'%.iv = {0x%#l%IV1, 0x%#l%IV2,  0x%#l%IV3, 0x%#l%IV4}; /* initialization vector */
%endif
%if %TwoFishSecurity='yes'
static %@TwoFish@'ModuleName'%.TCryptParam %'ModuleName'%.cp; /* crypt parameter block */
static const TData128 %'ModuleName'%.iv = {0x%#l%IV1, 0x%#l%IV2,  0x%#l%IV3, 0x%#l%IV4}; /* initialization vector */
%endif
%if %IdeaSecurity='yes'
static %@Idea@'ModuleName'%.TCryptParam %'ModuleName'%.cp; /* crypt parameter block */
static const TData64 %'ModuleName'%.iv = {(0x%#l%IV1&0xffff0000)>>16, 0x%#l%IV1&0xffff, (0x%#l%IV2&0xffff0000)>>16, 0x%#l%IV2&0xffff}; /* initialization vector */
%endif
%if %MarsSecurity='yes'
static %@Mars@'ModuleName'%.TCryptParam %'ModuleName'%.cp; /* crypt parameter block */
static const TData128 %'ModuleName'%.iv = {0x%#l%IV1, 0x%#l%IV2,  0x%#l%IV3, 0x%#l%IV4}; /* initialization vector */
%endif
%if %RC6Security='yes'
static %@RC6@'ModuleName'%.TCryptParam %'ModuleName'%.cp; /* crypt parameter block */
static const TData128 %'ModuleName'%.iv = {0x%#l%IV1, 0x%#l%IV2,  0x%#l%IV3, 0x%#l%IV4}; /* initialization vector */
%endif

%-
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN Encrypt
%ifdef Encrypt
%define! Parpu8Buffer
%define! Paru8Length
%define! RetVal
%include Common\SSECEncrypt.Inc
%if defined(COMPILER_HIX) & SMACSecurity='yes' & SecurityType='SEC_MODE_SIMPLEXOR'
#pragma MESSAGE DISABLE C5900 /* result is zero, in case of 1 char default key */
#pragma MESSAGE DISABLE C4000 /* condition is always true */
%endif %-SMACSecurity='yes' & SecurityType='SEC_MODE_SIMPLEXOR'
byte %'ModuleName'%.%Encrypt(byte *pu8Buffer, byte u8Length)
{
%if SMACSecurity='yes'
 %if SecurityType='SEC_MODE_NOSECURITY'
  /* no security */
  (void)pu8Buffer; (void)u8Length; /* to avoid compiler warning about unused argument */
 %elif SecurityType='SEC_MODE_SIMPLEXOR'
  /* simple XOR security */
  byte i = 0;

  if (%'ModuleName'%.u8SECKeyLength > 0) {
    while (i < u8Length){
      *pu8Buffer ^= %'ModuleName'%.pu8SECKey[i%%%'ModuleName'%.u8SECKeyLength];
      pu8Buffer++;
      i++;
    }
  }
 %else
  #warning "security type not implemented!"
 %endif
%endif
%if %3DESSecurity='yes' | %SerpentSecurity='yes' | %TwoFishSecurity='yes' | %IdeaSecurity='yes' | %MarsSecurity='yes' | %RC6Security='yes'
  byte i, tmp[%CryptBlockSize]; /* temporary block for encrypted block. The block has a fixed size of %CryptBlockSize bytes. */

  if ((u8Length%%%CryptBlockSize) != 0) {
    return ERR_OVERFLOW; /* buffer blocks have to be a multiple of %CryptBlockSize bytes! */
  }
  while(u8Length > 0) {
%if %3DESSecurity='yes'
    %@3DES@'ModuleName'%.Encrypt(pu8Buffer, tmp, &%'ModuleName'%.cp);
%endif
%if %SerpentSecurity='yes'
    %@Serpent@'ModuleName'%.Encrypt(pu8Buffer, tmp, &%'ModuleName'%.cp);
%endif
%if %TwoFishSecurity='yes'
    %@TwoFish@'ModuleName'%.Encrypt(pu8Buffer, tmp, &%'ModuleName'%.cp);
%endif
%if %IdeaSecurity='yes'
    %@Idea@'ModuleName'%.Encrypt(pu8Buffer, tmp, &%'ModuleName'%.cp);
%endif
%if %MarsSecurity='yes'
    %@Mars@'ModuleName'%.Encrypt(pu8Buffer, tmp, &%'ModuleName'%.cp);
%endif
%if %RC6Security='yes'
    %@RC6@'ModuleName'%.Encrypt(pu8Buffer, tmp, &%'ModuleName'%.cp);
%endif
    for(i=0;i<sizeof(tmp);i++) {
      *pu8Buffer++ = tmp[i];
    }
    u8Length -= sizeof(tmp);
  }
%endif
  return ERR_OK;
}
%if defined(COMPILER_HIX) & SMACSecurity='yes' & SecurityType='SEC_MODE_SIMPLEXOR'
#pragma MESSAGE DEFAULT C5900 /* result is zero */
#pragma MESSAGE DEFAULT C4000 /* condition is always true */
%endif %-SMACSecurity='yes' & SecurityType='SEC_MODE_SIMPLEXOR'
%endif %- Encrypt
%-BW_METHOD_END Encrypt
%-************************************************************************************************************
%-BW_METHOD_BEGIN Decrypt
%ifdef Decrypt
%define! Parpu8Buffer
%define! Paru8Length
%define! RetVal
%include Common\SSECDecrypt.Inc
byte %'ModuleName'%.%Decrypt(byte *pu8Buffer, byte *u8Length)
{
%if SMACSecurity='yes'
%if SecurityType='SEC_MODE_NOSECURITY'
  /* no security */
  (void)pu8Buffer; (void)u8Length; /* to avoid compiler warning about unused argument */
%elif SecurityType='SEC_MODE_SIMPLEXOR'
  /* simple XOR security */
  byte i = 0;

  if (%'ModuleName'%.u8SECKeyLength > 0) {
    while (i < *u8Length){
      *pu8Buffer ^= %'ModuleName'%.pu8SECKey[i%%%'ModuleName'%.u8SECKeyLength];
      pu8Buffer++;
      i++;
    }
  }
%else
  #warning "security type not implemented!"
%endif
%endif
%if %3DESSecurity='yes' | %SerpentSecurity='yes' | %TwoFishSecurity='yes' | %IdeaSecurity='yes' | %MarsSecurity='yes' | %RC6Security='yes'
  byte i, tmp[%CryptBlockSize]; /* temporary block for decrypted block. The block has a fixed size of %CryptBlockSize bytes. */
  byte length; /* packet length we received */
  byte newLength; /* length of decrypted packet */
  byte *p; /* pointer to iterate the source buffer */

  length = *u8Length;
  if (length < %CryptBlockSize) { /* encrypted packets are at least %CryptBlockSize bytes! */
    return ERR_FAULT; /* return with error */
  }
  p = pu8Buffer;
  while(length > 0) {
    %if %3DESSecurity='yes'
    %@3DES@'ModuleName'%.Decrypt(p, tmp, &%'ModuleName'%.cp);
    %endif
    %if %SerpentSecurity='yes'
    %@Serpent@'ModuleName'%.Decrypt(p, tmp, &%'ModuleName'%.cp);
    %endif
    %if %TwoFishSecurity='yes'
    %@TwoFish@'ModuleName'%.Decrypt(p, tmp, &%'ModuleName'%.cp);
    %endif
    %if %IdeaSecurity='yes'
    %@Idea@'ModuleName'%.Decrypt(p, tmp, &%'ModuleName'%.cp);
    %endif
    %if %MarsSecurity='yes'
    %@Mars@'ModuleName'%.Decrypt(p, tmp, &%'ModuleName'%.cp);
    %endif
    %if %RC6Security='yes'
    %@RC6@'ModuleName'%.Decrypt(p, tmp, &%'ModuleName'%.cp);
    %endif
    for(i=0; i<sizeof(tmp) && length>0; i++, length--) { /* copy decrypted information back into data packet */
      *p++ = tmp[i];
    }
  }
  newLength = pu8Buffer[*u8Length-1]; /* actual data length is in last byte of decrypted block */
  if (!(newLength>=(*u8Length)-%CryptBlockSize && newLength<=(*u8Length))) { /* with the encryption the packet will grow up at maximum of %CryptBlockSize bytes */
    return ERR_FAULT; /* return with error */
  }
  *u8Length = newLength; /* update new and real packet length */
%endif
  return ERR_OK;
}

%endif %- Decrypt
%-BW_METHOD_END Decrypt
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetKey
%ifdef SetKey
%define! ParpBuffer
%define! Paru8Length
%include Common\SSECSetKey.Inc
void %'ModuleName'%.%SetKey(byte *pBuffer, byte u8Length)
{
  %'ModuleName'%.pu8SECKey = pBuffer;
  %'ModuleName'%.u8SECKeyLength = u8Length;
%if %3DESSecurity='yes'
  %@3DES@'ModuleName'%.SetKeyHex((char*)%'ModuleName'%.pu8SECKey, &%'ModuleName'%.cp); /* Set key value into parameters record */
  %@3DES@'ModuleName'%.InitKey(%'ModuleName'%.iv, &%'ModuleName'%.cp); /* Set key, key schedule and other parameters into parameters record */
%endif
%if %SerpentSecurity='yes'
  %@Serpent@'ModuleName'%.SetKeyHex((char*)%'ModuleName'%.pu8SECKey, &%'ModuleName'%.cp); /* Set key value into parameters record */
  %@Serpent@'ModuleName'%.InitKey(%'ModuleName'%.iv, &%'ModuleName'%.cp); /* Set key, key schedule and other parameters into parameters record */
%endif
%if %TwoFishSecurity='yes'
  %@TwoFish@'ModuleName'%.SetKeyHex((char*)%'ModuleName'%.pu8SECKey, &%'ModuleName'%.cp); /* Set key value into parameters record */
  %@TwoFish@'ModuleName'%.InitKey(%'ModuleName'%.iv, &%'ModuleName'%.cp); /* Set key, key schedule and other parameters into parameters record */
%endif
%if %IdeaSecurity='yes'
  %@Idea@'ModuleName'%.SetKeyHex((char*)%'ModuleName'%.pu8SECKey, &%'ModuleName'%.cp); /* Set key value into parameters record */
  %@Idea@'ModuleName'%.InitKey(%'ModuleName'%.iv, &%'ModuleName'%.cp); /* Set key, key schedule and other parameters into parameters record */
%endif
%if %MarsSecurity='yes'
  %@Mars@'ModuleName'%.SetKeyHex((char*)%'ModuleName'%.pu8SECKey, &%'ModuleName'%.cp); /* Set key value into parameters record */
  %@Mars@'ModuleName'%.InitKey(%'ModuleName'%.iv, &%'ModuleName'%.cp); /* Set key, key schedule and other parameters into parameters record */
%endif
%if %RC6Security='yes'
  %@RC6@'ModuleName'%.SetKeyHex((char*)%'ModuleName'%.pu8SECKey, &%'ModuleName'%.cp); /* Set key value into parameters record */
  %@RC6@'ModuleName'%.InitKey(%'ModuleName'%.iv, &%'ModuleName'%.cp); /* Set key, key schedule and other parameters into parameters record */
%endif
}
%endif %- SetKey
%-BW_METHOD_END SetKey
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG Init
%include Common\GeneralInternal.inc (Init)
void %'ModuleName'%.Init(void)
{
%if %3DESSecurity='yes' | %SerpentSecurity='yes' | %TwoFishSecurity='yes' | %IdeaSecurity='yes' | %MarsSecurity='yes' | %RC6Security='yes'
  %'ModuleName'%.%SetKey(%'ModuleName'%.pu8SECKey, %'ModuleName'%.u8SECKeyLength);
%endif
}

%-INTERNAL_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN AdjustPacketSize
%ifdef AdjustPacketSize
%define! Parbuf
%define! ParbufSize
%define! PardataSize
%define! RetVal
%include Common\SSECAdjustPacketSize.Inc
byte %'ModuleName'%.%AdjustPacketSize(byte *buf, byte bufSize, byte *dataSize)
{
%if %3DESSecurity='yes' | %SerpentSecurity='yes' | %TwoFishSecurity='yes' | %IdeaSecurity='yes' | %MarsSecurity='yes' | %RC6Security='yes'
  /* The data packet needs to be a multiple of %CryptBlockSize bytes */
  byte incSize = (%CryptBlockSize-(((*dataSize)+1)%%%CryptBlockSize))+1; /* number of additional bytes needed for multiple of %CryptBlockSize, plus one byte for the size itself */

  if (*dataSize + incSize > bufSize) { /* buffer data structure not large enough: increase buffer size! */
    return ERR_OVERFLOW;
  }
  *(buf + *dataSize + incSize - 1) = *dataSize; /* last byte in data packet is the real data size */
  *dataSize += incSize; /* increase data packet size */
%else
  (void)buf; (void)bufSize; (void)dataSize; /* to avoid compiler warnings about unused variables */
%endif
  return ERR_OK;
}

%endif %- AdjustPacketSize
%-BW_METHOD_END AdjustPacketSize
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
%-  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
%CODE_END
  %'ModuleName'%.Init();
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This bean is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
