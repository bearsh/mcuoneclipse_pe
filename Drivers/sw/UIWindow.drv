%-Driver generated by the Bean Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Bean Wizard
%- If you change these lines, Bean Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    25.09.2009
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%define! Description_Paint Paints a window with all widgets
%define! Description_EventCallbackMovableWindow Callback used for movable window
%define! Description_MsgHandler Callback used for widget events
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\UIWindowSettings.Inc
%define! Abstract Common\UIWindowAbstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited beans */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"

typedef %@UI@'ModuleName'%.PixelColor %'ModuleName'%.PixelColor; %>40/* type large enough to hold the color information */
typedef %@UI@'ModuleName'%.PixelDim %'ModuleName'%.PixelDim;     %>40/* type big enough to hold the x and y coordinates */
typedef %@UI@'ModuleName'%.Screen %'ModuleName'%.Screen;         %>40/* Alias to UserInterface type */
typedef %@UI@'ModuleName'%.Element %'ModuleName'%.Element;       %>40/* Alias to UserInterface type */
typedef %@UI@'ModuleName'%.Coordinate %'ModuleName'%.Coordinate; %>40/* Alias to UserInterface type */
typedef %@UI@'ModuleName'%.MsgKind %'ModuleName'%.MsgKind;       %>40/* Alias to UserInterface type */
typedef %@UI@'ModuleName'%.Pvoid %'ModuleName'%.Pvoid;           %>40/* Alias to Pvoid data type */
typedef %@UI@'ModuleName'%.painterCallback %'ModuleName'%.painterCallback;%>40/* Alias to UserInterface type */
%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;

/* --- Element: Window --- */
typedef struct %'ModuleName'_WindowWidget {
  %'ModuleName'_Element element;                                 %>40 /* the base element, always first in structure */
%ifdef SetUserMsgHandler
  %@UI@'ModuleName'%.MsgHandler userMsgHandler;                  %>40/* optional user handler */
%endif %- SetUserMsgHandler
%if movable='yes'
  bool windowMovable;
  %'ModuleName'_Coordinate clickCoord;                           %>40 /* saves the coordinates on click, needed for movable window */
%endif
} %'ModuleName'_WindowWidget;
%-
%-BW_CUSTOM_USERTYPE_END

%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN Create
%ifdef Create
byte %'ModuleName'%.%Create(%'ModuleName'_Element *parent, %'ModuleName'_WindowWidget *window, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim width, %'ModuleName'_PixelDim height);
%define! Parwindow
%define! Parx
%define! Pary
%define! Parwidth
%define! Parheight
%define! Parparent
%define! RetVal
%include Common\UIWindowCreate.Inc

%endif %- Create
%-BW_METHOD_END Create
%-************************************************************************************************************
%-BW_METHOD_BEGIN WindowSetBorder
%ifdef WindowSetBorder
%-BW_PUBLISH_MACRO
#define %'ModuleName'%.%WindowSetBorder(window) \
  (window)->element.prop.flags |= %@UI@'ModuleName'%.FLAGS_WINDOW_HAS_BORDER
%define! Parwindow
%include Common\UIWindowWindowSetBorder.Inc

%endif %- WindowSetBorder
%-BW_METHOD_END WindowSetBorder
%-************************************************************************************************************
%-BW_METHOD_BEGIN MakeWindowMovable
%ifdef MakeWindowMovable
void %'ModuleName'%.%MakeWindowMovable(%'ModuleName'_WindowWidget *window);
%define! Parwindow
%include Common\UIWindowMakeWindowMovable.Inc

%endif %- MakeWindowMovable
%-BW_METHOD_END MakeWindowMovable
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetUserMsgHandler
%ifdef SetUserMsgHandler
%-BW_PUBLISH_MACRO
#define %'ModuleName'%.%SetUserMsgHandler(window, handler) \
  (window)->userMsgHandler = handler

%define! Parwindow
%define! Parhandler
%include Common\UIWindowSetUserMsgHandler.Inc

%endif %- SetUserMsgHandler
%-BW_METHOD_END SetUserMsgHandler
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetBackgroundColor
%ifdef SetBackgroundColor
#define %'ModuleName'%.%SetBackgroundColor(window, color) \
  %@UI@'ModuleName'%.SetElementColor(&((window)->element), color)

%define! Parcolor
%define! Parwindow
%include Common\UIWindowSetBackgroundColor.Inc

%endif %- SetBackgroundColor
%-BW_METHOD_END SetBackgroundColor
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\UIWindowSettings.Inc
%define! Abstract Common\UIWindowAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"

%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
%-
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-UNLOCKED
/* Internal method prototypes */
%-INTERNAL_LOC_METHOD_BEG Paint
static byte Paint(%'ModuleName'_Element *element);
%-INTERNAL_LOC_METHOD_END Paint
%-INTERNAL_LOC_METHOD_BEG EventCallbackMovableWindow
static void EventCallbackMovableWindow(%'ModuleName'_Element *element, %'ModuleName'_MsgKind kind, %'ModuleName'_Pvoid pData);
%-INTERNAL_LOC_METHOD_END EventCallbackMovableWindow
%-INTERNAL_LOC_METHOD_BEG MsgHandler
static void MsgHandler(%'ModuleName'_MsgKind kind, %'ModuleName'_Element *element, %'ModuleName'_Pvoid pData);
%-INTERNAL_LOC_METHOD_END MsgHandler
%-

%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG MsgHandler
%define! Parkind
%define! ParpData
%define! Parelement
%include Common\GeneralInternalGlobal.inc (MsgHandler)
static void MsgHandler(%'ModuleName'_MsgKind kind, %'ModuleName'_Element *element, %'ModuleName'_Pvoid pData)
{
%ifdef SetUserMsgHandler
  %'ModuleName'_WindowWidget *widget = (%'ModuleName'_WindowWidget*)element;

%else
  (void)pData; /* avoid warning about unused argument */
%endif
  if (kind==%@UI@'ModuleName'%.MSG_WIDGET_PAINT) {
    (void)Paint(element);
%-  } else if (kind==%@UI@'ModuleName'%.MSG_WIDGET_RESIZE) {
%-    (void)%'ModuleName'%.%Resize(widget);
  }
%ifdef SetUserMsgHandler
  if (widget->userMsgHandler != NULL){
    widget->userMsgHandler(kind, element, pData);                %>40/* call user event  */
  }
%endif
}
%-INTERNAL_METHOD_END MsgHandler
%-************************************************************************************************************
%-BW_METHOD_BEGIN Create
%ifdef Create
%define! Parwindow
%define! Parx
%define! Pary
%define! Parwidth
%define! Parheight
%define! Parparent
%define! RetVal
%include Common\UIWindowCreate.Inc
byte %'ModuleName'%.%Create(%'ModuleName'_Element *parent, %'ModuleName'_WindowWidget *window, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim width, %'ModuleName'_PixelDim height)
{
  if (parent == NULL || window == NULL) {
    return ERR_FAILED;
  }
  %@UI@'ModuleName'%.ElementInitCommon((%'ModuleName'%.Element*)window, %@UI@'ModuleName'%.WIDGET_WINDOW,
    x, y, width, height, %@UI@'ModuleName'%.COLOR_%WindowBackgroundColor, MsgHandler);
%if %WindowHasBorder='yes'
  %'ModuleName'%.%WindowSetBorder(window);
%endif
%if %movable='yes'
  window->windowMovable = TRUE;
  window->clickCoord.x = 0;
  window->clickCoord.y = 0;
%endif
%ifdef SetUserMsgHandler
  window->userMsgHandler = NULL;                                 %>40/* needs to be set by user */
%endif %- SetUserMsgHandler
  return %@UI@'ModuleName'%.AddSubElement(parent, &window->element);%>40/* add window to screen */
}

%endif %- Create
%-BW_METHOD_END Create
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG Paint
%define! Parelement
%define! RetVal
%include Common\GeneralInternalGlobal.inc (Paint)
static byte Paint(%'ModuleName'_Element *element)
{
  bool updateAll; /* do we need a global update? */
  %'ModuleName'_WindowWidget *window = (%'ModuleName'_WindowWidget*)element;

  if (window != NULL) {
    updateAll = window->element.prop.flags&%@UI@'ModuleName'%.FLAGS_NEEDS_REPAINT;
    if (updateAll) {                                             %>40/* start with drawing the background */
%ifdef _OPTIMIZE_CLEARED_BACKGROUND
      if (window->prop.flags&%@UI@'ModuleName'%.FLAGS_WINDOW_HAS_BORDER) {
        %@UI@'ModuleName'%.DrawBox(window->element.prop.x, window->element.prop.y, window->element.prop.width, window->element.prop.height, 1, %@UI@'ModuleName'%.COLOR_%WindowBorderColor);
        if (!(window->element.prop.flags&%@UI@'ModuleName'%.FLAGS_WINDOW_BG_CLEARED)) {
          %@UI@'ModuleName'%.DrawFilledBox(
              (%'ModuleName'_PixelDim)(window->element.prop.x+1),
              (%'ModuleName'_PixelDim)(window->element.prop.y+1),
              (%'ModuleName'_PixelDim)(window->element.prop.width-2),
              (%'ModuleName'_PixelDim)(window->element.prop.height-2), window->element.prop.color);
          window->element.prop.flags |= %@UI@'ModuleName'%.FLAGS_WINDOW_BG_CLEARED;%>40/* window is in background color now */
        }
      } else if (!(window->element.prop.flags&%@UI@'ModuleName'%.FLAGS_WINDOW_BG_CLEARED)) {
        %@UI@'ModuleName'%.DrawFilledBox(window->element.prop.x, window->element.prop.y, window->element.prop.width, window->element.prop.height, window->element.prop.color);
        window->element.prop.flags |= %@UI@'ModuleName'%.FLAGS_WINDOW_BG_CLEARED;%>40/* window is in background color now */
      }
    }
%else
      if (window->element.prop.flags&%@UI@'ModuleName'%.FLAGS_WINDOW_HAS_BORDER) {
        %@UI@'ModuleName'%.DrawBox(&window->element, 0, 0, window->element.prop.width, window->element.prop.height, 1, %@UI@'ModuleName'%.COLOR_%WindowBorderColor);
        %@UI@'ModuleName'%.DrawFilledBox(&window->element,
              1,
              1,
              (%'ModuleName'_PixelDim)(window->element.prop.width-2),
              (%'ModuleName'_PixelDim)(window->element.prop.height-2), window->element.prop.color);%>40 /* assuming window height/width > 2 pixel */
      } else {
        %@UI@'ModuleName'%.DrawFilledBox(&window->element, 0, 0, window->element.prop.width, window->element.prop.height, window->element.prop.color);
      }
    }
%endif
    element = window->element.sub;                               %>40/* start with first element of window */
    if (element!=NULL) {
      do {
        %@UI@'ModuleName'%.UpdateElementNoRefresh(NULL, element, updateAll);%>40/* paint element, or whole window */
        if (element->prop.type==%@UI@'ModuleName'%.WIDGET_WINDOW) {%>40/* subtree is already painted recursively */
          element = element->next;
        } else {
          %@UI@'ModuleName'%.NextElement(&element, &window->element);%>40/* get next element in list */
        }
      } while (element!=NULL && element!=&window->element);
    }
    window->element.prop.flags &= ~%@UI@'ModuleName'%.FLAGS_NEEDS_REPAINT;
%ifdef _OPTIMIZE_CLEARED_BACKGROUND
    window->element.prop.flags &= ~%@UI@'ModuleName'%.FLAGS_WINDOW_BG_CLEARED;%>40/* mark that we have changed content and it is not any more in just background color */
%endif
  }
  return ERR_OK;
}

%-INTERNAL_METHOD_END Paint
%-************************************************************************************************************
%-BW_METHOD_BEGIN WindowSetBorder
%ifdef WindowSetBorder
%define! Parwindow
%include Common\UIWindowWindowSetBorder.Inc
/*
void %'ModuleName'%.%WindowSetBorder(%'ModuleName'_WindowWidget *window)
 ** This method is implemented as macro
*/

%endif %- WindowSetBorder
%-BW_METHOD_END WindowSetBorder
%-************************************************************************************************************
%-BW_METHOD_BEGIN MakeWindowMovable
%ifdef MakeWindowMovable
%define! Parwindow
%include Common\UIWindowMakeWindowMovable.Inc
void %'ModuleName'%.%MakeWindowMovable(%'ModuleName'_WindowWidget *window)
{
%if movable='yes'
  window->windowMovable = TRUE;
%else
  /* nothing to do because window is not movable */
%endif
}

%endif %- MakeWindowMovable
%-BW_METHOD_END MakeWindowMovable
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG EventCallbackMovableWindow
%define! Parelement
%define! Parkind
%define! ParpData
%include Common\GeneralInternalGlobal.inc (EventCallbackMovableWindow)
static void EventCallbackMovableWindow(%'ModuleName'_Element *element, %'ModuleName'_MsgKind kind, %'ModuleName'_Pvoid pData)
{
%if %movable='yes'
  if (element->prop.type == %@UI@'ModuleName'%.WIDGET_HEADER){   %>40/* only do something if header is clicked */
    bool update = FALSE;                                         %>40/* default no update needed */

    %'ModuleName'_WindowWidget *window = (%'ModuleName'_WindowWidget*) windowElement;
    %@UI@'ModuleName'%.Coordinate curCoord = *(%@UI@'ModuleName'%.Coordinate *)pData;
    %@UI@'ModuleName'%.PixelDim screenWidth = %@UI@'ModuleName'%.GetWidth();
    %@UI@'ModuleName'%.PixelDim screenHeight = %@UI@'ModuleName'%.GetHeight();
    if (kind == %@UI@'ModuleName'%.EVENT_CLICK) {
      window->clickCoord = *(%@UI@'ModuleName'%.Coordinate *)pData;
      window->clickCoord.x = window->clickCoord.x + window->element.prop.x;%>40/* transform to screen coordinates */
      window->clickCoord.y = window->clickCoord.y + window->element.prop.y;%>40/* transform to screen coordinates */
    } else if (kind == %@UI@'ModuleName'%.EVENT_CLICK_MOVE){
      curCoord = *(%@UI@'ModuleName'%.Coordinate *)pData;        %>40/* window coordinates */
      curCoord.x = curCoord.x + window->element.prop.x;          %>40/* transform to screen coordinates */
      curCoord.y = curCoord.y + window->element.prop.y;          %>40/* transform to screen coordinates */

      /* check if moved window is inside screen */
      if ((window->element.prop.x + curCoord.x) > window->clickCoord.x){
        window->element.prop.x = (window->element.prop.x + curCoord.x) - window->clickCoord.x;
        update = TRUE;
      } else if (window->element.prop.x != 0){
        window->element.prop.x = 0;                              %>40/* no negative coordinates force x=0, window stays inside screen */
        update = TRUE;
      }
      if ((window->element.prop.y + curCoord.y) > window->clickCoord.y){
        window->element.prop.y = (window->element.prop.y + curCoord.y) - window->clickCoord.y;
        update = TRUE;
      } else if (window->element.prop.y != 0){
        window->element.prop.y = 0;                              %>40/* no negative coordinates force y=0, window stays inside screen */
        update = TRUE;
      }
      if ((window->element.prop.x + window->element.prop.width > screenWidth) && (window->element.prop.x != screenWidth - window->element.prop.width)){
        window->element.prop.x = screenWidth - window->element.prop.width;%>40 /* window width < screen width */
        update = TRUE;
      }
      if ((window->element.prop.y + window->element.prop.height > screenHeight) && (window->element.prop.y != screenHeight - window->element.prop.height)){
        window->element.prop.y = screenHeight - window->element.prop.height;%>40 /* window height < screen height */
        update = TRUE;
      }
      if (update){
        %@UI@'ModuleName'%.UpdateScreen(screen, TRUE);
        window->clickCoord = curCoord;                           %>40/* update coordinates, if window was moved */
      }
    } /* end if click_move event */
  } /* end if header clicked */
%else
  (void)element;
  (void)kind;
  (void)pData;
%endif %- %movable='yes'
}

%-INTERNAL_METHOD_END EventCallbackMovableWindow
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetUserMsgHandler
%ifdef SetUserMsgHandler
%define! Parwindow
%define! Parhandler
%include Common\UIWindowSetUserMsgHandler.Inc
/*
void %'ModuleName'%.%SetUserMsgHandler(%'ModuleName'_WindowWidget *window, %@UI@'ModuleName'%.MsgHandler handler)
 ** This method is implemented as macro
*/

%endif %- SetUserMsgHandler
%-BW_METHOD_END SetUserMsgHandler
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetBackgroundColor
%ifdef SetBackgroundColor
%define! Parcolor
%define! Parwindow
%include Common\UIWindowSetBackgroundColor.Inc
/*
void %'ModuleName'%.%SetBackgroundColor(%'ModuleName'_Window *window, %'ModuleName'_PixelColor color)
 ** This method is implemented as macro
*/

%endif %- SetBackgroundColor
%-BW_METHOD_END SetBackgroundColor
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This bean is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
