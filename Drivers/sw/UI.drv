%-Driver generated by the Bean Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Bean Wizard
%- If you change these lines, Bean Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    25.09.2009
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%define! Description_ScreenMsgHandler Message handler for the screen
%define! Description_PaintScreen Draws all elements to the screen
%define! Description_SearchInsideElement search touched element in a sub tree
%define! Description_FctInsideElement check if coordinates are inside element
%define! Description_AddSubElement Adds a sub element 
%define! Description_AddNextElement Adds an element on the same level
%define! Description_RemoveElement Removes an element from the element tree. The user is responsible to  delete any elements in lower levels of the removed element. The User is also responsible to remove any used memory if needed. 
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\UISettings.Inc
%define! Abstract Common\UIAbstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited beans */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"

#ifndef NULL
  #define NULL ((void*)0)
#endif

%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"

typedef enum {                                                   %>40/* this lists all the different element types supported */
  %'ModuleName'_WIDGET_SPACE,                                    %>40/* generic rectangle space (transparent) */
  %'ModuleName'_WIDGET_SCREEN,                                   %>40/* screen element, top element */
  %'ModuleName'_WIDGET_WINDOW,                                   %>40/* window element */
  %'ModuleName'_WIDGET_HEADER,                                   %>40/* header on top of window */
  %'ModuleName'_WIDGET_BUTTON,                                   %>40/* button which can be pressed */
  %'ModuleName'_WIDGET_CHECKBOX,                                 %>40/* checkbox element (checked or unchecked) */
  %'ModuleName'_WIDGET_TEXT,                                     %>40/* text element (both static and dynamic text */
  %'ModuleName'_WIDGET_SCROLLMENU,                               %>40/* menu item which scrolls text on click. Similar like a drop down box. */
  %'ModuleName'_WIDGET_BARGRAPH,                                 %>40/* widget a bar graph*/
  %'ModuleName'_WIDGET_ICON,                                     %>40/* widget for an icon/symbol */
  %'ModuleName'_WIDGET_SLIDER                                    %>40/* widget for a slider */
} %'ModuleName'_ElementType;

typedef enum %'ModuleName'_MsgKind {                             %>40/* this lists all the different message types supported */
  %'ModuleName'_MSG_ELEMENT_SELECT,                              %>40/* message for selecting an element */
  %'ModuleName'_MSG_ELEMENT_DESELECT,                            %>40/* message for deselecting an element */
  %'ModuleName'_MSG_ELEMENT_MOVE_OUT,                            %>40/* message called if cursor moved out of an element */
  %'ModuleName'_MSG_ELEMENT_REMOVE,                              %>40/* message to the widget when it gets removed from UI */
  %'ModuleName'_MSG_WINDOW_CLOSE,                                %>40/* message for closing a window */
  %'ModuleName'_MSG_CLICK,                                       %>40/* message for pressing/click an element. */
  %'ModuleName'_MSG_CLICK_MOVE,                                  %>40/* message for moving cursor while clicked (e.g. with a touch screen). Passes %'ModuleName'_Coordinate as data argument in the message */
  %'ModuleName'_MSG_CLICK_RELEASE,                               %>40/* message for a short click release */
  /* widget messages */
  %'ModuleName'_MSG_WIDGET_RESIZE,                               %>40/* message to the widget to resize itself. Widget usually will da a recursive update. */
  %'ModuleName'_MSG_WIDGET_PAINT,                                %>40/* message to the widget to paint itself. The widget shall do a complete repaint. */
  %'ModuleName'_MSG_WIDGET_UPDATE,                               %>40/* message to the widget to update itself in case data has been changed. */
  /* slider specific */
  %'ModuleName'_MSG_SLIDER_VAL_CHANGE,
  /* display specific */
  %'ModuleName'_MSG_PRE_ORIENTATION_CHANGE,                      %>40/* message called before a display orientation change */
  %'ModuleName'_MSG_ORIENTATION_CHANGE,                          %>40/* message called after the orientation change, before doing an update */
  %'ModuleName'_MSG_POST_ORIENTATION_CHANGE,                     %>40/* message called after a display orientation change and update */
  %'ModuleName'_MSG_PAINT,                                       %>40/* message called for painting the element */
  /* starting point for widget specific messages */
  %'ModuleName'_MSG_LAST_PREFINED                                %>40/* last predefined message */
} %'ModuleName'_MsgKind;

/* callback/function pointer type used internally and for user events */
struct %'ModuleName'_Element; /* forward declaration, needed for type below */
typedef void (*%'ModuleName'_MsgHandler) (                       %>40/* event called for an element */
  %'ModuleName'_MsgKind eventKind,                               %>40/* kind of event */
  struct %'ModuleName'_Element *element,                         %>40/* element for the event */
  void *pData                                                    %>40/* optional data pointer */
);

%if SelectionEnabled='yes'
#define %'ModuleName'_CAN_SELECT_ELEMENTS  1                     %>40/* We can select elements (this will need some more resources) */
%else
#define %'ModuleName'_CAN_SELECT_ELEMENTS  0                     %>40/* We cannot select elements (using additional resources) */

%endif %- SelectElement
#define %'ModuleName'%.COLOR_BLACK              %@Display@'ModuleName'%.COLOR_BLACK           /* black color */
#define %'ModuleName'%.COLOR_WHITE              %@Display@'ModuleName'%.COLOR_WHITE           /* white color */
#define %'ModuleName'%.COLOR_RED                %@Display@'ModuleName'%.COLOR_RED             /* red color */
#define %'ModuleName'%.COLOR_BRIGHT_RED         %@Display@'ModuleName'%.COLOR_BRIGHT_RED      /* bright red color */
#define %'ModuleName'%.COLOR_DARK_RED           %@Display@'ModuleName'%.COLOR_DARK_RED        /* dark red color */
#define %'ModuleName'%.COLOR_GREEN              %@Display@'ModuleName'%.COLOR_GREEN           /* green color */
#define %'ModuleName'%.COLOR_DARK_GREEN         %@Display@'ModuleName'%.COLOR_DARK_GREEN      /* dark green color */
#define %'ModuleName'%.COLOR_BRIGHT_GREEN       %@Display@'ModuleName'%.COLOR_BRIGHT_GREEN    /* bright green color */
#define %'ModuleName'%.COLOR_BLUE               %@Display@'ModuleName'%.COLOR_BLUE            /* blue color */
#define %'ModuleName'%.COLOR_BRIGHT_BLUE        %@Display@'ModuleName'%.COLOR_BRIGHT_BLUE     /* bright blue color */
#define %'ModuleName'%.COLOR_DARK_BLUE          %@Display@'ModuleName'%.COLOR_DARK_BLUE       /* dark blue color */
#define %'ModuleName'%.COLOR_YELLOW             %@Display@'ModuleName'%.COLOR_YELLOW          /* yellow color */
#define %'ModuleName'%.COLOR_BRIGHT_YELLOW      %@Display@'ModuleName'%.COLOR_BRIGHT_YELLOW   /* bright yellow color */
#define %'ModuleName'%.COLOR_ORANGE             %@Display@'ModuleName'%.COLOR_ORANGE          /* orange color */
#define %'ModuleName'%.COLOR_GREY               %@Display@'ModuleName'%.COLOR_GREY            /* grey color */
#define %'ModuleName'%.COLOR_BRIGHT_GREY        %@Display@'ModuleName'%.COLOR_BRIGHT_GREY     /* bright grey color */

typedef %@Display@'ModuleName'%.PixelColor %'ModuleName'%.PixelColor;%>40/* type large enough to hold the color information */
typedef %@Display@'ModuleName'%.PixelDim   %'ModuleName'%.PixelDim;%>40/* type big enough to hold the x and y coordinates */
typedef GFONT_Callbacks   %'ModuleName'%.FontCallbacks;          %>40/* Callback to retrieve font information. */

/* wrappers for the low level display orientation enumeration and type */
typedef %@Display@'ModuleName'%.DisplayOrientation %'ModuleName'%.DisplayOrientation;
#define %'ModuleName'%.ORIENTATION_PORTRAIT     %@Display@'ModuleName'%.ORIENTATION_PORTRAIT
#define %'ModuleName'%.ORIENTATION_PORTRAIT180  %@Display@'ModuleName'%.ORIENTATION_PORTRAIT180
#define %'ModuleName'%.ORIENTATION_LANDSCAPE    %@Display@'ModuleName'%.ORIENTATION_LANDSCAPE
#define %'ModuleName'%.ORIENTATION_LANDSCAPE180 %@Display@'ModuleName'%.ORIENTATION_LANDSCAPE180
%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;

%- %define _OPTIMIZE_CLEARED_BACKGROUND /* if we shall optimize using the fact that the background has been filled with a color. Still experimental... */
%-
/* flags for elements */
#define %'ModuleName'_FLAGS_INIT            (0)                  %>40/* initial value of flags */
#define %'ModuleName'_FLAGS_NEEDS_REPAINT   (1<<0)               %>40/* element needs to be repainted */
#define %'ModuleName'_FLAGS_IS_MODAL        (1<<1)               %>40/* element is modal */
#define %'ModuleName'_FLAGS_ALIGN_RIGHT     (1<<2)               %>40/* element is right aligned */
%if SelectionEnabled='yes'
/* selection flags */
#define %'ModuleName'_FLAGS_CAN_SELECT      (1<<3)               %>40/* flag indicating that the element can be selected */
#define %'ModuleName'_FLAGS_IS_SELECTED     (1<<4)               %>40/* flag indicating that the element is selected */
#define %'ModuleName'_FLAGS_CLICKED         (1<<5)               %>40/* flag indicating that the element is clicked */
%endif

/* window flags */
#define %'ModuleName'_FLAGS_WINDOW_HAS_BORDER    (1<<6)          %>40/* window has a border */
%ifdef _OPTIMIZE_CLEARED_BACKGROUND
#define %'ModuleName'_FLAGS_WINDOW_BG_CLEARED    (1<<7)          %>40/* window just has been cleared with background color */

typedef uint16_t %'ModuleName'_ElementFlagsType;                 %>40/* type to hold all element flags */
%else

typedef uint8_t %'ModuleName'_ElementFlagsType;                  %>40/* type to hold all element flags */
%endif

/* --- Screen content: window, ... */
typedef struct %'ModuleName'_ElementProperties {                 %>40/* Common properties for elements */
  %'ModuleName'_ElementType type;                                %>40/* type of the element */
  %'ModuleName'_ElementFlagsType flags;                          %>40/* element flags */
  %'ModuleName'_PixelDim x;                                      %>40/* x coordinate */
  %'ModuleName'_PixelDim y;                                      %>40/* y coordinate */
  %'ModuleName'_PixelDim width;                                  %>40/* element width in pixels */
  %'ModuleName'_PixelDim height;                                 %>40/* element height in pixels */
  %'ModuleName'_PixelColor color;                                %>40/* color of element */
} %'ModuleName'_ElementProperties;

typedef void *%'ModuleName'_Pvoid;                               %>40/* pointer to void */

typedef struct {
  %'ModuleName'_PixelDim x;                                      %>40/* x coordinate */
  %'ModuleName'_PixelDim y;                                      %>40/* y coordinate */
} %'ModuleName'_Coordinate;

struct %'ModuleName'_Screen;                                     %>40/* forward declaration of screen widget */

/* --- Element --- */
typedef struct %'ModuleName'_Element {                           %>40/* This describes a generic UI element */
  %'ModuleName'_ElementProperties prop;                          %>40/* common properties of element */
  %'ModuleName'_MsgHandler msgHandler;                           %>40/* message handler for element */
  struct %'ModuleName'_Element *sub;                             %>40/* pointer to internal widget if needed */
  struct %'ModuleName'_Element *parent;
  struct %'ModuleName'_Element *next;                            %>40/* pointer to the next element in list */
} %'ModuleName'_Element;

/* --- Screen --- */
typedef struct  %'ModuleName'_Screen{                            %>40/* This is the abstraction of a generic window, with all the needed information. */
 %'ModuleName'_Element element;                                  %>40/* the base element */
 %'ModuleName'_Element *modalElement;                            %>40/* pointer to a modal element or NULL */
 %if SelectionEnabled='yes'
 %'ModuleName'_Element *selectedE;                               %>40/* pointer to the currently selected element */
 %endif
} %'ModuleName'_Screen;

typedef %'ModuleName'_Coordinate *%'ModuleName'_PCoordinate;     %>40/* Pointer to coordinate */
typedef struct %'ModuleName'_Element* %'ModuleName'%.PElement;   %>40/* Pointer to element */
typedef %'ModuleName'_Screen *%'ModuleName'%.PScreen;            %>40/* Pointer to Screen element. */
typedef bool (*%'ModuleName'_ElementFindFct)(%'ModuleName'_Element*, void*);%>40/* Function pointer for finding an element */
typedef byte (*%'ModuleName'_painterCallback) (%'ModuleName'_Element *element);%>40/* callback to be called to paint the element */
%-
%-BW_CUSTOM_USERTYPE_END

%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN UpdateElement
%ifdef UpdateElement
void %'ModuleName'%.%UpdateElement(%'ModuleName'_Element *parent, %'ModuleName'_Element *element);
%define! Parelement
%define! Parparent
%include Common\UIUpdateElement.Inc

%endif %- UpdateElement
%-BW_METHOD_END UpdateElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN SelectElement
%ifdef SelectElement
void %'ModuleName'%.%SelectElement(%'ModuleName'_Screen *screen, %'ModuleName'_Element *window, %'ModuleName'_Element *element);
%define! Parwindow
%define! Parelement
%define! Parscreen
%include Common\UISelectElement.Inc

%endif %- SelectElement
%-BW_METHOD_END SelectElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN SelectNextElement
%ifdef SelectNextElement
void %'ModuleName'%.%SelectNextElement(%'ModuleName'_Screen *screen, bool forward);
%define! Parforward
%define! Parscreen
%include Common\UISelectNextElement.Inc

%endif %- SelectNextElement
%-BW_METHOD_END SelectNextElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN EnableElementSelection
%ifdef EnableElementSelection
#define %'ModuleName'%.%EnableElementSelection(elem) \
%if SelectionEnabled='yes'
  ((%'ModuleName'_Element*)elem)->prop.flags |= %'ModuleName'_FLAGS_CAN_SELECT%>40/* indicate that we can select the element */
%else
  /* do nothing, as selection is disabled in the settings */
%endif

%define! Parelem
%include Common\UIEnableElementSelection.Inc

%endif %- EnableElementSelection
%-BW_METHOD_END EnableElementSelection
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetElementWidth
%ifdef GetElementWidth
#define %'ModuleName'%.%GetElementWidth(element) \
  ((%'ModuleName'_Element*)element)->prop.width

%define! Parelement
%define! RetVal
%include Common\UIGetElementWidth.Inc

%endif %- GetElementWidth
%-BW_METHOD_END GetElementWidth
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetElementHeight
%ifdef GetElementHeight
#define %'ModuleName'%.%GetElementHeight(element) \
  ((%'ModuleName'_Element*)element)->prop.height

%define! Parelement
%define! RetVal
%include Common\UIGetElementHeight.Inc

%endif %- GetElementHeight
%-BW_METHOD_END GetElementHeight
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetElementPosX
%ifdef GetElementPosX
#define %'ModuleName'%.%GetElementPosX(element)\
  ((%'ModuleName'_Element*)element)->prop.x

%define! Parelement
%define! RetVal
%include Common\UIGetElementPosX.Inc

%endif %- GetElementPosX
%-BW_METHOD_END GetElementPosX
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetElementPosY
%ifdef GetElementPosY
#define %'ModuleName'%.%GetElementPosY(element)\
  ((%'ModuleName'_Element*)element)->prop.y

%define! Parelement
%define! RetVal
%include Common\UIGetElementPosY.Inc

%endif %- GetElementPosY
%-BW_METHOD_END GetElementPosY
%-************************************************************************************************************
%-************************************************************************************************************
%-BW_METHOD_BEGIN CreateScreen
%ifdef CreateScreen
void %'ModuleName'%.%CreateScreen(%'ModuleName'_Screen *screen, %'ModuleName'_PixelColor bgColor);
%define! Parscreen
%define! ParbgColor
%include Common\UICreateScreen.Inc

%endif %- CreateScreen
%-BW_METHOD_END CreateScreen
%-************************************************************************************************************
%-BW_METHOD_BEGIN UpdateScreen
%ifdef UpdateScreen
void %'ModuleName'%.%UpdateScreen(%'ModuleName'_Screen *screen, bool updateAll);
%define! Parscreen
%define! ParupdateAll
%include Common\UIUpdateScreen.Inc

%endif %- UpdateScreen
%-BW_METHOD_END UpdateScreen
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawFilledBox
%ifdef DrawFilledBox
void %'ModuleName'%.%DrawFilledBox(%'ModuleName'_Element *element, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim w, %'ModuleName'_PixelDim h, %'ModuleName'_PixelColor color);

%define! Parx
%define! Pary
%define! Parw
%define! Parh
%define! Parcolor
%define! Parelement
%include Common\UIDrawFilledBox.Inc

%endif %- DrawFilledBox
%-BW_METHOD_END DrawFilledBox
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawBox
%ifdef DrawBox
void %'ModuleName'%.%DrawBox(%'ModuleName'_Element *element, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim w, %'ModuleName'_PixelDim h, %'ModuleName'_PixelDim lineWidth, %'ModuleName'_PixelColor color);
%define! Parx
%define! Pary
%define! Parw
%define! Parh
%define! ParlineWidth
%define! Parcolor
%define! Parelement
%include Common\UIDrawBox.Inc

%endif %- DrawBox
%-BW_METHOD_END DrawBox
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawLine
%ifdef DrawLine
void %'ModuleName'%.%DrawLine(%'ModuleName'_Element *element, %'ModuleName'_PixelDim x0, %'ModuleName'_PixelDim y0, %'ModuleName'_PixelDim x1, %'ModuleName'_PixelDim y1, %'ModuleName'_PixelColor color);
%define! Parx0
%define! Pary0
%define! Parx1
%define! Pary1
%define! Parcolor
%define! Parelement
%include Common\UIDrawLine.Inc

%endif %- DrawLine
%-BW_METHOD_END DrawLine
%-************************************************************************************************************
%-BW_METHOD_BEGIN DeselectElement
%ifdef DeselectElement
void %'ModuleName'%.%DeselectElement(%'ModuleName'_Screen *screen, %'ModuleName'_Element *window, %'ModuleName'_Element *element);
%define! Parscreen
%define! Parwindow
%define! Parelement
%include Common\UIDeselectElement.Inc

%endif %- DeselectElement
%-BW_METHOD_END DeselectElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetElementColor
%ifdef SetElementColor
void %'ModuleName'%.%SetElementColor(%'ModuleName'_Element *element, %'ModuleName'_PixelColor color);
%define! Parcolor
%define! Parelement
%include Common\UISetElementColor.Inc

%endif %- SetElementColor
%-BW_METHOD_END SetElementColor
%-************************************************************************************************************
%-BW_METHOD_BEGIN ElementInitCommon
%ifdef ElementInitCommon
void %'ModuleName'%.%ElementInitCommon(%'ModuleName'_Element *element, %'ModuleName'_ElementType type, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim width, %'ModuleName'_PixelDim height, %'ModuleName'_PixelColor bgColor, %'ModuleName'_MsgHandler handler);
%define! Parelement
%define! Partype
%define! Parx
%define! Pary
%define! Parwidth
%define! Parheight
%define! ParbgColor
%define! Parhandler
%include Common\UIElementInitCommon.Inc

%endif %- ElementInitCommon
%-BW_METHOD_END ElementInitCommon
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetScreen
%ifdef GetScreen
%'ModuleName'_PScreen %'ModuleName'%.%GetScreen(void);
%define! RetVal
%include Common\UIGetScreen.Inc

%endif %- GetScreen
%-BW_METHOD_END GetScreen
%-************************************************************************************************************
%-BW_METHOD_BEGIN EqualElement
%ifdef EqualElement
#define %'ModuleName'%.%EqualElement(elem1, elem2) \
  ((elem1)==&((elem2)->element))
%define! Parelem1
%define! Parelem2
%define! RetVal
%include Common\UIEqualElement.Inc

%endif %- EqualElement
%-BW_METHOD_END EqualElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetSelectedElement
%ifdef GetSelectedElement
bool %'ModuleName'%.%GetSelectedElement(%'ModuleName'_Screen *screen, %'ModuleName'_PElement *pElement);
%define! Parscreen
%define! ParpElement
%define! RetVal
%include Common\UIGetSelectedElement.Inc

%endif %- GetSelectedElement
%-BW_METHOD_END GetSelectedElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN FindElement
%ifdef FindElement
bool %'ModuleName'%.%FindElement(%'ModuleName'_Element *startElement, %'ModuleName'_PElement *pElement, %'ModuleName'_ElementFindFct compare, %'ModuleName'_Pvoid data);
%define! ParpElement
%define! Parcompare
%define! Pardata
%define! ParstartElement
%define! RetVal
%include Common\UIFindElement.Inc

%endif %- FindElement
%-BW_METHOD_END FindElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetDisplayOrientation
%ifdef GetDisplayOrientation
%-BW_PUBLISH_MACRO
#define %'ModuleName'%.%GetDisplayOrientation %@Display@'ModuleName'%.%GetDisplayOrientation
%define! RetVal
%include Common\UIGetDisplayOrientation.Inc

%endif %- GetDisplayOrientation
%-BW_METHOD_END GetDisplayOrientation
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetWidth
%ifdef GetWidth
%-BW_PUBLISH_MACRO
#define %'ModuleName'%.%GetWidth %@Display@'ModuleName'%.%GetWidth
%define! RetVal
%include Common\UIGetWidth.Inc

%endif %- GetWidth
%-BW_METHOD_END GetWidth
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetHeight
%ifdef GetHeight
%-BW_PUBLISH_MACRO
#define %'ModuleName'%.%GetHeight %@Display@'ModuleName'%.%GetHeight
%define! RetVal
%include Common\UIGetHeight.Inc

%endif %- GetHeight
%-BW_METHOD_END GetHeight
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetDisplayOrientation
%ifdef SetDisplayOrientation
void %'ModuleName'%.%SetDisplayOrientation(%'ModuleName'_DisplayOrientation newOrientation);
%define! ParnewOrientation
%include Common\UISetDisplayOrientation.Inc

%endif %- SetDisplayOrientation
%-BW_METHOD_END SetDisplayOrientation
%-************************************************************************************************************
%-BW_METHOD_BEGIN UpdateElementNoRefresh
%ifdef UpdateElementNoRefresh
void %'ModuleName'%.%UpdateElementNoRefresh(%'ModuleName'_Element *parent, %'ModuleName'_Element *element, bool updateAll);
%define! Parelement
%define! ParupdateAll
%define! Parparent
%include Common\UIUpdateElementNoRefresh.Inc

%endif %- UpdateElementNoRefresh
%-BW_METHOD_END UpdateElementNoRefresh
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG AddSubElement
byte %'ModuleName'%.AddSubElement(%'ModuleName'_Element *parentElement, %'ModuleName'_Element *subElement);
%define! ParparentElement
%define! ParsubElement
%define! RetVal
%include Common\GeneralInternal.inc (AddSubElement)

%-INTERNAL_METHOD_END AddSubElement
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG AddNextElement
byte %'ModuleName'%.AddNextElement(%'ModuleName'_Element *currentElement, %'ModuleName'_Element *nextElement);
%define! ParcurrentElement
%define! ParnextElement
%define! RetVal
%include Common\GeneralInternal.inc (AddNextElement)

%-INTERNAL_METHOD_END AddNextElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawCircle
%ifdef DrawCircle
void %'ModuleName'%.%DrawCircle(%'ModuleName'_Element *element, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim radius, %'ModuleName'_PixelColor color);
%define! Parelement
%define! Parx
%define! Pary
%define! Parradius
%define! Parcolor
%include Common\UIDrawCircle.Inc

%endif %- DrawCircle
%-BW_METHOD_END DrawCircle
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawFilledCircle
%ifdef DrawFilledCircle
void %'ModuleName'%.%DrawFilledCircle(%'ModuleName'_Element *element, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim radius, %'ModuleName'_PixelColor color);
%define! Parelement
%define! Parx
%define! Pary
%define! Parradius
%define! Parcolor
%include Common\UIDrawFilledCircle.Inc

%endif %- DrawFilledCircle
%-BW_METHOD_END DrawFilledCircle
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG RemoveElement
byte %'ModuleName'%.RemoveElement(%'ModuleName'_Element *element);
%define! Parelement
%define! RetVal
%include Common\GeneralInternal.inc (RemoveElement)

%-INTERNAL_METHOD_END RemoveElement
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG SearchInsideElement
bool %'ModuleName'%.SearchInsideElement(%'ModuleName'_PElement *pElement, %'ModuleName'_Coordinate *coord);
%define! Parcoord
%define! ParpElement
%define! RetVal
%include Common\GeneralInternal.inc (SearchInsideElement)

%-INTERNAL_METHOD_END SearchInsideElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetScreenPosX
%ifdef GetScreenPosX
%'ModuleName'_PixelDim %'ModuleName'%.%GetScreenPosX(%'ModuleName'_Element *element);
%define! Parelement
%define! RetVal
%include Common\UIGetScreenPosX.Inc

%endif %- GetScreenPosX
%-BW_METHOD_END GetScreenPosX
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetScreenPosY
%ifdef GetScreenPosY
%'ModuleName'_PixelDim %'ModuleName'%.%GetScreenPosY(%'ModuleName'_Element *element);
%define! Parelement
%define! RetVal
%include Common\UIGetScreenPosY.Inc

%endif %- GetScreenPosY
%-BW_METHOD_END GetScreenPosY
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawHLine
%ifdef DrawHLine
void %'ModuleName'%.%DrawHLine(%'ModuleName'_Element *element, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim w, %'ModuleName'_PixelColor color);
%define! Parelement
%define! Parx
%define! Pary
%define! Parw
%define! Parcolor
%include Common\UIDrawHLine.Inc

%endif %- DrawHLine
%-BW_METHOD_END DrawHLine
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawVLine
%ifdef DrawVLine
void %'ModuleName'%.%DrawVLine(%'ModuleName'_Element *element, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim h, %'ModuleName'_PixelColor color);
%define! Parelement
%define! Parx
%define! Pary
%define! Parh
%define! Parcolor
%include Common\UIDrawVLine.Inc

%endif %- DrawVLine
%-BW_METHOD_END DrawVLine
%-************************************************************************************************************
%-BW_METHOD_BEGIN NextElement
%ifdef NextElement
void %'ModuleName'%.%NextElement(%'ModuleName'_PElement *ppElement, %'ModuleName'_Element *stopElement);
%define! ParppElement
%define! ParstopElement
%include Common\UINextElement.Inc

%endif %- NextElement
%-BW_METHOD_END NextElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrevElement
%ifdef PrevElement
void %'ModuleName'%.%PrevElement(%'ModuleName'_PElement *ppElement, %'ModuleName'_Element *stopElement);
%define! ParppElement
%define! ParstopElement
%include Common\UIPrevElement.Inc

%endif %- PrevElement
%-BW_METHOD_END PrevElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN AlignElementRight
%ifdef AlignElementRight
byte %'ModuleName'%.%AlignElementRight(%'ModuleName'_Element *element);
%define! Parelement
%define! RetVal
%include Common\UIAlignElementRight.Inc

%endif %- AlignElementRight
%-BW_METHOD_END AlignElementRight
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetElementAbsolutePos
%ifdef GetElementAbsolutePos
byte %'ModuleName'%.%GetElementAbsolutePos(%'ModuleName'_Element *elem, %'ModuleName'_PixelDim *xp, %'ModuleName'_PixelDim *yp);
%define! Parelem
%define! Parxp
%define! Paryp
%define! RetVal
%include Common\UIGetElementAbsolutePos.Inc

%endif %- GetElementAbsolutePos
%-BW_METHOD_END GetElementAbsolutePos
%-************************************************************************************************************
%-BW_METHOD_BEGIN CoordinateInsideElement
%ifdef CoordinateInsideElement
bool %'ModuleName'%.%CoordinateInsideElement(%'ModuleName'_Coordinate *coord, %'ModuleName'_Element *element);
%define! Parcoord
%define! Parelement
%define! RetVal
%include Common\UICoordinateInsideElement.Inc

%endif %- CoordinateInsideElement
%-BW_METHOD_END CoordinateInsideElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN MsgSendListRecursiveBottomUp
%ifdef MsgSendListRecursiveBottomUp
void %'ModuleName'%.%MsgSendListRecursiveBottomUp(%'ModuleName'_Element *element, %'ModuleName'_MsgKind kind, %'ModuleName'_Pvoid pData);
%define! Parelement
%define! Parkind
%define! ParpData
%include Common\UIMsgSendListRecursiveBottomUp.Inc

%endif %- MsgSendListRecursiveBottomUp
%-BW_METHOD_END MsgSendListRecursiveBottomUp
%-************************************************************************************************************
%-BW_METHOD_BEGIN ProcessTouch
%ifdef ProcessTouch
void %'ModuleName'%.%ProcessTouch(bool touched, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y);
%define! Partouched
%define! Parx
%define! Pary
%include Common\UIProcessTouch.Inc

%endif %- ProcessTouch
%-BW_METHOD_END ProcessTouch
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendMessage
%ifdef SendMessage
void %'ModuleName'%.%SendMessage(%'ModuleName'_MsgKind kind, %'ModuleName'_Element *element, %'ModuleName'_Pvoid pData);
%define! Parelement
%define! Parkind
%define! ParpData
%include Common\UISendMessage.Inc

%endif %- SendMessage
%-BW_METHOD_END SendMessage
%-************************************************************************************************************
%-BW_METHOD_BEGIN MarkElementModal
%ifdef MarkElementModal
byte %'ModuleName'%.%MarkElementModal(%'ModuleName'_Element *element);
%define! Parelement
%define! RetVal
%include Common\UIMarkElementModal.Inc

%endif %- MarkElementModal
%-BW_METHOD_END MarkElementModal
%-************************************************************************************************************
%-BW_METHOD_BEGIN UnMarkElementModal
%ifdef UnMarkElementModal
byte %'ModuleName'%.%UnMarkElementModal(%'ModuleName'_Element *element);
%define! Parelement
%define! RetVal
%include Common\UIUnMarkElementModal.Inc

%endif %- UnMarkElementModal
%-BW_METHOD_END UnMarkElementModal
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetRoot
%ifdef GetRoot
%'ModuleName'_PElement %'ModuleName'%.%GetRoot(void);
%define! RetVal
%include Common\UIGetRoot.Inc

%endif %- GetRoot
%-BW_METHOD_END GetRoot
%-************************************************************************************************************
%-BW_METHOD_BEGIN ElementFullyVisible
%ifdef ElementFullyVisible
bool %'ModuleName'%.%ElementFullyVisible(%'ModuleName'_Element *element);
%define! Parelement
%define! RetVal
%include Common\UIElementFullyVisible.Inc

%endif %- ElementFullyVisible
%-BW_METHOD_END ElementFullyVisible
%-************************************************************************************************************
%-BW_METHOD_BEGIN MsgPaintAllElements
%ifdef MsgPaintAllElements
void %'ModuleName'%.%MsgPaintAllElements(%'ModuleName'_Element *rootElement);
%define! ParrootElement
%include Common\UIMsgPaintAllElements.Inc

%endif %- MsgPaintAllElements
%-BW_METHOD_END MsgPaintAllElements
%-************************************************************************************************************
%-BW_METHOD_BEGIN MsgUpdateAllElements
%ifdef MsgUpdateAllElements
void %'ModuleName'%.%MsgUpdateAllElements(%'ModuleName'_Element *rootElement);
%define! ParrootElement
%include Common\UIMsgUpdateAllElements.Inc

%endif %- MsgUpdateAllElements
%-BW_METHOD_END MsgUpdateAllElements
%-************************************************************************************************************
%-BW_METHOD_BEGIN MsgSendListRecursiveTopDown
%ifdef MsgSendListRecursiveTopDown
void %'ModuleName'%.%MsgSendListRecursiveTopDown(%'ModuleName'_Element *element, %'ModuleName'_MsgKind kind, %'ModuleName'_Pvoid pData);
%define! Parelement
%define! Parkind
%define! ParpData
%include Common\UIMsgSendListRecursiveTopDown.Inc

%endif %- MsgSendListRecursiveTopDown
%-BW_METHOD_END MsgSendListRecursiveTopDown
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetElementPosLeft
%ifdef GetElementPosLeft
#define %'ModuleName'%.%GetElementPosLeft(element) \
  %'ModuleName'%.%GetElementPosX(element)

%define! Parelement
%define! RetVal
%include Common\UIGetElementPosLeft.Inc

%endif %- GetElementPosLeft
%-BW_METHOD_END GetElementPosLeft
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetElementPosRight
%ifdef GetElementPosRight
#define %'ModuleName'%.%GetElementPosRight(element) \
  ((%'ModuleName'_PixelDim)(%'ModuleName'%.%GetElementPosX(element)+%'ModuleName'%.%GetElementWidth(element)))

%define! Parelement
%define! RetVal
%include Common\UIGetElementPosRight.Inc

%endif %- GetElementPosRight
%-BW_METHOD_END GetElementPosRight
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetElementPosTop
%ifdef GetElementPosTop
#define %'ModuleName'%.%GetElementPosTop(element) \
  %'ModuleName'%.%GetElementPosY(element)

%define! Parelement
%define! RetVal
%include Common\UIGetElementPosTop.Inc

%endif %- GetElementPosTop
%-BW_METHOD_END GetElementPosTop
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetElementPosBottom
%ifdef GetElementPosBottom
#define %'ModuleName'%.%GetElementPosBottom(element) \
  ((%'ModuleName'_PixelDim)(%'ModuleName'%.%GetElementPosY(element)+%'ModuleName'%.%GetElementHeight(element)))

%define! Parelement
%define! RetVal
%include Common\UIGetElementPosBottom.Inc

%endif %- GetElementPosBottom
%-BW_METHOD_END GetElementPosBottom
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetUI
%ifdef GetUI
void %'ModuleName'%.%GetUI(void);
%include Common\UIGetUI.Inc

%endif %- GetUI
%-BW_METHOD_END GetUI
%-************************************************************************************************************
%-BW_METHOD_BEGIN GiveUI
%ifdef GiveUI
void %'ModuleName'%.%GiveUI(void);
%include Common\UIGiveUI.Inc

%endif %- GiveUI
%-BW_METHOD_END GiveUI
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
void %'ModuleName'%.%Init(void);
%include Common\UIInit.Inc

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
void %'ModuleName'%.%Deinit(void);
%include Common\UIDeinit.Inc

%endif %- Deinit
%-BW_METHOD_END Deinit
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_METHOD_BEGIN OnEvent
%ifdef OnEvent
%INTERFACE OnEvent
void %OnEvent(%'ModuleName'_Screen *screen, %'ModuleName'_Element *window, %'ModuleName'_Element *element, %'ModuleName'_MsgKind event);
%define! Parscreen
%define! Parwindow
%define! Parelement
%define! Parevent
%include Common\UIOnEvent.Inc

%endif %- OnEvent
%-BW_METHOD_END OnEvent
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\UISettings.Inc
%define! Abstract Common\UIAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"

%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
static %'ModuleName'%.Screen *currentScreen;                     %>40/* current screen */
%if RTOSenabled='yes'
static xSemaphoreHandle UISem = NULL; /* Semaphore to protect UI access */
%endif

%-
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-UNLOCKED
/* Internal method prototypes */
%-INTERNAL_LOC_METHOD_BEG ScreenMsgHandler
static void ScreenMsgHandler(%'ModuleName'_MsgKind kind, %'ModuleName'_Element *element, %'ModuleName'_Pvoid pData);
%-INTERNAL_LOC_METHOD_END ScreenMsgHandler
%-INTERNAL_LOC_METHOD_BEG PaintScreen
static byte PaintScreen(%'ModuleName'_Element *element);
%-INTERNAL_LOC_METHOD_END PaintScreen
%-INTERNAL_LOC_METHOD_BEG FctInsideElement
static bool FctInsideElement(%'ModuleName'_Element *element, %'ModuleName'_Coordinate *coord);
%-INTERNAL_LOC_METHOD_END FctInsideElement
%-

%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN ElementInitCommon
%ifdef ElementInitCommon
%define! Parelement
%define! Partype
%define! Parx
%define! Pary
%define! Parwidth
%define! Parheight
%define! ParbgColor
%define! Parhandler
%include Common\UIElementInitCommon.Inc
void %'ModuleName'%.%ElementInitCommon(%'ModuleName'_Element *element, %'ModuleName'_ElementType type, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim width, %'ModuleName'_PixelDim height, %'ModuleName'_PixelColor bgColor, %'ModuleName'_MsgHandler handler)
{
  element->prop.type = type;
  element->prop.x = x;
  element->prop.y = y;
  element->prop.width = width;
  element->prop.height = height;
  element->prop.color = bgColor;
  element->prop.flags = %'ModuleName'_FLAGS_INIT;                %>40/* initialize flags */
  element->msgHandler = handler;
  element->sub = NULL;                                           %>40/* default widget contains no subwidgets */
  element->parent = NULL;                                        %>40/* default widget has no parent */
  element->next = NULL;
  element->prop.flags = %'ModuleName'_FLAGS_NEEDS_REPAINT;       %>40/* after creation the element needs to be repainted */
}

%endif %- ElementInitCommon
%-BW_METHOD_END ElementInitCommon
%-************************************************************************************************************
%-BW_METHOD_BEGIN UpdateElement
%ifdef UpdateElement
%define! Parelement
%define! Parparent
%include Common\UIUpdateElement.Inc
void %'ModuleName'%.%UpdateElement(%'ModuleName'_Element *parent, %'ModuleName'_Element *element)
{
  %'ModuleName'%.%UpdateElementNoRefresh(parent, element, TRUE);
  %@Display@'ModuleName'%.UpdateRegion(element->prop.x, element->prop.y, element->prop.width, element->prop.height);
}

%endif %- UpdateElement
%-BW_METHOD_END UpdateElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN EnableElementSelection
%ifdef EnableElementSelection
%define! Parelem
%include Common\UIEnableElementSelection.Inc
#if 0
void %'ModuleName'%.%EnableElementSelection(%'ModuleName'_Element *elem)
{
  /* method is implemented as macro in the header file */
}
#endif

%endif %- EnableElementSelection
%-BW_METHOD_END EnableElementSelection
%-************************************************************************************************************
%-BW_METHOD_BEGIN SelectNextElement
%ifdef SelectNextElement
%define! Parforward
%define! Parscreen
%include Common\UISelectNextElement.Inc
void %'ModuleName'%.%SelectNextElement(%'ModuleName'_Screen *screen, bool forward)
{
%if SelectionEnabled='yes'
  %'ModuleName'_Element *currElement, *e;                        %>40/* currently selected element */
  %'ModuleName'_Element *window;                                 %>40/* window of currently selected element */
  %'ModuleName'_Element *startElement;                           %>40/* starting element of iteration */

  if (screen == NULL) {                                          %>40/* no screen at all? */
    return;
  }

  /* search window , to be removed?*/
  while (e != NULL && e->parent != NULL){
    if (e->prop.type == %'ModuleName'_WIDGET_WINDOW){
      window = e->parent;                                        %>40/* found window */
    }
    else {
      window = NULL;                                             %>40/* no window element */
    }
    e = e->parent;
  }

  if (%'ModuleName'%.%GetSelectedElement(screen, &startElement)){%>40/* we have an element already selected */
    %'ModuleName'%.DeselectElement(screen, window, startElement);
  } else {
    startElement = screen->element.sub;                          %>40/* we have no current selected element: use first in chain */
  }

  currElement = startElement;
  for(;;) {
    if (forward) {
      %'ModuleName'%.%NextElement(&currElement, NULL);           %>40/* select next element, we will go forward */
    } else {
      %'ModuleName'%.%PrevElement(&currElement, NULL);           %>40/* select previous element, we will go backward */
    }
    if (currElement == NULL) {                                   %>40/* no element at all? */
      break;
    }
    if (currElement == startElement) {                           %>40/* wrap over, no element to select? */
      break;
    }
    if (currElement->prop.flags&%'ModuleName'_FLAGS_CAN_SELECT) {%>40/* ok, can select element: break out of loop */
      break;
    }
  } /* for */                                                    %>40/* iterate elements */
  if (currElement != NULL &&(currElement->prop.flags&%'ModuleName'_FLAGS_CAN_SELECT)) {
    %'ModuleName'%.%SelectElement(screen, window, currElement);
  }
%else
  (void)window; (void)forward;
  /* do nothing, as selection is not enabled in the bean properties */
%endif
}

%endif %- SelectNextElement
%-BW_METHOD_END SelectNextElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN SelectElement
%ifdef SelectElement
%define! Parwindow
%define! Parelement
%define! Parscreen
%include Common\UISelectElement.Inc
void %'ModuleName'%.%SelectElement(%'ModuleName'_Screen *screen, %'ModuleName'_Element *window, %'ModuleName'_Element *element)
{
%if SelectionEnabled='yes'
  if (element!=NULL) {
    if (   (element->prop.flags&%'ModuleName'_FLAGS_CAN_SELECT)  %>40/* element can be selected */
        && !(element->prop.flags&%'ModuleName'_FLAGS_IS_SELECTED)%>40/* element is not currently selected */
       )
    {
      %if defined(OnEvent)
      %OnEvent(screen, window, element, %'ModuleName'_MSG_ELEMENT_SELECT);%>40/* call user event */
      %endif
      element->prop.flags |= (%'ModuleName'_FLAGS_IS_SELECTED|%'ModuleName'_FLAGS_NEEDS_REPAINT);%>40/* select element, and it needs a repaint */
      screen->selectedE = element;
      %'ModuleName'%.%UpdateElement(window, screen->selectedE);  %>40/* element needs update */
    }
  }
%else
  (void)screen; (void)window; (void)element;
  /* do nothing, as selection is not enabled in the bean properties */
%endif
}

%endif %- SelectElement
%-BW_METHOD_END SelectElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN DeselectElement
%ifdef DeselectElement
%define! Parscreen
%define! Parwindow
%define! Parelement
%include Common\UIDeselectElement.Inc
void %'ModuleName'%.%DeselectElement(%'ModuleName'_Screen *screen, %'ModuleName'_Element *window, %'ModuleName'_Element *element)
{
  if (element!=NULL) {
    if (element->prop.flags&%'ModuleName'_FLAGS_IS_SELECTED) {   %>40/* element is currently selected */
      %if defined(OnEvent)
      %OnEvent(screen, window, element, %'ModuleName'_MSG_ELEMENT_DESELECT);%>40/* call user event */
      %endif

      if (element->msgHandler != NULL) { /* call element deselect handler if there is any */
        element->msgHandler(%'ModuleName'_MSG_ELEMENT_DESELECT, element, NULL);
      }
      element->prop.flags &= ~%'ModuleName'_FLAGS_IS_SELECTED;   %>40/* unselect current selected element */
      element->prop.flags |= %'ModuleName'_FLAGS_NEEDS_REPAINT;  %>40/* need to repaint element */
      %'ModuleName'%.%UpdateElement(window, element);
      screen->selectedE = NULL;                                  %>40/* no currently selected element */
    }
  }
}

%endif %- DeselectElement
%-BW_METHOD_END DeselectElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetElementWidth
%ifdef GetElementWidth
%define! Parelement
%define! RetVal
%include Common\UIGetElementWidth.Inc
#if 0
%'ModuleName'_PixelDim %'ModuleName'%.%GetElementWidth(%'ModuleName'_Element *element)
{
  /* method is implemented as macro in the header file */
}
#endif

%endif %- GetElementWidth
%-BW_METHOD_END GetElementWidth
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetElementHeight
%ifdef GetElementHeight
%define! Parelement
%define! RetVal
%include Common\UIGetElementHeight.Inc
#if 0
%'ModuleName'_PixelDim %'ModuleName'%.%GetElementHeight(%'ModuleName'_Element *element)
{
  /* method is implemented as macro in the header file */
}
#endif

%endif %- GetElementHeight
%-BW_METHOD_END GetElementHeight
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetElementPosX
%ifdef GetElementPosX
%define! Parelement
%define! RetVal
%include Common\UIGetElementPosX.Inc
#if 0
%'ModuleName'_PixelDim %'ModuleName'%.%GetElementPosX(%'ModuleName'_Element *element)
{
  /* method is implemented as macro in the header file */
}
#endif

%endif %- GetElementPosX
%-BW_METHOD_END GetElementPosX
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetElementPosY
%ifdef GetElementPosY
%define! Parelement
%define! RetVal
%include Common\UIGetElementPosY.Inc
#if 0
%'ModuleName'_PixelDim %'ModuleName'%.%GetElementPosY(%'ModuleName'_Element *element)
{
  /* method is implemented as macro in the header file */
}
#endif

%endif %- GetElementPosY
%-BW_METHOD_END GetElementPosY
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG ScreenMsgHandler
%define! Parkind
%define! Parelement
%define! ParpData
%include Common\GeneralInternalGlobal.inc (ScreenMsgHandler)
static void ScreenMsgHandler(%'ModuleName'_MsgKind kind, %'ModuleName'_Element *element, %'ModuleName'_Pvoid pData)
{
  (void)pData; /* unused argument */
  if (kind==%'ModuleName'_MSG_WIDGET_PAINT) {
    (void)PaintScreen(element);
  }
}

%-INTERNAL_METHOD_END ScreenMsgHandler
%-************************************************************************************************************
%-BW_METHOD_BEGIN CreateScreen
%ifdef CreateScreen
%define! Parscreen
%define! ParbgColor
%include Common\UICreateScreen.Inc
void %'ModuleName'%.%CreateScreen(%'ModuleName'_Screen *screen, %'ModuleName'_PixelColor bgColor)
{
  %'ModuleName'%.ElementInitCommon((%'ModuleName'%.Element*)screen, %'ModuleName'_WIDGET_SCREEN,
    0, 0, %'ModuleName'%.%GetWidth(), %'ModuleName'%.%GetHeight(), bgColor, ScreenMsgHandler);
%if SelectionEnabled='yes'
  screen->selectedE = NULL;
%endif
  screen->element.prop.flags |= %'ModuleName'_FLAGS_NEEDS_REPAINT;%>40 /* screen needs to be repainted */
  currentScreen = screen;
}

%endif %- CreateScreen
%-BW_METHOD_END CreateScreen
%-************************************************************************************************************
%-BW_METHOD_BEGIN UpdateScreen
%ifdef UpdateScreen
%define! Parscreen
%define! ParupdateAll
%include Common\UIUpdateScreen.Inc
void %'ModuleName'%.%UpdateScreen(%'ModuleName'_Screen *screen, bool updateAll)
{
  if (updateAll){
    screen->element.prop.flags |= %'ModuleName'_FLAGS_NEEDS_REPAINT;%>40/* force complete update */
  }
  (void)PaintScreen((%'ModuleName'_Element*)screen);
}

%endif %- UpdateScreen
%-BW_METHOD_END UpdateScreen
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawFilledBox
%ifdef DrawFilledBox
%define! Parx
%define! Pary
%define! Parw
%define! Parh
%define! Parcolor
%define! Parelement
%include Common\UIDrawFilledBox.Inc
void %'ModuleName'%.%DrawFilledBox(%'ModuleName'_Element *element, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim w, %'ModuleName'_PixelDim h, %'ModuleName'_PixelColor color)
{
%ifdef _OPTIMIZE_CLEARED_BACKGROUND
  if ((window->flags&%'ModuleName'_FLAGS_WINDOW_BG_CLEARED) && color==window->prop.color) {
    /* nothing to do, as window background just has been cleared with our color */
  } else {
    %@Display@'ModuleName'%.DrawFilledBox((%'ModuleName'_PixelDim)(%'ModuleName'%.%GetScreenPosX(element)+x), (%'ModuleName'_PixelDim)(%'ModuleName'%.%GetScreenPosY(element)+y), w, h, color);
  }
%else
  %@Display@'ModuleName'%.DrawFilledBox((%'ModuleName'_PixelDim)(%'ModuleName'%.%GetScreenPosX(element)+x), (%'ModuleName'_PixelDim)(%'ModuleName'%.%GetScreenPosY(element)+y), w, h, color);
%endif
}

%endif %- DrawFilledBox
%-BW_METHOD_END DrawFilledBox
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawBox
%ifdef DrawBox
%define! Parx
%define! Pary
%define! Parw
%define! Parh
%define! ParlineWidth
%define! Parcolor
%define! Parelement
%include Common\UIDrawBox.Inc
void %'ModuleName'%.%DrawBox(%'ModuleName'_Element *element, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim w, %'ModuleName'_PixelDim h, %'ModuleName'_PixelDim lineWidth, %'ModuleName'_PixelColor color)
{
%ifdef _OPTIMIZE_CLEARED_BACKGROUND
  if ((window->flags&%'ModuleName'_FLAGS_WINDOW_BG_CLEARED) && color==window->prop.color) {
    /* nothing to do, as window background just has been cleared with our color */
  } else {
    %@Display@'ModuleName'%.DrawBox((%'ModuleName'_PixelDim)(%'ModuleName'%.%GetScreenPosX(element)+x), (%'ModuleName'_PixelDim)(%'ModuleName'%.%GetScreenPosY(element)+y), w, h, lineWidth, color);
  }
%else
  %@Display@'ModuleName'%.DrawBox((%'ModuleName'_PixelDim)(%'ModuleName'%.%GetScreenPosX(element)+x), (%'ModuleName'_PixelDim)(%'ModuleName'%.%GetScreenPosY(element)+y), w, h, lineWidth, color);
%endif
}

%endif %- DrawBox
%-BW_METHOD_END DrawBox
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawLine
%ifdef DrawLine
%define! Parx0
%define! Pary0
%define! Parx1
%define! Pary1
%define! Parcolor
%define! Parelement
%include Common\UIDrawLine.Inc
void %'ModuleName'%.%DrawLine(%'ModuleName'_Element *element, %'ModuleName'_PixelDim x0, %'ModuleName'_PixelDim y0, %'ModuleName'_PixelDim x1, %'ModuleName'_PixelDim y1, %'ModuleName'_PixelColor color)
{
  %@Display@'ModuleName'%.DrawLine(
    %'ModuleName'%.%GetScreenPosX(element)+x0,
    %'ModuleName'%.%GetScreenPosY(element)+y0,
    %'ModuleName'%.%GetScreenPosX(element)+x1,
    %'ModuleName'%.%GetScreenPosY(element)+y1,
    color);
}

%endif %- DrawLine
%-BW_METHOD_END DrawLine
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetElementColor
%ifdef SetElementColor
%define! Parcolor
%define! Parelement
%include Common\UISetElementColor.Inc
void %'ModuleName'%.%SetElementColor(%'ModuleName'_Element *element, %'ModuleName'_PixelColor color)
{
  //%'ModuleName'_Element *e;
  if (element != NULL){
    element->prop.color = color;                                 %>40/* change color of element */
  }
}

%endif %- SetElementColor
%-BW_METHOD_END SetElementColor
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetScreen
%ifdef GetScreen
%define! RetVal
%include Common\UIGetScreen.Inc
%'ModuleName'_PScreen %'ModuleName'%.%GetScreen(void)
{
  return currentScreen;
}

%endif %- GetScreen
%-BW_METHOD_END GetScreen
%-************************************************************************************************************
%-BW_METHOD_BEGIN EqualElement
%ifdef EqualElement
%define! Parelem1
%define! Parelem2
%define! RetVal
%include Common\UIEqualElement.Inc
#if 0
bool %'ModuleName'%.%EqualElement(%'ModuleName'_Element *elem1, %'ModuleName'_Element *elem2)
{
  /* method is implemented as macro in '%'ModuleName'.h' */
}
#endif

%endif %- EqualElement
%-BW_METHOD_END EqualElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetSelectedElement
%ifdef GetSelectedElement
%define! Parscreen
%define! ParpElement
%define! RetVal
%include Common\UIGetSelectedElement.Inc
bool %'ModuleName'%.%GetSelectedElement(%'ModuleName'_Screen *screen, %'ModuleName'_PElement *pElement)
{
  *pElement = screen->selectedE;

  return (bool)((*pElement)!=NULL);
}

%endif %- GetSelectedElement
%-BW_METHOD_END GetSelectedElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN FindElement
%ifdef FindElement
%define! ParpElement
%define! Parcompare
%define! Pardata
%define! ParstartElement
%define! RetVal
%include Common\UIFindElement.Inc
bool %'ModuleName'%.%FindElement(%'ModuleName'_Element *startElement, %'ModuleName'_PElement *pElement, %'ModuleName'_ElementFindFct compare, %'ModuleName'_Pvoid data)
{
 %'ModuleName'%.Element *element;

 if (startElement != NULL && startElement->sub != NULL){         %>40/* skip search if no sub elements available */
   element=startElement->sub;                                    %>40/* start with sub element */
   while (element != startElement) {
     if (compare(element, data)){
       *pElement = element;
       return TRUE;                                              %>40/* matching element found, return */
     }
     %'ModuleName'%.%NextElement(&element, NULL);                %>40/* goto next element */
   }
 }
 return FALSE;
}

%endif %- FindElement
%-BW_METHOD_END FindElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetDisplayOrientation
%ifdef GetDisplayOrientation
%define! RetVal
%include Common\UIGetDisplayOrientation.Inc
/*
%'ModuleName'_DisplayOrientation %'ModuleName'%.%GetDisplayOrientation(void)
  ** This method is implemented as macro
*/

%endif %- GetDisplayOrientation
%-BW_METHOD_END GetDisplayOrientation
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetWidth
%ifdef GetWidth
%define! RetVal
%include Common\UIGetWidth.Inc
/*
%'ModuleName'_PixelDim %'ModuleName'%.%GetWidth(void)
  ** This method is implemented as macro
*/

%endif %- GetWidth
%-BW_METHOD_END GetWidth
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetHeight
%ifdef GetHeight
%define! RetVal
%include Common\UIGetHeight.Inc
/*
%'ModuleName'_PixelDim %'ModuleName'%.%GetHeight(void)
  ** This method is implemented as macro
*/

%endif %- GetHeight
%-BW_METHOD_END GetHeight
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetDisplayOrientation
%ifdef SetDisplayOrientation
%define! ParnewOrientation
%include Common\UISetDisplayOrientation.Inc
void %'ModuleName'%.%SetDisplayOrientation(%'ModuleName'_DisplayOrientation newOrientation)
{
  %'ModuleName'%.Screen *screen;
  %'ModuleName'%.Window *window;
  %'ModuleName'_DisplayOrientation currOrientation = %'ModuleName'%.%GetDisplayOrientation();

  /* inform UI about change */
  screen = %'ModuleName'%.%GetScreen();
  if (screen==NULL) {
    return;                                                      %>40/* no screen? something is wrong? */
  }
  /* adopt UI elements for new orientation */
  if (newOrientation == currOrientation) {
    return; /* nothing to do */
  }
  if (  (   (currOrientation==%'ModuleName'%.ORIENTATION_PORTRAIT || currOrientation==%'ModuleName'%.ORIENTATION_PORTRAIT180)
         && (newOrientation==%'ModuleName'%.ORIENTATION_LANDSCAPE || newOrientation==%'ModuleName'%.ORIENTATION_LANDSCAPE180)
        )
      ||
        (   (newOrientation==%'ModuleName'%.ORIENTATION_PORTRAIT || newOrientation==%'ModuleName'%.ORIENTATION_PORTRAIT180)
         && (currOrientation==%'ModuleName'%.ORIENTATION_LANDSCAPE || currOrientation==%'ModuleName'%.ORIENTATION_LANDSCAPE180)
        )
     ) /* changing from landscape to portrait or vice versa: adopt UI coordinates */
  {
    window = screen->element.sub;
    while(window != NULL) {
      if (   window->prop.x==0 && window->prop.y==0
          && window->prop.width == %'ModuleName'%.GetWidth()
          && window->prop.height == %'ModuleName'%.GetHeight()
         )
      { /* full screen window: swap width/height */
        window->prop.width = %'ModuleName'%.GetHeight();
        window->prop.height = %'ModuleName'%.GetWidth();
        %'ModuleName'%.OnWindowResize(window);
      }
      window = window->next;
    } /* while */
  } /* if */
  /* Calling inherited method */
%ifdef OnEvent
  %OnEvent(screen, NULL, NULL, %'ModuleName'_MSG_PRE_ORIENTATION_CHANGE);%>40/* call user event */
%endif %- OnEvent
  %@Display@'ModuleName'%.SetDisplayOrientation(newOrientation);
%ifdef OnEvent
  %OnEvent(screen, NULL, NULL, %'ModuleName'_MSG_ORIENTATION_CHANGE);%>40/* call user event */
%endif %- OnEvent
  element->prop.flags |= ~%'ModuleName'_FLAGS_NEEDS_REPAINT;     %>40/* update whole screen */
  %'ModuleName'%.%UpdateScreen(screen, TRUE);
%ifdef OnEvent
  %OnEvent(screen, NULL, NULL, %'ModuleName'_MSG_POST_ORIENTATION_CHANGE);%>40/* call user event */
%endif %- OnEvent
}

%endif %- SetDisplayOrientation
%-BW_METHOD_END SetDisplayOrientation
%-************************************************************************************************************
%-BW_METHOD_BEGIN UpdateElementNoRefresh
%ifdef UpdateElementNoRefresh
%define! Parelement
%define! ParupdateAll
%define! Parparent
%include Common\UIUpdateElementNoRefresh.Inc
void %'ModuleName'%.%UpdateElementNoRefresh(%'ModuleName'_Element *parent, %'ModuleName'_Element *element, bool updateAll)
{
  (void)parent; /* unused argument */
  if (updateAll || (element->prop.flags&%'ModuleName'_FLAGS_NEEDS_REPAINT)) {
    element->prop.flags |= %'ModuleName'_FLAGS_NEEDS_REPAINT; /* force repaint */
    element->msgHandler(%'ModuleName'_MSG_PAINT, element, NULL);
    element->prop.flags &= ~%'ModuleName'_FLAGS_NEEDS_REPAINT;
  }
}

%endif %- UpdateElementNoRefresh
%-BW_METHOD_END UpdateElementNoRefresh
%-************************************************************************************************************
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG AddSubElement
%define! ParparentElement
%define! ParsubElement
%define! RetVal
%include Common\GeneralInternal.inc (AddSubElement)
byte %'ModuleName'%.AddSubElement(%'ModuleName'_Element *parentElement, %'ModuleName'_Element *subElement)
{
  if (parentElement == NULL){
    return ERR_FAILED;
  }
  if (parentElement->sub == NULL){
    parentElement->sub = subElement;                             %>40/* no previous sub elements so add it direct */
    subElement->parent = parentElement;                          %>40/* link parent */
    return ERR_OK;
  } else {
    return %'ModuleName'%.AddNextElement(parentElement->sub, subElement);%>40/* add sub element to the end of list */
  }
}

%-INTERNAL_METHOD_END AddSubElement
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG AddNextElement
%define! ParcurrentElement
%define! ParnextElement
%define! RetVal
%include Common\GeneralInternal.inc (AddNextElement)
byte %'ModuleName'%.AddNextElement(%'ModuleName'_Element *currentElement, %'ModuleName'_Element *nextElement)
{
  if (currentElement == NULL){
    return ERR_FAILED;
  }
  /*add element to the end of the list */
  if (currentElement->next == NULL){                             %>40/* first in list */
    currentElement->next = nextElement;
  } else {                                                       %>40/* append to the end of the list */
    %'ModuleName'_Element *e;
    e = currentElement->next;
    while (e->next != NULL){                                     %>40/* iterate through the list */
      e = e->next;
    }
    e->next = nextElement;
  }
  nextElement->parent = currentElement->parent;                  %>40/* they have the same parent */
  return ERR_OK;
}

%-INTERNAL_METHOD_END AddNextElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawCircle
%ifdef DrawCircle
%define! Parelement
%define! Parx
%define! Pary
%define! Parradius
%define! Parcolor
%include Common\UIDrawCircle.Inc
void %'ModuleName'%.%DrawCircle(%'ModuleName'_Element *element, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim radius, %'ModuleName'_PixelColor color)
{
   %@Display@'ModuleName'%.DrawCircle((%'ModuleName'_PixelDim)(%'ModuleName'%.%GetScreenPosX(element)+x), (%'ModuleName'_PixelDim)(%'ModuleName'%.%GetScreenPosY(element)+y), radius, color);
}

%endif %- DrawCircle
%-BW_METHOD_END DrawCircle
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawFilledCircle
%ifdef DrawFilledCircle
%define! Parelement
%define! Parx
%define! Pary
%define! Parradius
%define! Parcolor
%include Common\UIDrawFilledCircle.Inc
void %'ModuleName'%.%DrawFilledCircle(%'ModuleName'_Element *element, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim radius, %'ModuleName'_PixelColor color)
{
  %@Display@'ModuleName'%.DrawFilledCircle((%'ModuleName'_PixelDim)(%'ModuleName'%.%GetScreenPosX(element)+x), (%'ModuleName'_PixelDim)(%'ModuleName'%.%GetScreenPosY(element)+y), radius, color);
}

%endif %- DrawFilledCircle
%-BW_METHOD_END DrawFilledCircle
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG RemoveElement
%define! Parelement
%define! RetVal
%include Common\GeneralInternal.inc (RemoveElement)
byte %'ModuleName'%.RemoveElement(%'ModuleName'_Element *element)
{
  %'ModuleName'_Element **pe;                                    %>40/* pointer to previous element */

  if (element==NULL) {
    return ERR_FAILED;
  }
  pe = &element->parent;
  if (*pe==NULL) {                                               %>40/* no parent? */
    return ERR_FAILED;
  }
  pe = &(*pe)->sub;
  if (*pe==NULL) {                                               %>40/* no sub element? */
    return ERR_FAILED;
  }
  while(*pe != NULL) {
    if (*pe == element) { /* found element */
      %'ModuleName'%.SendMessage(%'ModuleName'_MSG_ELEMENT_REMOVE, element, NULL);%>40/* notify element about removal */
      *pe = (*pe)->next;                                         %>40/* unlink element */
      break; /* break while loop */
    }
    pe = &(*pe)->next;
  }
  return ERR_OK;
}

%-INTERNAL_METHOD_END RemoveElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN NextElement
%ifdef NextElement
%define! ParppElement
%define! ParstopElement
%include Common\UINextElement.Inc
void %'ModuleName'%.%NextElement(%'ModuleName'_PElement *ppElement, %'ModuleName'_Element *stopElement)
{
  /* precondition: data structure with valid data */
  %'ModuleName'_Element *parent = NULL;
  if (stopElement == NULL){
    stopElement = (%'ModuleName'_Element*)%'ModuleName'%.%GetScreen();%>40/* searching whole tree */
  }
  if ((*ppElement)->sub != NULL){
    *ppElement = (*ppElement)->sub;                              %>40/* next element on sub level */
  } else if ((*ppElement)->next != NULL){
    *ppElement = (*ppElement)->next;                             %>40/* next element on the same level */
  } else if ((*ppElement)->parent != NULL){                      %>40/* no sub and next elements, go one level up */
    parent = (*ppElement)->parent;
    *ppElement = NULL;
    /* searching elements in upper levels */
    while (*ppElement == NULL){
      if ((parent == stopElement) || (parent->prop.flags&%'ModuleName'_FLAGS_IS_MODAL)){%>40/* restart, sub tree complete or parent is modal e. g. dialog window */
        *ppElement = parent;
        break;
      }
      if (parent->next != NULL){                                 %>40/* next element is next of parent */
        (*ppElement) = parent->next;
      } else if (parent->parent != NULL){                        %>40/* go one level up if possible */
        parent = parent->parent;
      } else {
        *ppElement = parent;                                     %>40/* top element, first element */
      }
    }
  }
}

%endif %- NextElement
%-BW_METHOD_END NextElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrevElement
%ifdef PrevElement
%define! ParppElement
%define! ParstopElement
%include Common\UIPrevElement.Inc
void %'ModuleName'%.%PrevElement(%'ModuleName'_PElement *ppElement, %'ModuleName'_Element *stopElement)
{
  /* precondition: datastructure with valid data */
  %'ModuleName'_Element *nextElement, *nextNextElement;
  nextElement = *ppElement;
  for(;;) {
    %'ModuleName'%.%NextElement(&nextElement, stopElement);      %>40/* next element */
    nextNextElement = nextElement;
    %'ModuleName'%.%NextElement(&nextNextElement, stopElement);  %>40/* next next element */
    if (nextNextElement == *ppElement){
      *ppElement = nextElement;                                  %>40/* found prev element, exit while */
      break;
    }
  } /* for */
}

%endif %- PrevElement
%-BW_METHOD_END PrevElement
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG FctInsideElement
%define! Parelement
%define! Parcoord
%define! RetVal
%include Common\GeneralInternalGlobal.inc (FctInsideElement)
static bool FctInsideElement(%'ModuleName'_Element *element, %'ModuleName'_Coordinate *coord)
{
  return (    coord->x >= %'ModuleName'%.%GetElementPosX(element)
           && coord->x <= %'ModuleName'%.%GetElementPosX(element) + %'ModuleName'%.%GetElementWidth(element) /* x inside element? */
           && coord->y >= %'ModuleName'%.%GetElementPosY(element)
           && coord->y <= %'ModuleName'%.%GetElementPosY(element) + %'ModuleName'%.%GetElementHeight(element) /* y inside element? */
           );
}

%-INTERNAL_METHOD_END FctInsideElement
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG SearchInsideElement
%define! Parcoord
%define! ParpElement
%define! RetVal
%include Common\GeneralInternal.inc (SearchInsideElement)
bool %'ModuleName'%.SearchInsideElement(%'ModuleName'_PElement *pElement, %'ModuleName'_Coordinate *coord)
{
  %'ModuleName'_Element *element;

  if (*pElement != NULL){                                        %>40/* something wrong */
    element = *pElement;                                         %>40/* start element */
    *pElement = NULL;
    for(;;){
      if (FctInsideElement(element, coord)){
        *pElement = element;                                     %>40/* save found element */
        if (element->sub != NULL){                               %>40/* found matching element, goto subelements if any */
          coord->x = (%'ModuleName'_PixelDim)(coord->x-%'ModuleName'_GetElementPosX(element));%>40/* transform into element coord */
          coord->y = (%'ModuleName'_PixelDim)(coord->y-%'ModuleName'_GetElementPosY(element));%>40/* transform into element coord */
          element = element->sub;
        } else if(element->next != NULL && element->parent == *pElement){
          element = element->next;                               %>40/* search sub elements */
        } else {
          return TRUE;
        }
      } else if (element->next != NULL){
        element = element->next;
      } else {
        return (bool)(*pElement != NULL);                        %>40/* no next element, search finished */
      }
    } /* for */
  } /* if */
  return FALSE;                                                  %>40/* return FALSE if no elements found */
}

%-INTERNAL_METHOD_END SearchInsideElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetScreenPosX
%ifdef GetScreenPosX
%define! Parelement
%define! RetVal
%include Common\UIGetScreenPosX.Inc
%'ModuleName'_PixelDim %'ModuleName'%.%GetScreenPosX(%'ModuleName'_Element *element)
{
  %'ModuleName'_PixelDim x;

  if (element == NULL){
    return 0;                                                    %>40 /* set x to 0 if element is NULL */
  }
  x = %'ModuleName'_GetElementPosX(element);
  while (element->parent != NULL){
    x += %'ModuleName'_GetElementPosX(element->parent);
    element = element->parent;
  }
  return x;
}

%endif %- GetScreenPosX
%-BW_METHOD_END GetScreenPosX
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetScreenPosY
%ifdef GetScreenPosY
%define! Parelement
%define! RetVal
%include Common\UIGetScreenPosY.Inc
%'ModuleName'_PixelDim %'ModuleName'%.%GetScreenPosY(%'ModuleName'_Element *element)
{
  %'ModuleName'_PixelDim y;

  if (element == NULL){
    return 0;                                                    %>40 /* set y to 0 if element is NULL */
  }
  y = %'ModuleName'_GetElementPosY(element);
  while (element->parent != NULL){
    y = y + %'ModuleName'_GetElementPosY(element->parent);
    element = element->parent;
  }
  return y;
}

%endif %- GetScreenPosY
%-BW_METHOD_END GetScreenPosY
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawHLine
%ifdef DrawHLine
%define! Parelement
%define! Parx
%define! Pary
%define! Parw
%define! Parcolor
%include Common\UIDrawHLine.Inc
void %'ModuleName'%.%DrawHLine(%'ModuleName'_Element *element, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim w, %'ModuleName'_PixelColor color)
{
  %@Display@'ModuleName'%.DrawHLine(
    %'ModuleName'%.%GetScreenPosX(element)+x,
    %'ModuleName'%.%GetScreenPosY(element)+y,
    w,
    color);
}

%endif %- DrawHLine
%-BW_METHOD_END DrawHLine
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawVLine
%ifdef DrawVLine
%define! Parelement
%define! Parx
%define! Pary
%define! Parh
%define! Parcolor
%include Common\UIDrawVLine.Inc
void %'ModuleName'%.%DrawVLine(%'ModuleName'_Element *element, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim h, %'ModuleName'_PixelColor color)
{
    %@Display@'ModuleName'%.DrawVLine(
    %'ModuleName'%.%GetScreenPosX(element)+x,
    %'ModuleName'%.%GetScreenPosY(element)+y,
    h,
    color);
}

%endif %- DrawVLine
%-BW_METHOD_END DrawVLine
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG PaintScreen
%define! Parelement
%define! RetVal
%include Common\GeneralInternalGlobal.inc (PaintScreen)
static byte PaintScreen(%'ModuleName'_Element *element)
{
  %'ModuleName'_Screen *screen = (%'ModuleName'_Screen*) element;

  if (screen != NULL) {
    %@Display@'ModuleName'%.DrawFilledBox(screen->element.prop.x, screen->element.prop.y, screen->element.prop.width, screen->element.prop.height, screen->element.prop.color);
//    %@Display@'ModuleName'%.UpdateFull();
  } /* if */
  return ERR_OK;
}

%-INTERNAL_METHOD_END PaintScreen
%-************************************************************************************************************
%-************************************************************************************************************
%-BW_METHOD_BEGIN AlignElementRight
%ifdef AlignElementRight
%define! Parelement
%define! RetVal
%include Common\UIAlignElementRight.Inc
byte %'ModuleName'%.%AlignElementRight(%'ModuleName'_Element *element)
{
  if (%'ModuleName'%.%GetElementWidth(element->parent) > (%'ModuleName'%.%GetElementPosX(element) + %'ModuleName'%.%GetElementWidth(element))){
    element->prop.x = (%'ModuleName'_PixelDim)(%'ModuleName'%.%GetElementWidth(element->parent) - (%'ModuleName'%.%GetElementPosX(element) + %'ModuleName'%.%GetElementWidth(element)));
    return ERR_OK;
  }
  return ERR_FAILED;
}

%endif %- AlignElementRight
%-BW_METHOD_END AlignElementRight
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetElementAbsolutePos
%ifdef GetElementAbsolutePos
%define! Parelem
%define! Parxp
%define! Paryp
%define! RetVal
%include Common\UIGetElementAbsolutePos.Inc
byte %'ModuleName'%.%GetElementAbsolutePos(%'ModuleName'_Element *elem, %'ModuleName'_PixelDim *xp, %'ModuleName'_PixelDim *yp)
{
  if (elem==NULL || xp==NULL || yp==NULL) {
    return ERR_FAILED;
  }
  *xp = 0;
  *yp = 0;
  while(elem != NULL) {
    *xp += elem->prop.x;
    *yp += elem->prop.y;
    elem = elem->parent;
  }
  return ERR_OK;
}

%endif %- GetElementAbsolutePos
%-BW_METHOD_END GetElementAbsolutePos
%-************************************************************************************************************
%-BW_METHOD_BEGIN CoordinateInsideElement
%ifdef CoordinateInsideElement
%define! Parcoord
%define! Parelement
%define! RetVal
%include Common\UICoordinateInsideElement.Inc
bool %'ModuleName'%.%CoordinateInsideElement(%'ModuleName'_Coordinate *coord, %'ModuleName'_Element *element)
{
  %'ModuleName'_PixelDim x, y;

  if (%'ModuleName'%.GetElementAbsolutePos(element, &x, &y)!=ERR_OK) {
    return FALSE; /* error case */
  }
  return (    coord->x >= x
           && coord->x <= x + %'ModuleName'%.%GetElementWidth(element) /* x inside element? */
           && coord->y >= y
           && coord->y <= y + %'ModuleName'%.%GetElementHeight(element) /* y inside element? */
           );
}

%endif %- CoordinateInsideElement
%-BW_METHOD_END CoordinateInsideElement
%-************************************************************************************************************
%-BW_METHOD_BEGIN ProcessTouch
%ifdef ProcessTouch
%define! Partouched
%define! Parx
%define! Pary
%include Common\UIProcessTouch.Inc
void %'ModuleName'%.%ProcessTouch(bool touched, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y)
{
  static struct {
    bool touched;
    %'ModuleName'_Coordinate pos;
  } prevState = {FALSE, {0, 0}};         /* previous state */
  %'ModuleName'_Coordinate pos;

  pos.x = x;
  pos.y = y;
  if (touched && !prevState.touched) { /* press */
    %'ModuleName'%.%MsgSendListRecursiveBottomUp(%'ModuleName'%.%GetRoot(), %'ModuleName'_MSG_CLICK, (void*)&pos);
    prevState.touched = touched;
    prevState.pos.x = x;
    prevState.pos.y = y;
  } else if (touched && prevState.touched && x!=prevState.pos.x && y!=prevState.pos.y) { /* move */
    %'ModuleName'%.%MsgSendListRecursiveBottomUp(%'ModuleName'%.%GetRoot(), %'ModuleName'_MSG_CLICK_MOVE, (void*)&pos);
    prevState.pos.x = x;
    prevState.pos.y = y;
  } else if (!touched && prevState.touched) { /* release */
    %'ModuleName'%.%MsgSendListRecursiveBottomUp(%'ModuleName'%.%GetRoot(), %'ModuleName'_MSG_CLICK_RELEASE, (void*)&pos);
    prevState.touched = FALSE;
    prevState.pos.x = 0;
    prevState.pos.y = 0;
  }
}

%endif %- ProcessTouch
%-BW_METHOD_END ProcessTouch
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendMessage
%ifdef SendMessage
%define! Parelement
%define! Parkind
%define! ParpData
%include Common\UISendMessage.Inc
void %'ModuleName'%.%SendMessage(%'ModuleName'_MsgKind kind, %'ModuleName'_Element *element, %'ModuleName'_Pvoid pData)
{
  if (element->msgHandler!=NULL) {
    element->msgHandler(kind, element, pData);
  }
}

%endif %- SendMessage
%-BW_METHOD_END SendMessage
%-************************************************************************************************************
%-BW_METHOD_BEGIN MarkElementModal
%ifdef MarkElementModal
%define! Parelement
%define! RetVal
%include Common\UIMarkElementModal.Inc
byte %'ModuleName'%.%MarkElementModal(%'ModuleName'_Element *element)
{
  %'ModuleName'_Screen *screen;

  if (element==NULL) {
    return ERR_FAILED;
  }
  screen = %'ModuleName'%.%GetScreen();
  if (screen==NULL || screen->modalElement != NULL) {
    return ERR_FAILED;
  }
  screen->modalElement = element;
  element->prop.flags |= %'ModuleName'_FLAGS_IS_MODAL;
  return ERR_OK;
}

%endif %- MarkElementModal
%-BW_METHOD_END MarkElementModal
%-************************************************************************************************************
%-BW_METHOD_BEGIN UnMarkElementModal
%ifdef UnMarkElementModal
%define! Parelement
%define! RetVal
%include Common\UIUnMarkElementModal.Inc
byte %'ModuleName'%.%UnMarkElementModal(%'ModuleName'_Element *element)
{
  %'ModuleName'_Screen *screen;

  if (element==NULL) {
    return ERR_FAILED;
  }
  screen = %'ModuleName'%.%GetScreen();
  if (screen==NULL || screen->modalElement != element) {
    return ERR_FAILED;
  }
  screen->modalElement = NULL;
  element->prop.flags &= ~%'ModuleName'_FLAGS_IS_MODAL;
  return ERR_OK;
}

%endif %- UnMarkElementModal
%-BW_METHOD_END UnMarkElementModal
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetRoot
%ifdef GetRoot
%define! RetVal
%include Common\UIGetRoot.Inc
%'ModuleName'_PElement %'ModuleName'%.%GetRoot(void)
{
  %'ModuleName'_Screen *screen = %'ModuleName'%.%GetScreen();

  if (screen==NULL) {
    return NULL;
  }
  if (screen->modalElement!=NULL) {
    return screen->modalElement;
  }
  return &screen->element;
}

%endif %- GetRoot
%-BW_METHOD_END GetRoot
%-************************************************************************************************************
%-BW_METHOD_BEGIN ElementFullyVisible
%ifdef ElementFullyVisible
%define! Parelement
%define! RetVal
%include Common\UIElementFullyVisible.Inc
bool %'ModuleName'%.%ElementFullyVisible(%'ModuleName'_Element *element)
{
  %'ModuleName'_Screen *screen;
  %'ModuleName'_Coordinate coord;

  /* simple implementation: checking if we have a modal window covering the element or part of it */
  screen = %'ModuleName'%.%GetScreen();
  if (screen==NULL || element==NULL) {
    return FALSE; /* no screen or element: well, it is not visible :-) */
  }
  if (screen->modalElement != NULL) { /* we have a modal window: */
    /* check left upper corner */
    coord.x = element->prop.x;
    coord.y = element->prop.y;
    if (%'ModuleName'%.CoordinateInsideElement(&coord, screen->modalElement)) {
      return FALSE; /* left upper corner is inside modal window */
    }
    /* check left lower corner */
    coord.x = element->prop.x;
    coord.y = element->prop.y+element->prop.height;
    if (%'ModuleName'%.CoordinateInsideElement(&coord, screen->modalElement)) {
      return FALSE; /* left lower corner is inside modal window */
    }
    /* check right upper corner */
    coord.x = element->prop.x+element->prop.width;
    coord.y = element->prop.y;
    if (%'ModuleName'%.CoordinateInsideElement(&coord, screen->modalElement)) {
      return FALSE; /* right upper corner is inside modal window */
    }
    /* check right lower corner */
    coord.x = element->prop.x+element->prop.width;
    coord.y = element->prop.y+element->prop.height;
    if (%'ModuleName'%.CoordinateInsideElement(&coord, screen->modalElement)) {
      return FALSE; /* right upper corner is inside modal window */
    }
  }
  return TRUE; /* element must be visible */
}

%endif %- ElementFullyVisible
%-BW_METHOD_END ElementFullyVisible
%-************************************************************************************************************
%-BW_METHOD_BEGIN MsgSendListRecursiveBottomUp
%ifdef MsgSendListRecursiveBottomUp
%define! Parelement
%define! Parkind
%define! ParpData
%include Common\UIMsgSendListRecursiveBottomUp.Inc
#ifdef __HC08__
  #pragma MESSAGE DISABLE C1855 /* recursive function call */
#endif
void %'ModuleName'%.%MsgSendListRecursiveBottomUp(%'ModuleName'_Element *element, %'ModuleName'_MsgKind kind, %'ModuleName'_Pvoid pData)
{
  while (element!=NULL) {
    %'ModuleName'%.%MsgSendListRecursiveBottomUp(element->sub, kind, pData);
    %'ModuleName'%.%SendMessage(kind, element, pData); /* for element */
    element = element->next;
  }
}
#ifdef __HC08__
  #pragma MESSAGE DEFAULT C1855 /* recursive function call */
#endif

%endif %- MsgSendListRecursiveBottomUp
%-BW_METHOD_END MsgSendListRecursiveBottomUp
%-************************************************************************************************************
%-BW_METHOD_BEGIN MsgSendListRecursiveTopDown
%ifdef MsgSendListRecursiveTopDown
%define! Parelement
%define! Parkind
%define! ParpData
%include Common\UIMsgSendListRecursiveTopDown.Inc
#ifdef __HC08__
  #pragma MESSAGE DISABLE C1855 /* recursive function call */
#endif
void %'ModuleName'%.%MsgSendListRecursiveTopDown(%'ModuleName'_Element *element, %'ModuleName'_MsgKind kind, %'ModuleName'_Pvoid pData)
{
  while (element!=NULL) {
    %'ModuleName'%.%SendMessage(kind, element, pData); /* for element */
    %'ModuleName'%.%MsgSendListRecursiveTopDown(element->sub, kind, pData);
    element = element->next;
  }
}
#ifdef __HC08__
  #pragma MESSAGE DEFAULT C1855 /* recursive function call */
#endif

%endif %- MsgSendListRecursiveTopDown
%-BW_METHOD_END MsgSendListRecursiveTopDown
%-************************************************************************************************************
%-BW_METHOD_BEGIN MsgPaintAllElements
%ifdef MsgPaintAllElements
%define! ParrootElement
%include Common\UIMsgPaintAllElements.Inc
void %'ModuleName'%.%MsgPaintAllElements(%'ModuleName'_Element *rootElement)
{
  %'ModuleName'%.%MsgSendListRecursiveTopDown(rootElement, %'ModuleName'_MSG_WIDGET_PAINT, NULL);
}

%endif %- MsgPaintAllElements
%-BW_METHOD_END MsgPaintAllElements
%-************************************************************************************************************
%-BW_METHOD_BEGIN MsgUpdateAllElements
%ifdef MsgUpdateAllElements
%define! ParrootElement
%include Common\UIMsgUpdateAllElements.Inc
void %'ModuleName'%.%MsgUpdateAllElements(%'ModuleName'_Element *rootElement)
{
  %'ModuleName'%.%MsgSendListRecursiveTopDown(rootElement, %'ModuleName'_MSG_WIDGET_UPDATE, NULL);
}

%endif %- MsgUpdateAllElements
%-BW_METHOD_END MsgUpdateAllElements
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetElementPosLeft
%ifdef GetElementPosLeft
%define! Parelement
%define! RetVal
%include Common\UIGetElementPosLeft.Inc
/*
%'ModuleName'_PixelDim %'ModuleName'%.%GetElementPosLeft(%'ModuleName'_Element *element)
{
  *** Implemented as a macro in the header file
}
*/

%endif %- GetElementPosLeft
%-BW_METHOD_END GetElementPosLeft
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetElementPosRight
%ifdef GetElementPosRight
%define! Parelement
%define! RetVal
%include Common\UIGetElementPosRight.Inc
/*
%'ModuleName'_PixelDim %'ModuleName'%.%GetElementPosRight(%'ModuleName'_Element *element)
{
  *** Implemented as a macro in the header file
}
*/

%endif %- GetElementPosRight
%-BW_METHOD_END GetElementPosRight
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetElementPosTop
%ifdef GetElementPosTop
%define! Parelement
%define! RetVal
%include Common\UIGetElementPosTop.Inc
/*
%'ModuleName'_PixelDim %'ModuleName'%.%GetElementPosTop(%'ModuleName'_Element *element)
{
  *** Implemented as a macro in the header file
}
*/

%endif %- GetElementPosTop
%-BW_METHOD_END GetElementPosTop
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetElementPosBottom
%ifdef GetElementPosBottom
%define! Parelement
%define! RetVal
%include Common\UIGetElementPosBottom.Inc
/*
%'ModuleName'_PixelDim %'ModuleName'%.%GetElementPosBottom(%'ModuleName'_Element *element)
{
  *** Implemented as a macro in the header file
}
*/

%endif %- GetElementPosBottom
%-BW_METHOD_END GetElementPosBottom
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetUI
%ifdef GetUI
%include Common\UIGetUI.Inc
void %'ModuleName'%.%GetUI(void)
{
%if RTOSenabled='yes'
  (void)%@RTOS@'ModuleName'%.xSemaphoreTakeRecursive(UISem, portMAX_DELAY);
%else
  /* nothing to do, as no RTOS selected */
%endif
}

%endif %- GetUI
%-BW_METHOD_END GetUI
%-************************************************************************************************************
%-BW_METHOD_BEGIN GiveUI
%ifdef GiveUI
%include Common\UIGiveUI.Inc
void %'ModuleName'%.%GiveUI(void)
{
%if RTOSenabled='yes'
  (void)%@RTOS@'ModuleName'%.xSemaphoreGiveRecursive(UISem);
%else
  /* nothing to do, as no RTOS selected */
%endif
}

%endif %- GiveUI
%-BW_METHOD_END GiveUI
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%include Common\UIInit.Inc
void %'ModuleName'%.%Init(void)
{
%if RTOSenabled='yes'
  UISem = %@RTOS@'ModuleName'%.xSemaphoreCreateRecursiveMutex();
  if (UISem==NULL) { /* semaphore creation failed */
    for(;;) {} /* error, not enough memory? */
  }
%else
  /* nothing to do, as no RTOS selected */
%endif
}

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
%include Common\UIDeinit.Inc
void %'ModuleName'%.%Deinit(void)
{
%if RTOSenabled='yes'
  %@RTOS@'ModuleName'%.vSemaphoreDelete(UISem);
%else
  /* nothing to do, as no RTOS selected */
%endif
}

%endif %- Deinit
%-BW_METHOD_END Deinit
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_METHOD_BEGIN OnEvent
%ifdef OnEvent
%IMPLEMENTATION OnEvent
%define! Parscreen
%define! Parwindow
%define! Parelement
%define! Parevent
%include Common\UIOnEvent.Inc
void %OnEvent(%'ModuleName'_Screen *screen, %'ModuleName'_Element *window, %'ModuleName'_Element *element, %'ModuleName'_MsgKind event)
{
  /* Write your code here ... */
}

%endif %- OnEvent
%-BW_METHOD_END OnEvent
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This bean is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
