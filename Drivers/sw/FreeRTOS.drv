%-Driver generated by the Bean Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Bean Wizard
%- If you change these lines, Bean Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    27.08.2009
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%ifdef RuntimeCntrLDD
  %ifdef @RuntimeCntrLDD@OnCounterRestart
    %define! Description_%@RuntimeCntrLDD@OnCounterRestart Called if counter overflow/underflow or counter is reinitialized by modulo or compare register matching. OnCounterRestart event and Timer unit must be enabled. See <a href="TimerUnit_LDDMethods.html#SetEventMask">SetEventMask</a> and <a href="TimerUnit_LDDMethods.html#GetEventMask">GetEventMask</a> methods.This event is available only if a <a href="TimerUnit_LDDProperties.html#IntServiceCounter">Interrupt</a> is enabled. The event services the event of the inherited component and eventually invokes other events.
  %endif %- @RuntimeCntrLDD@OnCounterRestart
%endif %- RuntimeCntrLDD
%ifdef RuntimeCntr
  %ifdef @RuntimeCntr@OnInterrupt
    %define! Description_%@RuntimeCntr@OnInterrupt When a timer interrupt occurs this event is called (only when the component is enabled - <a href="TimerIntMethods.html#Enable">Enable</a> and the events are enabled - <a href="TimerIntMethods.html#EnableEvent">EnableEvent</a>). This event is enabled only if a <a href="TimerIntProperties.html#IntService">interrupt service/event</a> is enabled. The event services the event of the inherited component and eventually invokes other events.
  %endif %- @RuntimeCntr@OnInterrupt
%endif %- RuntimeCntr
%ifdef TickCntr
  %ifdef @TickCntr@OnInterrupt
    %define! Description_%@TickCntr@OnInterrupt This event is called when a compare matches the counter value (if compare or reload is selected as a interrupt source) or a counter overflows (for free-running devices). It is valid only when the component is enabled - <a href="FreeCntrMethods.html#Enable">"Enable"</a> and the events are enabled - <a href="FreeCntrMethods.html#EnableEvent">"EnableEvent"</a>. The event is available only if <a href="FreeCntrProperties.html#IntService">Interrupt service/event</a> is enabled. The event services the event of the inherited component and eventually invokes other events.
  %endif %- @TickCntr@OnInterrupt
%endif %- TickCntr
%ifdef TickTimerLDD
  %ifdef @TickTimerLDD@OnCounterRestart
    %define! Description_%@TickTimerLDD@OnCounterRestart Called if counter overflow/underflow or counter is reinitialized by modulo or compare register matching. OnCounterRestart event and Timer unit must be enabled. See <a href="TimerUnit_LDDMethods.html#SetEventMask">SetEventMask</a> and <a href="TimerUnit_LDDMethods.html#GetEventMask">GetEventMask</a> methods.This event is available only if a <a href="TimerUnit_LDDProperties.html#IntServiceCounter">Interrupt</a> is enabled. The event services the event of the inherited component and eventually invokes other events.
  %endif %- @TickTimerLDD@OnCounterRestart
%endif %- TickTimerLDD
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%include freeRTOS_Files.prg
%if defined(myDummy) %- dummy reference to the RTOS adaptor, otherwise the classic Component wizard will NOT include the file below in the package!
%include sw\RTOSAdaptor\FreeRTOS_RTOSAdaptor.prg
%endif
%-
%INTERFACE
%define! Settings Common\FreeRTOSSettings.Inc
%define! Abstract Common\FreeRTOSAbstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited components */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"
#include "FreeRTOS.h"
#include "task.h"                                                %>40/* task API */
#include "semphr.h"                                              %>40/* semaphore API */
#include <stddef.h>                                              %>40/* for size_t type */

/* Macro for shell support */
%ifdef ParseCommand
#define %'ModuleName'%.PARSE_COMMAND_ENABLED  1  /* set to 1 if method ParseCommand() is present, 0 otherwise */
%else
#define %'ModuleName'%.PARSE_COMMAND_ENABLED  0 /* set to 1 if method ParseCommand() is present, 0 otherwise */
%endif %- ParseCommand

/* Macros used by Processor Expert */
%if %DisabledInterruptsInStartup='yes'
#define PEX_RTOS_INIT()                                          %>>portDISABLE_INTERRUPTS() /* disable all interrupts, they get enabled in vStartScheduler() */
%else
#define PEX_RTOS_INIT()                                          %>>/* RTOS adapter is configured not to disable interrupts */
%endif
#define PEX_RTOS_START()                                         %>>%'ModuleName'%.%vTaskStartScheduler()

/* macro to identify CPU: 0 for M0+ and 4 for M4 */
%if %CPUDB_prph_has_feature(CPU,ARM_CORTEX_M0P) = 'yes' %- Note: for IAR this is defined in portasm.s too!
#define FREERTOS_CPU_CORTEX_M                                    %>>0 /* Cortex M0+ core */
%else
#define FREERTOS_CPU_CORTEX_M                                    %>>4 /* Cortex M4 core */
%endif
%- =============================================================================
%- Add linker Entry Point - through .xlkr file
%- =============================================================================
%- %define_prj! PE_G_4PEx_ToolChain_Linker_EntryPoint __boot
%-
%- =============================================================================
%- Add other compiler language parameters - through .xlkr file
%- Currently disabled and fixed in source code.
%- =============================================================================
%if Compiler = 'CodeWarriorARM'
  %-if defined(XLKR_C_COMPILER_OTHER_PARAMS)
    %-error! xx %XLKR_C_COMPILER_OTHER_PARAMS
%-    %define_prj! PE_G_4PEx_ToolChain_Compiler_OtherParams -define __CODEWARRIOR__=1 -define __CWARM__=1 -define MQX_MQXLITE=1
  %-endif
  %-if defined(XLKR_ASM_COMPILER_OTHER_PARAMS)
%-    %define_prj! PE_G_4PEx_ToolChain_Asm_OtherParams -define __CODEWARRIOR__=1 -define __CWARM__=1 -define MQX_MQXLITE=1
  %-endif
%endif
%-
%-
%if (CPUfamily = "Kinetis")
%- =============================================================================
%- Allocation of interrupt vectors by RTOS.
%- =============================================================================

/* Prototypes for interrupt service handlers */
void vPortSVCHandler(void);
void vPortPendSVHandler(void);
%-
%if (defined(PEversionDecimal) && (PEversionDecimal >=0 '1282')) %- this is only supported with MCU 10.3
%- Get interrupts info from CPU database
%- Note: this is done only for Kinetis for now, and defaults are disabled in FreeRTOS_RTOSAdaptor.prg.
%:tmp = %CPUDB_define_Interrupt_Vectors_info()
%-
 %for vect from InterruptVectors
   %if %"%'vect'" = 'defaultInt'
     %if vect = 'ivINT_SVCall'
       %define_prj %'vect' vPortSVCHandler
     %elif vect = 'ivINT_PendableSrvReq'
       %define_prj %'vect' vPortPendSVHandler
     %else
       %- keep PEx default
     %endif
   %endif
 %endfor
%-
%endif %- MCU 10.3
%-
%endif %-(CPUfamily = "Kinetis")
%- =============================================================================
%- Required update of the generated linker command file.
%- =============================================================================
%- DATA SECTION
%- %append PE_G_LCF_ADDITIONAL_DATA_SECTION_CONTENT  /* FreeRTOS component BEGIN */
%- %append PE_G_LCF_ADDITIONAL_DATA_SECTION_CONTENT  . = ALIGN(0x10);
%- %append PE_G_LCF_ADDITIONAL_DATA_SECTION_CONTENT  *(.kernel_data)
%- %append PE_G_LCF_ADDITIONAL_DATA_SECTION_CONTENT  __KERNEL_DATA_START = ALIGN(0x10);
%- %append PE_G_LCF_ADDITIONAL_DATA_SECTION_CONTENT  . = __KERNEL_DATA_START + 0x0400;
%- %append PE_G_LCF_ADDITIONAL_DATA_SECTION_CONTENT  __KERNEL_DATA_END = .;
%- %append PE_G_LCF_ADDITIONAL_DATA_SECTION_CONTENT  /* FreeRTOS component END */
%- CODE SECTION
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  /* FreeRTOS component BEGIN */
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  * (KERNEL)
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  __VECTOR_TABLE_START = __vector_table;
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  . = ALIGN(0x4);
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  *(.rdata)
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  . = ALIGN(0x4);
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  *(.exception)
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  . = ALIGN(0x4);
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  __exception_table_start__ = .;
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  /* EXCEPTION */
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  __exception_table_end__ = .;
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  __sinit__ = .;
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  /* STATICINIT */
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  /* FreeRTOS component END */
%-
%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

#ifndef __BWUserType_Tsize_t
#define __BWUserType_Tsize_t
  typedef size_t Tsize_t;                                        %>40/* Alias to size_t standard type */
#endif

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-
%-BW_CUSTOM_USERTYPE_END

%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskCreate
%ifdef xTaskCreate

#define %'ModuleName'%.%xTaskCreate(pvTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pvCreatedTask) \
        xTaskCreate(pvTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pvCreatedTask)
%define! ParpvTaskCode
%define! ParpcName
%define! ParusStackDepth
%define! ParpvParameters
%define! ParuxPriority
%define! ParpvCreatedTask
%define! RetVal
%include Common\FreeRTOSxTaskCreate.Inc

%endif %- xTaskCreate
%-BW_METHOD_END xTaskCreate
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskDelete
%ifdef vTaskDelete
#define %'ModuleName'%.%vTaskDelete(pxTask) \
        vTaskDelete(pxTask)
%define! ParpxTask
%include Common\FreeRTOSvTaskDelete.Inc

%endif %- vTaskDelete
%-BW_METHOD_END vTaskDelete
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskStartScheduler
%ifdef vTaskStartScheduler
#define %'ModuleName'%.%vTaskStartScheduler() \
  vTaskStartScheduler()
%include Common\FreeRTOSvTaskStartScheduler.Inc

%endif %- vTaskStartScheduler
%-BW_METHOD_END vTaskStartScheduler
%-************************************************************************************************************
%-BW_METHOD_BEGIN taskYIELD
%ifdef taskYIELD
#define %'ModuleName'%.%taskYIELD() \
  taskYIELD()
%include Common\FreeRTOStaskYIELD.Inc

%endif %- taskYIELD
%-BW_METHOD_END taskYIELD
%-************************************************************************************************************
%-BW_METHOD_BEGIN taskENTER_CRITICAL
%ifdef taskENTER_CRITICAL
#define %'ModuleName'%.%taskENTER_CRITICAL() \
  taskENTER_CRITICAL()
%include Common\FreeRTOStaskENTER_CRITICAL.Inc

%endif %- taskENTER_CRITICAL
%-BW_METHOD_END taskENTER_CRITICAL
%-************************************************************************************************************
%-BW_METHOD_BEGIN taskEXIT_CRITICAL
%ifdef taskEXIT_CRITICAL
#define %'ModuleName'%.%taskEXIT_CRITICAL() \
  taskEXIT_CRITICAL()
%include Common\FreeRTOStaskEXIT_CRITICAL.Inc

%endif %- taskEXIT_CRITICAL
%-BW_METHOD_END taskEXIT_CRITICAL
%-************************************************************************************************************
%-BW_METHOD_BEGIN taskDISABLE_INTERRUPTS
%ifdef taskDISABLE_INTERRUPTS
#define %'ModuleName'%.%taskDISABLE_INTERRUPTS() \
  taskDISABLE_INTERRUPTS()
%include Common\FreeRTOStaskDISABLE_INTERRUPTS.Inc

%endif %- taskDISABLE_INTERRUPTS
%-BW_METHOD_END taskDISABLE_INTERRUPTS
%-************************************************************************************************************
%-BW_METHOD_BEGIN taskENABLE_INTERRUPTS
%ifdef taskENABLE_INTERRUPTS
#define %'ModuleName'%.%taskENABLE_INTERRUPTS() \
  taskENABLE_INTERRUPTS()
%include Common\FreeRTOStaskENABLE_INTERRUPTS.Inc

%endif %- taskENABLE_INTERRUPTS
%-BW_METHOD_END taskENABLE_INTERRUPTS
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskEndScheduler
%ifdef vTaskEndScheduler
#define %'ModuleName'%.%vTaskEndScheduler() \
  vTaskEndScheduler()
%include Common\FreeRTOSvTaskEndScheduler.Inc

%endif %- vTaskEndScheduler
%-BW_METHOD_END vTaskEndScheduler
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskSuspendAll
%ifdef vTaskSuspendAll
#define %'ModuleName'%.%vTaskSuspendAll() \
  vTaskSuspendAll()
%include Common\FreeRTOSvTaskSuspendAll.Inc

%endif %- vTaskSuspendAll
%-BW_METHOD_END vTaskSuspendAll
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskResumeAll
%ifdef xTaskResumeAll
#define %'ModuleName'%.%xTaskResumeAll() \
  xTaskResumeAll()
%define! RetVal
%include Common\FreeRTOSxTaskResumeAll.Inc

%endif %- xTaskResumeAll
%-BW_METHOD_END xTaskResumeAll
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskDelay
%ifdef vTaskDelay
#define %'ModuleName'%.%vTaskDelay(xTicksToDelay) \
  vTaskDelay(xTicksToDelay)
%define! ParxTicksToDelay
%include Common\FreeRTOSvTaskDelay.Inc

%endif %- vTaskDelay
%-BW_METHOD_END vTaskDelay
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskDelayUntil
%ifdef vTaskDelayUntil
#define %'ModuleName'%.%vTaskDelayUntil(pxPreviousWakeTime, xTimeIncrement) \
  vTaskDelayUntil(pxPreviousWakeTime, xTimeIncrement)
%define! ParpxPreviousWakeTime
%define! ParxTimeIncrement
%include Common\FreeRTOSvTaskDelayUntil.Inc

%endif %- vTaskDelayUntil
%-BW_METHOD_END vTaskDelayUntil
%-************************************************************************************************************
%-BW_METHOD_BEGIN uxTaskPriorityGet
%ifdef uxTaskPriorityGet
#define %'ModuleName'%.%uxTaskPriorityGet(pxTask) \
  uxTaskPriorityGet(pxTask)
%define! ParpxTask
%define! RetVal
%include Common\FreeRTOSuxTaskPriorityGet.Inc

%endif %- uxTaskPriorityGet
%-BW_METHOD_END uxTaskPriorityGet
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskPrioritySet
%ifdef vTaskPrioritySet
#define %'ModuleName'%.%vTaskPrioritySet(pxTask, uxNewPriority) \
  vTaskPrioritySet(pxTask, uxNewPriority)
%define! ParpxTask
%define! ParuxNewPriority
%include Common\FreeRTOSvTaskPrioritySet.Inc

%endif %- vTaskPrioritySet
%-BW_METHOD_END vTaskPrioritySet
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreTakeRecursive
%ifdef xSemaphoreTakeRecursive
#define %'ModuleName'%.%xSemaphoreTakeRecursive(xMutex, xBlockTime) \
  xSemaphoreTakeRecursive(xMutex, xBlockTime)

%define! ParxMutex
%define! ParxBlockTime
%define! RetVal
%include Common\FreeRTOSxSemaphoreTakeRecursive.Inc

%endif %- xSemaphoreTakeRecursive
%-BW_METHOD_END xSemaphoreTakeRecursive
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreGiveRecursive
%ifdef xSemaphoreGiveRecursive
#define %'ModuleName'%.%xSemaphoreGiveRecursive(xMutex) \
  xSemaphoreGiveRecursive(xMutex)

%define! ParxMutex
%define! RetVal
%include Common\FreeRTOSxSemaphoreGiveRecursive.Inc

%endif %- xSemaphoreGiveRecursive
%-BW_METHOD_END xSemaphoreGiveRecursive
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreCreateRecursiveMutex
%ifdef xSemaphoreCreateRecursiveMutex
#define %'ModuleName'%.%xSemaphoreCreateRecursiveMutex() \
  xSemaphoreCreateRecursiveMutex()

%define! RetVal
%include Common\FreeRTOSxSemaphoreCreateRecursiveMutex.Inc

%endif %- xSemaphoreCreateRecursiveMutex
%-BW_METHOD_END xSemaphoreCreateRecursiveMutex
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskSuspend
%ifdef vTaskSuspend
#define %'ModuleName'%.%vTaskSuspend(pxTaskToSuspend) \
  vTaskSuspend(pxTaskToSuspend)

%define! ParpxTaskToSuspend
%include Common\FreeRTOSvTaskSuspend.Inc

%endif %- vTaskSuspend
%-BW_METHOD_END vTaskSuspend
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskResume
%ifdef vTaskResume
#define %'ModuleName'%.%vTaskResume(pxTaskToResume) \
  vTaskResume(pxTaskToResume)

%define! ParpxTaskToResume
%include Common\FreeRTOSvTaskResume.Inc

%endif %- vTaskResume
%-BW_METHOD_END vTaskResume
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreCreateMutex
%ifdef xSemaphoreCreateMutex
#define %'ModuleName'%.%xSemaphoreCreateMutex() \
  xSemaphoreCreateMutex()

%define! RetVal
%include Common\FreeRTOSxSemaphoreCreateMutex.Inc

%endif %- xSemaphoreCreateMutex
%-BW_METHOD_END xSemaphoreCreateMutex
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreTake
%ifdef xSemaphoreTake
#define %'ModuleName'%.%xSemaphoreTake(xMutex, xBlockTime) \
  xSemaphoreTake(xMutex, xBlockTime)

%define! ParxMutex
%define! ParxBlockTime
%define! RetVal
%include Common\FreeRTOSxSemaphoreTake.Inc

%endif %- xSemaphoreTake
%-BW_METHOD_END xSemaphoreTake
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreGive
%ifdef xSemaphoreGive
#define %'ModuleName'%.%xSemaphoreGive(xMutex) \
  xSemaphoreGive(xMutex)

%define! ParxMutex
%define! RetVal
%include Common\FreeRTOSxSemaphoreGive.Inc

%endif %- xSemaphoreGive
%-BW_METHOD_END xSemaphoreGive
%-************************************************************************************************************
%-BW_METHOD_BEGIN vSemaphoreCreateBinary
%ifdef vSemaphoreCreateBinary
#define %'ModuleName'%.%vSemaphoreCreateBinary(xSemaphore) \
  vSemaphoreCreateBinary(xSemaphore)

%define! ParxSemaphore
%include Common\FreeRTOSvSemaphoreCreateBinary.Inc

%endif %- vSemaphoreCreateBinary
%-BW_METHOD_END vSemaphoreCreateBinary
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreCreateCounting
%ifdef xSemaphoreCreateCounting
#define %'ModuleName'%.%xSemaphoreCreateCounting(uxMaxCount, uxInitialCount) \
  xSemaphoreCreateCounting(uxMaxCount, uxInitialCount)

%define! ParuxMaxCount
%define! ParuxInitialCount
%define! RetVal
%include Common\FreeRTOSxSemaphoreCreateCounting.Inc

%endif %- xSemaphoreCreateCounting
%-BW_METHOD_END xSemaphoreCreateCounting
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreGiveFromISR
%ifdef xSemaphoreGiveFromISR
#define %'ModuleName'%.%xSemaphoreGiveFromISR(xSemaphore, pxHigherPriorityTaskWoken) \
  xSemaphoreGiveFromISR(xSemaphore, pxHigherPriorityTaskWoken)

%define! ParxSemaphore
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxSemaphoreGiveFromISR.Inc

%endif %- xSemaphoreGiveFromISR
%-BW_METHOD_END xSemaphoreGiveFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN vSemaphoreDelete
%ifdef vSemaphoreDelete
#define %'ModuleName'%.%vSemaphoreDelete(xSemaphore) \
  vSemaphoreDelete(xSemaphore)
%define! ParxSemaphore
%include Common\FreeRTOSvSemaphoreDelete.Inc

%endif %- vSemaphoreDelete
%-BW_METHOD_END vSemaphoreDelete
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskList
%ifdef vTaskList
#define %'ModuleName'%.%vTaskList(pcWriteBuffer, bufSize) \
  vTaskList(pcWriteBuffer, bufSize)

%define! ParpcWriteBuffer
%define! ParbufSize
%include Common\FreeRTOSvTaskList.Inc

%endif %- vTaskList
%-BW_METHOD_END vTaskList
%-************************************************************************************************************
%-BW_METHOD_BEGIN pvPortMalloc
%ifdef pvPortMalloc
#define %'ModuleName'%.%pvPortMalloc(xWantedSize) \
  pvPortMalloc(xWantedSize)
%define! ParxWantedSize
%define! RetVal
%include Common\FreeRTOSpvPortMalloc.Inc

%endif %- pvPortMalloc
%-BW_METHOD_END pvPortMalloc
%-************************************************************************************************************
%-BW_METHOD_BEGIN vPortFree
%ifdef vPortFree
#define %'ModuleName'%.%vPortFree(pv) \
  vPortFree(pv)
%define! Parpv
%include Common\FreeRTOSvPortFree.Inc

%endif %- vPortFree
%-BW_METHOD_END vPortFree
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskGetTickCount
%ifdef xTaskGetTickCount
#define %'ModuleName'%.%xTaskGetTickCount() \
  xTaskGetTickCount()
%define! RetVal
%include Common\FreeRTOSxTaskGetTickCount.Inc

%endif %- xTaskGetTickCount
%-BW_METHOD_END xTaskGetTickCount
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskGetSchedulerState
%ifdef xTaskGetSchedulerState
#define %'ModuleName'%.%xTaskGetSchedulerState() \
  xTaskGetSchedulerState()
%define! RetVal
%include Common\FreeRTOSxTaskGetSchedulerState.Inc

%endif %- xTaskGetSchedulerState
%-BW_METHOD_END xTaskGetSchedulerState
%-************************************************************************************************************
%-BW_METHOD_BEGIN uxTaskGetStackHighWaterMark
%ifdef uxTaskGetStackHighWaterMark
#define %'ModuleName'%.%uxTaskGetStackHighWaterMark(xTask) \
  uxTaskGetStackHighWaterMark(xTask)
%define! ParxTask
%define! RetVal
%include Common\FreeRTOSuxTaskGetStackHighWaterMark.Inc

%endif %- uxTaskGetStackHighWaterMark
%-BW_METHOD_END uxTaskGetStackHighWaterMark
%-************************************************************************************************************
%-BW_METHOD_BEGIN uxTaskGetNumberOfTasks
%ifdef uxTaskGetNumberOfTasks
#define %'ModuleName'%.%uxTaskGetNumberOfTasks() \
  uxTaskGetNumberOfTasks()
%define! RetVal
%include Common\FreeRTOSuxTaskGetNumberOfTasks.Inc

%endif %- uxTaskGetNumberOfTasks
%-BW_METHOD_END uxTaskGetNumberOfTasks
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskGetRunTimeStats
%ifdef vTaskGetRunTimeStats
#define %'ModuleName'%.%vTaskGetRunTimeStats(pcWriteBuffer, bufSize) \
  vTaskGetRunTimeStats(pcWriteBuffer, bufSize)

%define! ParpcWriteBuffer
%define! ParbufSize
%include Common\FreeRTOSvTaskGetRunTimeStats.Inc

%endif %- vTaskGetRunTimeStats
%-BW_METHOD_END vTaskGetRunTimeStats
%-INHERITED_EVENT_BEGIN RuntimeCntr OnInterrupt
%ifdef RuntimeCntr
%ifdef @RuntimeCntr@OnInterrupt
extern dword %'ModuleName'%.RunTimeCounter; /* runtime counter, used for configGENERATE_RUNTIME_STATS */
void %@RuntimeCntr@OnInterrupt(void);

%endif %- @RuntimeCntr@OnInterrupt
%endif
%-INHERITED_EVENT_END RuntimeCntr OnInterrupt
%-************************************************************************************************************
%-BW_METHOD_BEGIN xPortGetFreeHeapSize
%ifdef xPortGetFreeHeapSize
#define %'ModuleName'%.%xPortGetFreeHeapSize() \
  xPortGetFreeHeapSize()

%define! RetVal
%include Common\FreeRTOSxPortGetFreeHeapSize.Inc

%endif %- xPortGetFreeHeapSize
%-BW_METHOD_END xPortGetFreeHeapSize
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueCreate
%ifdef xQueueCreate
#define %'ModuleName'%.%xQueueCreate(uxQueueLength, uxItemSize) \
  xQueueCreate(uxQueueLength, uxItemSize)
%define! ParuxQueueLength
%define! ParuxItemSize
%define! RetVal
%include Common\FreeRTOSxQueueCreate.Inc

%endif %- xQueueCreate
%-BW_METHOD_END xQueueCreate
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueSendToFront
%ifdef xQueueSendToFront
#define %'ModuleName'%.%xQueueSendToFront(xQueue, pvItemToQueue, xTicksToWait) \
  xQueueSendToFront(xQueue, pvItemToQueue, xTicksToWait)
%define! ParxQueue
%define! ParpvItemToQueue
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSxQueueSendToFront.Inc

%endif %- xQueueSendToFront
%-BW_METHOD_END xQueueSendToFront
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueSendToBack
%ifdef xQueueSendToBack
#define %'ModuleName'%.%xQueueSendToBack(xQueue, pvItemToQueue, xTicksToWait) \
  xQueueSendToBack(xQueue, pvItemToQueue, xTicksToWait)
%define! ParxQueue
%define! ParpvItemToQueue
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSxQueueSendToBack.Inc

%endif %- xQueueSendToBack
%-BW_METHOD_END xQueueSendToBack
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueReceive
%ifdef xQueueReceive
#define %'ModuleName'%.%xQueueReceive(xQueue, pvBuffer, xTicksToWait) \
  xQueueReceive(xQueue, pvBuffer, xTicksToWait)
%define! ParxQueue
%define! ParxTicksToWait
%define! ParpvBuffer
%define! RetVal
%include Common\FreeRTOSxQueueReceive.Inc

%endif %- xQueueReceive
%-BW_METHOD_END xQueueReceive
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueuePeek
%ifdef xQueuePeek
#define %'ModuleName'%.%xQueuePeek(xQueue, pvBuffer, xTicksToWait) \
  xQueuePeek(xQueue, pvBuffer, xTicksToWait)
%define! ParxQueue
%define! ParpvBuffer
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSxQueuePeek.Inc

%endif %- xQueuePeek
%-BW_METHOD_END xQueuePeek
%-************************************************************************************************************
%-BW_METHOD_BEGIN vQueueDelete
%ifdef vQueueDelete
#define %'ModuleName'%.%vQueueDelete(pxQueueToDelete) \
  vQueueDelete(pxQueueToDelete)
%define! ParpxQueueToDelete
%include Common\FreeRTOSvQueueDelete.Inc

%endif %- vQueueDelete
%-BW_METHOD_END vQueueDelete
%-************************************************************************************************************
%-BW_METHOD_BEGIN uxQueueMessagesWaiting
%ifdef uxQueueMessagesWaiting
#define %'ModuleName'%.%uxQueueMessagesWaiting(xQueue) \
  uxQueueMessagesWaiting(xQueue)
%define! ParxQueue
%define! RetVal
%include Common\FreeRTOSuxQueueMessagesWaiting.Inc

%endif %- uxQueueMessagesWaiting
%-BW_METHOD_END uxQueueMessagesWaiting
%-************************************************************************************************************
%-BW_METHOD_BEGIN uxQueueMessagesWaitingfromISR
%ifdef uxQueueMessagesWaitingfromISR
#define %'ModuleName'%.%uxQueueMessagesWaitingfromISR(xQueue) \
  uxQueueMessagesWaitingfromISR(xQueue)
%define! ParxQueue
%define! RetVal
%include Common\FreeRTOSuxQueueMessagesWaitingfromISR.Inc

%endif %- uxQueueMessagesWaitingfromISR
%-BW_METHOD_END uxQueueMessagesWaitingfromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueReceivefromISR
%ifdef xQueueReceivefromISR
#define %'ModuleName'%.%xQueueReceivefromISR(xQueue, pvBuffer, pxHigherPriorityTaskWoken) \
  xQueueReceivefromISR(xQueue, pvBuffer, pxHigherPriorityTaskWoken)
%define! ParxQueue
%define! ParpvBuffer
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxQueueReceivefromISR.Inc

%endif %- xQueueReceivefromISR
%-BW_METHOD_END xQueueReceivefromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueSendToFrontFromISR
%ifdef xQueueSendToFrontFromISR
#define %'ModuleName'%.%xQueueSendToFrontFromISR(xQueue, pvItemToQueue, pxHigherPriorityTaskWoken) \
  xQueueSendToFrontFromISR(xQueue, pvItemToQueue, pxHigherPriorityTaskWoken)
%define! ParxQueue
%define! ParpvItemToQueue
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxQueueSendToFrontFromISR.Inc

%endif %- xQueueSendToFrontFromISR
%-BW_METHOD_END xQueueSendToFrontFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueSendToBackFromISR
%ifdef xQueueSendToBackFromISR
#define %'ModuleName'%.%xQueueSendToBackFromISR(xQueue, pvItemToQueue,pxHigherPriorityTaskWoken) \
  xQueueSendToBackFromISR(xQueue, pvItemToQueue,pxHigherPriorityTaskWoken)
%define! ParxQueue
%define! ParpvItemToQueue
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxQueueSendToBackFromISR.Inc

%endif %- xQueueSendToBackFromISR
%-BW_METHOD_END xQueueSendToBackFromISR
%-INHERITED_EVENT_BEGIN TickTimerLDD OnCounterRestart
%ifdef TickTimerLDD
%ifdef @TickTimerLDD@OnCounterRestart
void %@TickTimerLDD@OnCounterRestart(LDD_TUserData *UserDataPtr);

%endif %- @TickTimerLDD@OnCounterRestart
%endif %-TickTimerLDD
%-INHERITED_EVENT_END TickTimerLDD OnCounterRestart
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskResumeFromISR
%ifdef xTaskResumeFromISR
#define %'ModuleName'%.%xTaskResumeFromISR(pxTaskToResume) \
  xTaskResumeFromISR(pxTaskToResume)

%define! ParpxTaskToResume
%define! RetVal
%include Common\FreeRTOSxTaskResumeFromISR.Inc

%endif %- xTaskResumeFromISR
%-BW_METHOD_END xTaskResumeFromISR
%-************************************************************************************************************
%-INHERITED_EVENT_BEGIN RuntimeCntrLDD OnCounterRestart
%ifdef RuntimeCntrLDD
%ifdef @RuntimeCntrLDD@OnCounterRestart
extern dword %'ModuleName'%.RunTimeCounter; /* runtime counter, used for configGENERATE_RUNTIME_STATS */
extern LDD_TDeviceData *%'ModuleName'%.RunTimeCounterHandle; /* runtime counter handle, used for configGENERATE_RUNTIME_STATS */
void %@RuntimeCntrLDD@OnCounterRestart(LDD_TUserData *UserDataPtr);

%endif %- @RuntimeCntrLDD@OnCounterRestart
%endif
%-INHERITED_EVENT_END RuntimeCntrLDD OnCounterRestart
%-INHERITED_EVENT_BEGIN TickCntr OnInterrupt
%if defined(TickCntr) & defined(@TickCntr@OnInterrupt)
void %@TickCntr@OnInterrupt(void);

%endif %- @TickCntr@OnInterrupt
%-INHERITED_EVENT_END TickCntr OnInterrupt
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueReset
%ifdef xQueueReset
#define %'ModuleName'%.%xQueueReset(xQueue) \
  xQueueReset(xQueue)

%define! ParxQueue
%define! RetVal
%include Common\FreeRTOSxQueueReset.Inc

%endif %- xQueueReset
%-BW_METHOD_END xQueueReset
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreGetMutexHolder
%ifdef xSemaphoreGetMutexHolder
#define %'ModuleName'%.%xSemaphoreGetMutexHolder(xSemaphore) \
  xSemaphoreGetMutexHolder(xSemaphore)

%define! ParxSemaphore
%define! RetVal
%include Common\FreeRTOSxSemaphoreGetMutexHolder.Inc

%endif %- xSemaphoreGetMutexHolder
%-BW_METHOD_END xSemaphoreGetMutexHolder
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreTakeFromISR
%ifdef xSemaphoreTakeFromISR
#define %'ModuleName'%.%xSemaphoreTakeFromISR(xSemaphore, pxHigherPriorityTaskWoken) \
  xSemaphoreTakeFromISR(xSemaphore, pxHigherPriorityTaskWoken)

%define! ParxSemaphore
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxSemaphoreTakeFromISR.Inc

%endif %- xSemaphoreTakeFromISR
%-BW_METHOD_END xSemaphoreTakeFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseCommand
%ifdef ParseCommand
byte %'ModuleName'%.%ParseCommand(const unsigned char *cmd, bool *handled, const %@Shell@'ModuleName'%.StdIOType *io);
%define! Parcmd
%define! Parhandled
%define! Pario
%define! RetVal
%include Common\FreeRTOSParseCommand.Inc

%endif %- ParseCommand
%-BW_METHOD_END ParseCommand
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
void %'ModuleName'%.%Init(void);
%include Common\FreeRTOSInit.Inc

%endif %- Init
%-BW_METHOD_END Init
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_METHOD_BEGIN vApplicationStackOverflowHook
%ifdef vApplicationStackOverflowHook
%INTERFACE vApplicationStackOverflowHook
void %vApplicationStackOverflowHook(xTaskHandle *pxTask, signed portCHAR *pcTaskName);
%define! ParpxTask
%define! ParpcTaskName
%include Common\FreeRTOSvApplicationStackOverflowHook.Inc

%endif %- vApplicationStackOverflowHook
%-BW_METHOD_END vApplicationStackOverflowHook
%-BW_METHOD_BEGIN vApplicationTickHook
%ifdef vApplicationTickHook
%INTERFACE vApplicationTickHook
void %vApplicationTickHook(void);
%include Common\FreeRTOSvApplicationTickHook.Inc

%endif %- vApplicationTickHook
%-BW_METHOD_END vApplicationTickHook
%-BW_METHOD_BEGIN vApplicationIdleHook
%ifdef vApplicationIdleHook
%INTERFACE vApplicationIdleHook
void %vApplicationIdleHook(void);
%include Common\FreeRTOSvApplicationIdleHook.Inc

%endif %- vApplicationIdleHook
%-BW_METHOD_END vApplicationIdleHook
%-BW_METHOD_BEGIN vApplicationMallocFailedHook
%ifdef vApplicationMallocFailedHook
%INTERFACE vApplicationMallocFailedHook
void %vApplicationMallocFailedHook(void);
%include Common\FreeRTOSvApplicationMallocFailedHook.Inc

%endif %- vApplicationMallocFailedHook
%-BW_METHOD_END vApplicationMallocFailedHook
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\FreeRTOSSettings.Inc
%define! Abstract Common\FreeRTOSAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
#include "portTicks.h"                                           %>40/* interface to tick counter */
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
%-
%if (%CPUfamily = "Kinetis") & (%Compiler = "CodeWarriorARM")
/* The Freescale Kinetis compiler generates different code for the PendSV and PendSVC interrupt handlers in Events.c.
   This requires that different code needs to be used for xPortPendSVHandler() and vPortSVCHandler(). */
#if defined(__optlevel0) || defined(__optlevel1) || defined(__optlevel2) || defined(__optlevel3) || defined(__optlevel4)
  /* Starting with MCU10.2 release, the Kinetis compiler offers the above macros to indicate the optimization level,
     so let's check if we are using the right settings in the FreeRTOS component as well... */
%if %CompilerOptimizationLevel='0'
  #if !defined(__optlevel0) /* FreeRTOS Processor Expert component has set optimization level 0, but compiler has something different? */
%elif %CompilerOptimizationLevel='1'
  #if !defined(__optlevel1) /* FreeRTOS Processor Expert component has set optimization level 1, but compiler has something different? */
%elif %CompilerOptimizationLevel='2'
  #if !defined(__optlevel2) /* FreeRTOS Processor Expert component has set optimization level 2, but compiler has something different? */
%elif %CompilerOptimizationLevel='3'
  #if !defined(__optlevel3) /* FreeRTOS Processor Expert component has set optimization level 3, but compiler has something different? */
%elif %CompilerOptimizationLevel='4'
  #if !defined(__optlevel4) /* FreeRTOS Processor Expert component has set optimization level 4, but compiler has something different? */
%endif
    #error "Mismatch between compiler optimization level and FreeRTOS Processor Expert settings! Please check your compiler and component settings."
  #endif
#endif

%endif
%- NOTE: cannot OR the following two define: MCU6.3 will report an internal error
%if defined(RuntimeCntr) & defined(@RuntimeCntr@OnInterrupt)
dword %'ModuleName'%.RunTimeCounter; /* runtime counter, used for configGENERATE_RUNTIME_STATS */
%elif defined(RuntimeCntrLDD) & defined(@RuntimeCntrLDD@OnCounterRestart)
dword %'ModuleName'%.RunTimeCounter; /* runtime counter, used for configGENERATE_RUNTIME_STATS */
LDD_TDeviceData *%'ModuleName'%.RunTimeCounterHandle; /* runtime counter handle, used for configGENERATE_RUNTIME_STATS */
%endif

%if defined(Shell)
static uint8_t PrintStatus(const %@Shell@'ModuleName'%.StdIOType *io) {
#if configUSE_TRACE_FACILITY || configGENERATE_RUN_TIME_STATS /* FreeRTOS trace feature enabled */
#if FRTOS_MEMORY_SCHEME==1 /* this scheme does not allow deallocation of memory */
  static unsigned char *taskListBufferP=NULL; /* allocated only once, never deallocated! */
#else
  unsigned char *taskListBufferP;
#endif
  size_t bufSize;
#endif
  byte buf[16];

  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"%'ModuleName'", (unsigned char*)"\r\n", io->stdOut);

#if configUSE_TRACE_FACILITY /* FreeRTOS trace feature enabled */
  %@Shell@'ModuleName'%.SendStr((unsigned char*)"TASK LIST:\r\nName\t\tStatus\tPrio\tStack\tTCB#\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)%@Shell@'ModuleName'%.DASH_LINE, io->stdOut);
  /* task list and status */
  bufSize = 40*uxTaskGetNumberOfTasks();  /* about 40 bytes for a task should be enough */
#if FRTOS_MEMORY_SCHEME==1 /* this scheme does not allow deallocation of memory */
  if (taskListBufferP==NULL) { /* only if not allocated yet */
    taskListBufferP = %'ModuleName'%.pvPortMalloc(bufSize); /* about 40 bytes for a task should be enough */
  }
#else
  taskListBufferP = %'ModuleName'%.pvPortMalloc(bufSize); /* about 40 bytes for a task should be enough */
#endif
  if (taskListBufferP != NULL) {
    %'ModuleName'%.vTaskList(taskListBufferP, bufSize);
    %@Shell@'ModuleName'%.SendStr(taskListBufferP, io->stdOut);
#if FRTOS_MEMORY_SCHEME!=1 /* this scheme does not allow deallocation of memory */
    %'ModuleName'%.vPortFree(taskListBufferP);
#endif
  } else {
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n*** out of heap! ***\r\n", io->stdErr);
  }
#endif
#if configGENERATE_RUN_TIME_STATS
  %@Shell@'ModuleName'%.SendStr((unsigned char*)%@Shell@'ModuleName'%.DASH_LINE, io->stdOut);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\nRTOS RUN-TIME STATISTICS:\r\nName\tTime (ms)\t%%Time\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)%@Shell@'ModuleName'%.DASH_LINE, io->stdOut);
  /* task list and status */
  bufSize = 40*uxTaskGetNumberOfTasks();  /* about 40 bytes for a task should be enough */
#if FRTOS_MEMORY_SCHEME==1 /* this scheme does not allow deallocation of memory */
  if (taskListBufferP==NULL) { /* only if not allocated yet */
    taskListBufferP = %'ModuleName'%.pvPortMalloc(bufSize);
  }
#else
  taskListBufferP = %'ModuleName'%.pvPortMalloc(bufSize);
#endif
  if (taskListBufferP != NULL) {
    %'ModuleName'%.vTaskGetRunTimeStats(taskListBufferP, bufSize);
    %@Shell@'ModuleName'%.SendStr(taskListBufferP, io->stdOut);
#if FRTOS_MEMORY_SCHEME!=1 /* this scheme does not allow deallocation of memory */
    %'ModuleName'%.vPortFree(taskListBufferP);
#endif
  } else {
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n*** out of heap! ***\r\n", io->stdErr);
  }
#endif
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"RTOS ticks", (const unsigned char*)"", io->stdOut);
  %@Utility@'ModuleName'%.Num16sToStr(buf, sizeof(buf), configTICK_RATE_HZ);
  %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)" Hz, ", io->stdOut);
  %@Utility@'ModuleName'%.Num16sToStr(buf, sizeof(buf), 1000/configTICK_RATE_HZ);
  %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)" ms\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"Free heap", (const unsigned char*)"", io->stdOut);
  %@Utility@'ModuleName'%.Num32uToStr(buf, sizeof(buf), %'ModuleName'%.xPortGetFreeHeapSize());
  %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)" bytes\r\n", io->stdOut);

  return ERR_OK;
}

static uint8_t PrintHelp(const %@Shell@'ModuleName'%.StdIOType *io) {
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"%'ModuleName'", (unsigned char*)"Group of %'ModuleName' commands\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  help|status", (unsigned char*)"Print help or status information\r\n", io->stdOut);
  return ERR_OK;
}

%endif
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskCreate
%ifdef xTaskCreate
%define! ParpvTaskCode
%define! ParpcName
%define! ParusStackDepth
%define! ParpvParameters
%define! ParuxPriority
%define! ParpvCreatedTask
%define! RetVal
%include Common\FreeRTOSxTaskCreate.Inc
/*
portBASE_TYPE %'ModuleName'%.%xTaskCreate(pdTASK_CODE pvTaskCode, const portCHAR * const pcName, unsigned portSHORT usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pvCreatedTask)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTaskCreate
%-BW_METHOD_END xTaskCreate
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskDelete
%ifdef vTaskDelete
%define! ParpxTask
%include Common\FreeRTOSvTaskDelete.Inc
/*
void %'ModuleName'%.%vTaskDelete(xTaskHandle pxTask)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskDelete
%-BW_METHOD_END vTaskDelete
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskStartScheduler
%ifdef vTaskStartScheduler
%include Common\FreeRTOSvTaskStartScheduler.Inc
/*
void %'ModuleName'%.%vTaskStartScheduler(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskStartScheduler
%-BW_METHOD_END vTaskStartScheduler
%-************************************************************************************************************
%-BW_METHOD_BEGIN taskYIELD
%ifdef taskYIELD
%include Common\FreeRTOStaskYIELD.Inc
/*
void %'ModuleName'%.%taskYIELD(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- taskYIELD
%-BW_METHOD_END taskYIELD
%-************************************************************************************************************
%-BW_METHOD_BEGIN taskENTER_CRITICAL
%ifdef taskENTER_CRITICAL
%include Common\FreeRTOStaskENTER_CRITICAL.Inc
/*
void %'ModuleName'%.%taskENTER_CRITICAL(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- taskENTER_CRITICAL
%-BW_METHOD_END taskENTER_CRITICAL
%-************************************************************************************************************
%-BW_METHOD_BEGIN taskEXIT_CRITICAL
%ifdef taskEXIT_CRITICAL
%include Common\FreeRTOStaskEXIT_CRITICAL.Inc
/*
void %'ModuleName'%.%taskEXIT_CRITICAL(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- taskEXIT_CRITICAL
%-BW_METHOD_END taskEXIT_CRITICAL
%-************************************************************************************************************
%-BW_METHOD_BEGIN taskDISABLE_INTERRUPTS
%ifdef taskDISABLE_INTERRUPTS
%include Common\FreeRTOStaskDISABLE_INTERRUPTS.Inc
/*
void %'ModuleName'%.%taskDISABLE_INTERRUPTS(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- taskDISABLE_INTERRUPTS
%-BW_METHOD_END taskDISABLE_INTERRUPTS
%-************************************************************************************************************
%-BW_METHOD_BEGIN taskENABLE_INTERRUPTS
%ifdef taskENABLE_INTERRUPTS
%include Common\FreeRTOStaskENABLE_INTERRUPTS.Inc
/*
void %'ModuleName'%.%taskENABLE_INTERRUPTS(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- taskENABLE_INTERRUPTS
%-BW_METHOD_END taskENABLE_INTERRUPTS
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskEndScheduler
%ifdef vTaskEndScheduler
%include Common\FreeRTOSvTaskEndScheduler.Inc
/*
void %'ModuleName'%.%vTaskEndScheduler(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskEndScheduler
%-BW_METHOD_END vTaskEndScheduler
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskSuspendAll
%ifdef vTaskSuspendAll
%include Common\FreeRTOSvTaskSuspendAll.Inc
/*
void %'ModuleName'%.%vTaskSuspendAll(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskSuspendAll
%-BW_METHOD_END vTaskSuspendAll
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskResumeAll
%ifdef xTaskResumeAll
%define! RetVal
%include Common\FreeRTOSxTaskResumeAll.Inc
/*
portBASE_TYPE %'ModuleName'%.%xTaskResumeAll(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTaskResumeAll
%-BW_METHOD_END xTaskResumeAll
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskResumeFromISR
%ifdef xTaskResumeFromISR
%define! ParpxTaskToResume
%define! RetVal
%include Common\FreeRTOSxTaskResumeFromISR.Inc
/*
portBASE_TYPE %'ModuleName'%.%xTaskResumeFromISR(xTaskHandle pxTaskToResume)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTaskResumeFromISR
%-BW_METHOD_END xTaskResumeFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskDelay
%ifdef vTaskDelay
%define! ParxTicksToDelay
%include Common\FreeRTOSvTaskDelay.Inc
/*
void %'ModuleName'%.%vTaskDelay(portTickType xTicksToDelay)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskDelay
%-BW_METHOD_END vTaskDelay
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskDelayUntil
%ifdef vTaskDelayUntil
%define! ParpxPreviousWakeTime
%define! ParxTimeIncrement
%include Common\FreeRTOSvTaskDelayUntil.Inc
/*
void %'ModuleName'%.%vTaskDelayUntil(portTickType *pxPreviousWakeTime, portTickType xTimeIncrement)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskDelayUntil
%-BW_METHOD_END vTaskDelayUntil
%-************************************************************************************************************
%-BW_METHOD_BEGIN uxTaskPriorityGet
%ifdef uxTaskPriorityGet
%define! ParpxTask
%define! RetVal
%include Common\FreeRTOSuxTaskPriorityGet.Inc
/*
unsigned_portBASE_TYPE %'ModuleName'%.%uxTaskPriorityGet(xTaskHandle pxTask)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- uxTaskPriorityGet
%-BW_METHOD_END uxTaskPriorityGet
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskPrioritySet
%ifdef vTaskPrioritySet
%define! ParpxTask
%define! ParuxNewPriority
%include Common\FreeRTOSvTaskPrioritySet.Inc
/*
void %'ModuleName'%.%vTaskPrioritySet(xTaskHandle pxTask, unsigned_portBASE_TYPE uxNewPriority)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskPrioritySet
%-BW_METHOD_END vTaskPrioritySet
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreTakeRecursive
%ifdef xSemaphoreTakeRecursive
%define! ParxMutex
%define! ParxBlockTime
%define! RetVal
%include Common\FreeRTOSxSemaphoreTakeRecursive.Inc
/*
bool %'ModuleName'%.%xSemaphoreTakeRecursive(xSemaphoreHandle xMutex, portTickType xBlockTime)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xSemaphoreTakeRecursive
%-BW_METHOD_END xSemaphoreTakeRecursive
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreGiveRecursive
%ifdef xSemaphoreGiveRecursive
%define! ParxMutex
%define! RetVal
%include Common\FreeRTOSxSemaphoreGiveRecursive.Inc
/*
bool %'ModuleName'%.%xSemaphoreGiveRecursive(xSemaphoreHandle xMutex)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xSemaphoreGiveRecursive
%-BW_METHOD_END xSemaphoreGiveRecursive
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreCreateRecursiveMutex
%ifdef xSemaphoreCreateRecursiveMutex
%define! RetVal
%include Common\FreeRTOSxSemaphoreCreateRecursiveMutex.Inc
/*
xSemaphoreHandle %'ModuleName'%.%xSemaphoreCreateRecursiveMutex(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xSemaphoreCreateRecursiveMutex
%-BW_METHOD_END xSemaphoreCreateRecursiveMutex
%-************************************************************************************************************
%-BW_METHOD_BEGIN vSemaphoreDelete
%ifdef vSemaphoreDelete
%define! ParxSemaphore
%include Common\FreeRTOSvSemaphoreDelete.Inc
/*
void %'ModuleName'%.%vSemaphoreDelete(xSemaphoreHandle xSemaphore)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vSemaphoreDelete
%-BW_METHOD_END vSemaphoreDelete
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskSuspend
%ifdef vTaskSuspend
%define! ParpxTaskToSuspend
%include Common\FreeRTOSvTaskSuspend.Inc
/*
void %'ModuleName'%.%vTaskSuspend(xTaskHandle pxTaskToSuspend)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskSuspend
%-BW_METHOD_END vTaskSuspend
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskResume
%ifdef vTaskResume
%define! ParpxTaskToResume
%include Common\FreeRTOSvTaskResume.Inc
/*
void %'ModuleName'%.%vTaskResume(xTaskHandle pxTaskToResume)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskResume
%-BW_METHOD_END vTaskResume
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreCreateMutex
%ifdef xSemaphoreCreateMutex
%define! RetVal
%include Common\FreeRTOSxSemaphoreCreateMutex.Inc
/*
xSemaphoreHandle %'ModuleName'%.%xSemaphoreCreateMutex(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xSemaphoreCreateMutex
%-BW_METHOD_END xSemaphoreCreateMutex
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreTake
%ifdef xSemaphoreTake
%define! ParxMutex
%define! ParxBlockTime
%define! RetVal
%include Common\FreeRTOSxSemaphoreTake.Inc
/*
bool %'ModuleName'%.%xSemaphoreTake(xSemaphoreHandle xMutex, portTickType xBlockTime)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xSemaphoreTake
%-BW_METHOD_END xSemaphoreTake
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreGive
%ifdef xSemaphoreGive
%define! ParxMutex
%define! RetVal
%include Common\FreeRTOSxSemaphoreGive.Inc
/*
bool %'ModuleName'%.%xSemaphoreGive(xSemaphoreHandle xMutex)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xSemaphoreGive
%-BW_METHOD_END xSemaphoreGive
%-************************************************************************************************************
%-BW_METHOD_BEGIN vSemaphoreCreateBinary
%ifdef vSemaphoreCreateBinary
%define! ParxSemaphore
%include Common\FreeRTOSvSemaphoreCreateBinary.Inc
/*
void %'ModuleName'%.%vSemaphoreCreateBinary(xSemaphoreHandle xSemaphore)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vSemaphoreCreateBinary
%-BW_METHOD_END vSemaphoreCreateBinary
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreCreateCounting
%ifdef xSemaphoreCreateCounting
%define! ParuxMaxCount
%define! ParuxInitialCount
%define! RetVal
%include Common\FreeRTOSxSemaphoreCreateCounting.Inc
/*
xSemaphoreHandle %'ModuleName'%.%xSemaphoreCreateCounting(unsigned_portBASE_TYPE uxMaxCount, unsigned_portBASE_TYPE uxInitialCount)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xSemaphoreCreateCounting
%-BW_METHOD_END xSemaphoreCreateCounting
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreGiveFromISR
%ifdef xSemaphoreGiveFromISR
%define! ParxSemaphore
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxSemaphoreGiveFromISR.Inc
/*
bool %'ModuleName'%.%xSemaphoreGiveFromISR(xSemaphoreHandle xSemaphore, signed_portBASE_TYPE *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xSemaphoreGiveFromISR
%-BW_METHOD_END xSemaphoreGiveFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskList
%ifdef vTaskList
%define! ParpcWriteBuffer
%define! ParbufSize
%include Common\FreeRTOSvTaskList.Inc
/*
void %'ModuleName'%.%vTaskList(signed portCHAR *pcWriteBuffer, size_t bufSize)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskList
%-BW_METHOD_END vTaskList
%-************************************************************************************************************
%-BW_METHOD_BEGIN pvPortMalloc
%ifdef pvPortMalloc
%define! ParxWantedSize
%define! RetVal
%include Common\FreeRTOSpvPortMalloc.Inc
/*
pVoid %'ModuleName'%.%pvPortMalloc(size_t xWantedSize)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- pvPortMalloc
%-BW_METHOD_END pvPortMalloc
%-************************************************************************************************************
%-BW_METHOD_BEGIN vPortFree
%ifdef vPortFree
%define! Parpv
%include Common\FreeRTOSvPortFree.Inc
/*
void %'ModuleName'%.%vPortFree(void *pv)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vPortFree
%-BW_METHOD_END vPortFree
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskGetTickCount
%ifdef xTaskGetTickCount
%define! RetVal
%include Common\FreeRTOSxTaskGetTickCount.Inc
/*
portTickType %'ModuleName'%.%xTaskGetTickCount(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTaskGetTickCount
%-BW_METHOD_END xTaskGetTickCount
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskGetSchedulerState
%ifdef xTaskGetSchedulerState
%define! RetVal
%include Common\FreeRTOSxTaskGetSchedulerState.Inc
/*
portBASE_TYPE %'ModuleName'%.%xTaskGetSchedulerState(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTaskGetSchedulerState
%-BW_METHOD_END xTaskGetSchedulerState
%-************************************************************************************************************
%-BW_METHOD_BEGIN uxTaskGetStackHighWaterMark
%ifdef uxTaskGetStackHighWaterMark
%define! ParxTask
%define! RetVal
%include Common\FreeRTOSuxTaskGetStackHighWaterMark.Inc
/*
unsigned_portBASE_TYPE %'ModuleName'%.%uxTaskGetStackHighWaterMark(xTaskHandle xTask)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- uxTaskGetStackHighWaterMark
%-BW_METHOD_END uxTaskGetStackHighWaterMark
%-************************************************************************************************************
%-BW_METHOD_BEGIN uxTaskGetNumberOfTasks
%ifdef uxTaskGetNumberOfTasks
%define! RetVal
%include Common\FreeRTOSuxTaskGetNumberOfTasks.Inc
/*
unsigned_portBASE_TYPE %'ModuleName'%.%uxTaskGetNumberOfTasks(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- uxTaskGetNumberOfTasks
%-BW_METHOD_END uxTaskGetNumberOfTasks
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskGetRunTimeStats
%ifdef vTaskGetRunTimeStats
%define! ParpcWriteBuffer
%define! ParbufSize
%include Common\FreeRTOSvTaskGetRunTimeStats.Inc
/*
void %'ModuleName'%.%vTaskGetRunTimeStats(portCHAR *pcWriteBuffer, size_t bufSize)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskGetRunTimeStats
%-BW_METHOD_END vTaskGetRunTimeStats
%-INHERITED_EVENT_BEGIN RuntimeCntr OnInterrupt
%ifdef RuntimeCntr
%ifdef @RuntimeCntr@OnInterrupt
%include Common\GeneralInternal.inc (OnInterrupt)
void %@RuntimeCntr@OnInterrupt(void)
{
  %'ModuleName'%.RunTimeCounter++; /* increment runtime counter */
}

%endif %- @RuntimeCntr@OnInterrupt
%endif
%-INHERITED_EVENT_END RuntimeCntr OnInterrupt
%-************************************************************************************************************
%-BW_METHOD_BEGIN xPortGetFreeHeapSize
%ifdef xPortGetFreeHeapSize
%define! RetVal
%include Common\FreeRTOSxPortGetFreeHeapSize.Inc
/*
Tsize_t %'ModuleName'%.%xPortGetFreeHeapSize(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xPortGetFreeHeapSize
%-BW_METHOD_END xPortGetFreeHeapSize
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueCreate
%ifdef xQueueCreate
%define! ParuxQueueLength
%define! ParuxItemSize
%define! RetVal
%include Common\FreeRTOSxQueueCreate.Inc
/*
xQueueHandle %'ModuleName'%.%xQueueCreate(unsigned_portBASE_TYPE uxQueueLength, unsigned_portBASE_TYPE uxItemSize)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueueCreate
%-BW_METHOD_END xQueueCreate
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueSendToFront
%ifdef xQueueSendToFront
%define! ParxQueue
%define! ParpvItemToQueue
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSxQueueSendToFront.Inc
/*
portBASE_TYPE %'ModuleName'%.%xQueueSendToFront(xQueueHandle xQueue, const void *pvItemToQueue, portTickType xTicksToWait)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueueSendToFront
%-BW_METHOD_END xQueueSendToFront
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueSendToBack
%ifdef xQueueSendToBack
%define! ParxQueue
%define! ParpvItemToQueue
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSxQueueSendToBack.Inc
/*
portBASE_TYPE %'ModuleName'%.%xQueueSendToBack(xQueueHandle xQueue, const void *pvItemToQueue, portTickType xTicksToWait)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueueSendToBack
%-BW_METHOD_END xQueueSendToBack
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueReceive
%ifdef xQueueReceive
%define! ParxQueue
%define! ParxTicksToWait
%define! ParpvBuffer
%define! RetVal
%include Common\FreeRTOSxQueueReceive.Inc
/*
portBASE_TYPE %'ModuleName'%.%xQueueReceive(xQueueHandle xQueue, void *pvBuffer, portTickType xTicksToWait)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueueReceive
%-BW_METHOD_END xQueueReceive
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueuePeek
%ifdef xQueuePeek
%define! ParxQueue
%define! ParpvBuffer
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSxQueuePeek.Inc
/*
portBASE_TYPE %'ModuleName'%.%xQueuePeek(xQueueHandle xQueue, void *pvBuffer, portTickType xTicksToWait)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueuePeek
%-BW_METHOD_END xQueuePeek
%-************************************************************************************************************
%-BW_METHOD_BEGIN vQueueDelete
%ifdef vQueueDelete
%define! ParpxQueueToDelete
%include Common\FreeRTOSvQueueDelete.Inc
/*
void %'ModuleName'%.%vQueueDelete(xQueueHandle pxQueueToDelete)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vQueueDelete
%-BW_METHOD_END vQueueDelete
%-************************************************************************************************************
%-BW_METHOD_BEGIN uxQueueMessagesWaiting
%ifdef uxQueueMessagesWaiting
%define! ParxQueue
%define! RetVal
%include Common\FreeRTOSuxQueueMessagesWaiting.Inc
/*
unsigned_portBASE_TYPE %'ModuleName'%.%uxQueueMessagesWaiting(xQueueHandle xQueue)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- uxQueueMessagesWaiting
%-BW_METHOD_END uxQueueMessagesWaiting
%-************************************************************************************************************
%-BW_METHOD_BEGIN uxQueueMessagesWaitingfromISR
%ifdef uxQueueMessagesWaitingfromISR
%define! ParxQueue
%define! RetVal
%include Common\FreeRTOSuxQueueMessagesWaitingfromISR.Inc
/*
unsigned_portBASE_TYPE %'ModuleName'%.%uxQueueMessagesWaitingfromISR(xQueueHandle xQueue)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- uxQueueMessagesWaitingfromISR
%-BW_METHOD_END uxQueueMessagesWaitingfromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueReceivefromISR
%ifdef xQueueReceivefromISR
%define! ParxQueue
%define! ParpvBuffer
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxQueueReceivefromISR.Inc
/*
portBASE_TYPE %'ModuleName'%.%xQueueReceivefromISR(xQueueHandle xQueue, void *pvBuffer, portBASE_TYPE *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueueReceivefromISR
%-BW_METHOD_END xQueueReceivefromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueSendToFrontFromISR
%ifdef xQueueSendToFrontFromISR
%define! ParxQueue
%define! ParpvItemToQueue
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxQueueSendToFrontFromISR.Inc
/*
portBASE_TYPE %'ModuleName'%.%xQueueSendToFrontFromISR(xQueueHandle xQueue, const void *pvItemToQueue, portBASE_TYPE *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueueSendToFrontFromISR
%-BW_METHOD_END xQueueSendToFrontFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueSendToBackFromISR
%ifdef xQueueSendToBackFromISR
%define! ParxQueue
%define! ParpvItemToQueue
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxQueueSendToBackFromISR.Inc
/*
portBASE_TYPE %'ModuleName'%.%xQueueSendToBackFromISR(xQueueHandle xQueue, const void *pvItemToQueue, portBASE_TYPE *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/
%endif %- xQueueSendToBackFromISR
%-BW_METHOD_END xQueueSendToBackFromISR
%-INHERITED_EVENT_BEGIN TickTimerLDD OnCounterRestart
%ifdef TickTimerLDD
%ifdef @TickTimerLDD@OnCounterRestart
%include Common\GeneralInternal.inc (OnCounterRestart)
%if (%Compiler = "GNUC")
__attribute__((naked)) void %@TickTimerLDD@OnCounterRestart(LDD_TUserData *UserDataPtr __attribute__((unused))) {
%elif (%Compiler = "IARARM")
void %@TickTimerLDD@OnCounterRestart(LDD_TUserData *UserDataPtr) {
%else
void %@TickTimerLDD@OnCounterRestart(LDD_TUserData *UserDataPtr __attribute__((unused))) {
%endif
  vOnCounterRestart();
}

%endif %- @TickTimerLDD@OnCounterRestart
%endif %-TickTimerLDD
%-INHERITED_EVENT_END TickTimerLDD OnCounterRestart
%-************************************************************************************************************
%-INHERITED_EVENT_BEGIN RuntimeCntrLDD OnCounterRestart
%ifdef RuntimeCntrLDD
%ifdef @RuntimeCntrLDD@OnCounterRestart
%include Common\GeneralInternal.inc (OnCounterRestart)
void %@RuntimeCntrLDD@OnCounterRestart(LDD_TUserData *UserDataPtr __attribute__((unused)))
{
  %'ModuleName'%.RunTimeCounter++; /* increment runtime counter */
}

%endif %- @RuntimeCntrLDD@OnCounterRestart
%endif
%-INHERITED_EVENT_END RuntimeCntrLDD OnCounterRestart
%-************************************************************************************************************
%-INHERITED_EVENT_BEGIN TickCntr OnInterrupt
%if defined(TickCntr) & defined(@TickCntr@OnInterrupt)
%include Common\GeneralInternal.inc (OnInterrupt)
%if (CPUfamily = "HCS08") | (CPUfamily = "HC08")
#pragma NO_ENTRY /* do not create entry sequence */
#pragma NO_EXIT  /* do not create exit sequence */
#pragma NO_RETURN /* we care about this (RTI) */
%endif
void %@TickCntr@OnInterrupt(void)
{
  /* NOTE: we are called here from the tick interrupt (periodic timer bean, ISR). However, we need to imitate things in
           a way as this function would be the primary ISR (means that this function would have been raised directly by
           the interrupt. In order to do this, we need to to 'fix' the stack below in a rather hacky way :-( */
%if (CPUfamily = "ColdFireV1") | (CPUfamily = "MCF")
  asm { /* we are called from the main ISR bean: we need to correct stack as if this function would be the main ISR */
    naked                                                        %>40 /* No stack frame or compiler-generated rts */
    LEA     4(A7),A7                                             %>40 /* Remove the 4 bytes from stack from the Processor Export ISR (+JSR to here) */
    /* now simulate exit sequence of caller (this code is at the end of the Processor Expert Bean code */
%if (CPUfamily = "MCF")
%- NOTE: was MOVEM.L 8(A7),D0-D2/A0-A1  for normal periodic tick timer
    MOVEM.L 8(A7),D0-D2/A0-A1                                    %>40 /* Restore cpu registers which were pushed on stack in bean (caller of this function) */
    UNLK    A6                                                   %>40 /* Unlink instruction (normally done in caller/bean code) */
    ADDQ.L  #4,A7                                                %>40 /* normally done in the caller/bean code */
%else
    MOVEM.L (A7),D0-D2/A0-A1                                     %>40 /* Restore cpu registers which were pushed on stack in bean (caller of this function) */
    LEA     20(A7),A7                                            %>40 /* Unlink instruction (normally done in caller/bean code) */
    /* here would be the RTE in the embedded component code */
%endif
    /* now build up the stack frame, as we would be directly called by the interrupt service routine */
    LEA     -24(A7),A7                                           %>40 /* Reserve space for processor registers onto stack */
    MOVEM.L D0-D2/D7/A0-A1,(A7)                                  %>40 /* Save registers */
  }
  /* Increment the RTOS tick. */
  (void)portSET_INTERRUPT_MASK_FROM_ISR(); /* return value is in D0 */
  asm {
    MOVE.L D0, D7 ; /* save ulSavedInterruptMask for later */
  }
  (void)%@TickCntr@'ModuleName'%.Reset(); /* reset tick counter: need this for trace */
  vTaskIncrementTick();
  asm {
    MOVE.L D7,D0
    JSR ulPortSetIPL
  }
  /* If we are using the pre-emptive scheduler then also request a
     context switch as incrementing the tick could have unblocked a task. */
  #if configUSE_PREEMPTION == 1
  taskYIELD();
  #endif
  /* now generate interrupt exit code */
  asm {
    MOVEM.L    (A7),D0-D2/D7/A0-A1                               %>40 /* Restore processor registers from stack */
    LEA        24(A7),A7                                         %>40 /* Remove space from stack */
    RTE                                                          %>40 /* Return to task or nested ISR */
  }
%elif (CPUfamily = "Kinetis")
  /* Kinetis is using LDD apprroach */
%elif (CPUfamily = "HCS08") | (CPUfamily = "HC08")
  __asm {
    PULH  ; remove return address from stack (from JSR to this function)
    PULH
#ifdef __BANKED__
    PULH  ; was a CALL instruction (not a JSR): there are 3 bytes on the stack.
#endif
  }
  #if configUSE_PREEMPTION == 1
    /* A context switch might happen so save the context. */
    portSAVE_CONTEXT();
    %@TickCntr@'ModuleName'%.Reset(); /* reset tick counter: need this for trace */
    vTaskIncrementTick();/* Increment the tick */
    /* ... then see if the new tick value has necessitated a context switch. */
    vTaskSwitchContext();
    /* Restore the context of a task - which may be a different task to that interrupted. */
    portRESTORE_CONTEXT(); /* includes PULH and RTI */
  #else
    %@TickCntr@'ModuleName'%.Reset(); /* reset tick counter: need this for trace */
    vTaskIncrementTick();
    __asm("PULH");
    __asm("RTI");
  #endif
%elif (CPUfamily = "HCS12") | (CPUfamily = "HCS12X")
  asm {
#ifdef __BANKED__
    LEAS 3,SP  ; was a CALL instruction (not a JSR): there are 3 bytes on the stack.
#else
    LEAS 2,SP
#endif
  }
  #if configUSE_PREEMPTION == 1
    /* A context switch might happen so save the context. */
    portSAVE_CONTEXT();
    %@TickCntr@'ModuleName'%.Reset(); /* reset tick counter: need this for trace */
    vTaskIncrementTick(); /* Increment the tick */
    /* ... then see if the new tick value has necessitated a context switch. */
    vTaskSwitchContext();
    /* Restore the context of a task - which may be a different task to that interrupted. */
    portRESTORE_CONTEXT(); /* includes RTI */
  #else
    %@TickCntr@'ModuleName'%.Reset(); /* reset tick counter: need this for trace */
    vTaskIncrementTick();
    __asm("RTI"); /* return from interrupt */
  #endif
%elif (CPUfamily = "56800")
//  asm { /* we are called from the main ISR bean: we need to correct stack as if this function would be the main ISR */
//    naked                                                      %>40 /* No stack frame or compiler-generated rts */
//    LEA     4(A7),A7                                           %>40 /* Remove the 4 bytes from stack from the Processor Export ISR (+JSR to here) */
//    /* now simulate exit sequence of caller (this code is at the end of the Processor Expert Bean code */
//    MOVEM.L (A7),D0-D2/A0-A1                                   %>40 /* Restore cpu registers which were pushed on stack in bean (caller of this function) */
//    LEA     20(A7),A7                                          %>40 /* Unlink instruction (normally done in caller/bean code) */
    /* here would be the RTE in the embedded component code */
    /* now build up the stack frame, as we would be directly called by the interrupt service routine */
//    LEA     -24(A7),A7                                         %>40 /* Reserve space for processor registers onto stack */
//    MOVEM.L D0-D2/D7/A0-A1,(A7)                                %>40 /* Save registers */
//  }
  /* Increment the RTOS tick. */
  (void)portSET_INTERRUPT_MASK_FROM_ISR(); /* return value is in D0 */
//  asm {
//    MOVE.L D0, D7 ; /* save ulSavedInterruptMask for later */
//  }
  {
     %@TickCntr@'ModuleName'%.Reset(); /* reset tick counter: need this for trace */
     vTaskIncrementTick();
  }
//  asm {
//    MOVE.L D7,D0
//    JSR ulPortSetIPL
//  }

  /* If we are using the pre-emptive scheduler then also request a
     context switch as incrementing the tick could have unblocked a task. */
  #if configUSE_PREEMPTION == 1
  {
    taskYIELD();
  }
  #endif
  /* now generate interrupt exit code */
//  asm {
//    MOVEM.L    (A7),D0-D2/D7/A0-A1                             %>40 /* Restore processor registers from stack */
//    LEA        24(A7),A7                                       %>40 /* Remove space from stack */
//    RTE                                                        %>40 /* Return to task or nested ISR */
//  }
%else
  #error "CPU %CPUfamily not supported"
%endif
}

%endif %- @TickCntr@OnInterrupt
%-INHERITED_EVENT_END TickCntr OnInterrupt
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueReset
%ifdef xQueueReset
%define! ParxQueue
%define! RetVal
%include Common\FreeRTOSxQueueReset.Inc
/*
portBASE_TYPE %'ModuleName'%.%xQueueReset(xQueueHandle xQueue)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueueReset
%-BW_METHOD_END xQueueReset
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreGetMutexHolder
%ifdef xSemaphoreGetMutexHolder
%define! ParxSemaphore
%define! RetVal
%include Common\FreeRTOSxSemaphoreGetMutexHolder.Inc
/*
void* %'ModuleName'%.%xSemaphoreGetMutexHolder(xSemaphoreHandle xSemaphore)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xSemaphoreGetMutexHolder
%-BW_METHOD_END xSemaphoreGetMutexHolder
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreTakeFromISR
%ifdef xSemaphoreTakeFromISR
%define! ParxSemaphore
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxSemaphoreTakeFromISR.Inc
/*
bool %'ModuleName'%.%xSemaphoreTakeFromISR(xSemaphoreHandle xSemaphore, signed_portBASE_TYPE *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xSemaphoreTakeFromISR
%-BW_METHOD_END xSemaphoreTakeFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseCommand
%ifdef ParseCommand
%define! Parcmd
%define! Parhandled
%define! Pario
%define! RetVal
%include Common\FreeRTOSParseCommand.Inc
byte %'ModuleName'%.%ParseCommand(const unsigned char *cmd, bool *handled, const %@Shell@'ModuleName'%.StdIOType *io)
{
  if (%@Utility@'ModuleName'%.strcmp((char*)cmd, %@Shell@'ModuleName'%.CMD_HELP)==0 || %@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' help")==0) {
    *handled = TRUE;
    return PrintHelp(io);
  } else if ((%@Utility@'ModuleName'%.strcmp((char*)cmd, %@Shell@'ModuleName'%.CMD_STATUS)==0) || (%@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' status")==0)) {
    *handled = TRUE;
    return PrintStatus(io);
  }
  return ERR_OK;
}

%endif %- ParseCommand
%-BW_METHOD_END ParseCommand
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%include Common\FreeRTOSInit.Inc
void %'ModuleName'%.%Init(void)
{
  vPortInitTickTimer();
  vPortStopTickTimer();
}

%endif %- Init
%-BW_METHOD_END Init
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_METHOD_BEGIN vApplicationStackOverflowHook
%ifdef vApplicationStackOverflowHook
%IMPLEMENTATION vApplicationStackOverflowHook
%define! ParpxTask
%define! ParpcTaskName
%include Common\FreeRTOSvApplicationStackOverflowHook.Inc
void %vApplicationStackOverflowHook(xTaskHandle *pxTask, signed portCHAR *pcTaskName)
{
  /* This will get called if a stack overflow is detected during the context
     switch.  Set configCHECK_FOR_STACK_OVERFLOWS to 2 to also check for stack
     problems within nested interrupts, but only do this for debug purposes as
     it will increase the context switch time. */
  (void)pxTask;
  (void)pcTaskName;
  taskDISABLE_INTERRUPTS();
  /* Write your code here ... */
  for(;;) {}
}

%endif %- vApplicationStackOverflowHook
%-BW_METHOD_END vApplicationStackOverflowHook
%-BW_METHOD_BEGIN vApplicationTickHook
%ifdef vApplicationTickHook
%IMPLEMENTATION vApplicationTickHook
%include Common\FreeRTOSvApplicationTickHook.Inc
void %vApplicationTickHook(void)
{
  /* Called for every RTOS tick. */
  /* Write your code here ... */
}

%endif %- vApplicationTickHook
%-BW_METHOD_END vApplicationTickHook
%-BW_METHOD_BEGIN vApplicationIdleHook
%ifdef vApplicationIdleHook
%IMPLEMENTATION vApplicationIdleHook
%include Common\FreeRTOSvApplicationIdleHook.Inc
void %vApplicationIdleHook(void)
{
  /* Called whenever the RTOS is idle (from the IDLE task).
     Here would be a good place to put the CPU into low power mode. */
%if (CPUfamily = "HCS08") | (CPUfamily = "HC08") | (CPUfamily = "ColdFireV1")
#if 0
  /* To put the CPU into lower power WAIT mode:
     - Make sure that in the CPU component the method 'SetWaitMode()' is enabled
     - Enable this code block (change '#if 0' to '#if 1')
   */
    %'ProcessorModule'%.SetWaitMode();
#endif
%elif (CPUfamily = "MCF")
#if 0
  /* To put the ColdFire V2 CPU into low power WAIT mode:
     - In the CPU component, go to 'Properties > Internal peripherals > PowerManagement > Low-power mode'
       - Set 'Low-power stop mode' to 'Enabled'
       - Set 'Low-power mode select' to 'WAIT'
     - Enable this code block (change '#if 0' to '#if 1')
     - Note: if you are using USB then putting the CPU into lower power mode might impact USB communication.
   */
    __asm("stop #0x2000"); /* put CPU into stop mode */
#endif
%endif
  /* Write your code here ... */
}

%endif %- vApplicationIdleHook
%-BW_METHOD_END vApplicationIdleHook
%-BW_METHOD_BEGIN vApplicationMallocFailedHook
%ifdef vApplicationMallocFailedHook
%IMPLEMENTATION vApplicationMallocFailedHook
%include Common\FreeRTOSvApplicationMallocFailedHook.Inc
void %vApplicationMallocFailedHook(void)
{
  /* Called if a call to pvPortMalloc() fails because there is insufficient
     free memory available in the FreeRTOS heap.  pvPortMalloc() is called
     internally by FreeRTOS API functions that create tasks, queues, software
     timers, and semaphores.  The size of the FreeRTOS heap is set by the
     configTOTAL_HEAP_SIZE configuration constant in FreeRTOSConfig.h. */
  taskDISABLE_INTERRUPTS();
  /* Write your code here ... */
  for(;;) {}
}

%endif %- vApplicationMallocFailedHook
%-BW_METHOD_END vApplicationMallocFailedHook
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
  %'ModuleName'%.%Init();
%CODE_BEGIN
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This bean is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
