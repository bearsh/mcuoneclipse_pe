%-Driver generated by the Bean Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Bean Wizard
%- If you change these lines, Bean Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    11.07.2008
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%define! Description_Init Initializes the driver
%define! Description_Scan Scans the keys and performs debouncing
%ifdef KBI
  %ifdef @KBI@OnInterrupt
    %define! Description_%@KBI@OnInterrupt This event is called when an active signal edge/level has occurred. The event services the event of the inherited component and eventually invokes other events.
  %endif %- @KBI@OnInterrupt
%endif %- KBI
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\KeySettings.Inc
%define! Abstract Common\KeyAbstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited beans */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"

#define %'ModuleName'%.KEYS_MASK    (0xFFu>>(8-%NumKeys)) /*<! Mask with bits set according to number of keys to handle */
%if PollingEnabled='yes'
%:maxPollingPins=%ScanKeySymbolNumItems
%:maxPollingPins-=1
%endif

typedef byte %'ModuleName'%.KeyStorage; /* we can deal with up to 8 keys */

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-
%-BW_CUSTOM_USERTYPE_END


%-BW_DEFINITION_START
%-Unused %-INHERITED_EVENT_BEGIN KBI OnInterrupt
%-Unused %ifdef @KBI@OnInterrupt
%-Unused void %@KBI@OnInterrupt(void);
%-Unused
%-Unused %endif %- @KBI@OnInterrupt
%-Unused %-INHERITED_EVENT_END KBI OnInterrupt
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG Init
void %'ModuleName'%.Init(void);
%include Common\GeneralInternal.inc (Init)

%-INTERNAL_METHOD_END Init
%-************************************************************************************************************
%-Unused %-INHERITED_EVENT_BEGIN KBI OnAutoWakeup
%-Unused %ifdef @KBI@OnAutoWakeup
%-Unused void %@KBI@OnAutoWakeup(void);
%-Unused
%-Unused %endif %- @KBI@OnAutoWakeup
%-Unused %-INHERITED_EVENT_END KBI OnAutoWakeup
%-INHERITED_EVENT_BEGIN KBI OnInterrupt
%ifdef @KBI@OnInterrupt
void %@KBI@OnInterrupt(void);

%endif %- @KBI@OnInterrupt
%-INHERITED_EVENT_END KBI OnInterrupt
%-************************************************************************************************************
%-BW_METHOD_BEGIN isIdle
%ifdef isIdle
bool %'ModuleName'%.%isIdle(void);
%define! RetVal
%include Common\KeyisIdle.Inc

%endif %- isIdle
%-BW_METHOD_END isIdle
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetKeys
%ifdef GetKeys
#define %'ModuleName'%.%GetKeys() \
%if InterruptEnabled='yes'
  %if (OpenIsLogicalOne='yes')
  ((byte)((~%@KBI@'ModuleName'%.GetVal())&%'ModuleName'%.KEYS_MASK))
  %else
  (%@KBI@'ModuleName'%.GetVal())
  %endif
%else
  (%'ModuleName'%.KeyStorage)(( \
 %if (OpenIsLogicalOne='yes')
    ((%@ScanKeySymb0@'ModuleName'%.GetVal()==0)?1<<0:0)          %>40/* a one bit if key pressed */ \
  %for i from [1..%maxPollingPins]
  | ((%@ScanKeySymb%i@'ModuleName'%.GetVal()==0)?1<<%i:0)        %>40/* a one bit if key pressed */ \
  %endfor
 %else
    ((%@ScanKeySymb0@'ModuleName'%.GetVal()!=0)?1<<0:0)          %>40/* a one bit if key pressed */ \
  %for i from [1..%maxPollingPins]
  | ((%@ScanKeySymb%i@'ModuleName'%.GetVal()!=0)?1<<%i:0)        %>40/* a one bit if key pressed */ \
  %endfor
 %endif
  ))
%endif
%define! RetVal
%include Common\KeyGetKeys.Inc

%endif %- GetKeys
%-BW_METHOD_END GetKeys
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScanKeys
%ifdef ScanKeys
void %'ModuleName'%.%ScanKeys(void);
%include Common\KeyScanKeys.Inc

%endif %- ScanKeys
%-BW_METHOD_END ScanKeys
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_METHOD_BEGIN OnKeyPressed
%ifdef OnKeyPressed
%INTERFACE OnKeyPressed
void %OnKeyPressed(byte keys);
%define! Parkeys
%include Common\KeyOnKeyPressed.Inc

%endif %- OnKeyPressed
%-BW_METHOD_END OnKeyPressed
%-BW_METHOD_BEGIN OnKeyReleased
%ifdef OnKeyReleased
%INTERFACE OnKeyReleased
void %OnKeyReleased(byte keys);
%define! Parkeys
%include Common\KeyOnKeyReleased.Inc

%endif %- OnKeyReleased
%-BW_METHOD_END OnKeyReleased
%-BW_METHOD_BEGIN OnKeyReleasedLong
%ifdef OnKeyReleasedLong
%INTERFACE OnKeyReleasedLong
void %OnKeyReleasedLong(byte keys);
%define! Parkeys
%include Common\KeyOnKeyReleasedLong.Inc

%endif %- OnKeyReleasedLong
%-BW_METHOD_END OnKeyReleasedLong
%-BW_METHOD_BEGIN OnKeyHold
%ifdef OnKeyHold
%INTERFACE OnKeyHold
void %OnKeyHold(byte keys);
%define! Parkeys
%include Common\KeyOnKeyHold.Inc

%endif %- OnKeyHold
%-BW_METHOD_END OnKeyHold
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\KeySettings.Inc
%define! Abstract Common\KeyAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
%-
/*! States of the key detection state machine. */
#define DBC_KEY_IDLE               0  /*<! Initial idle state */
#define DBC_KEY_PRESSED            1  /*<! Key pressing detected, see if it is a long key */
#define DBC_KEY_WAIT_RELEASE       2  /*<! got a short key, wait for release */
%if (LongKeyDetection='yes')
#define DBC_KEY_WAIT_RELEASE_LONG  3  /*<! got a long key, wait for release */
%endif

static byte DBC_KeyState = DBC_KEY_IDLE;
  /*!< status of the state machine to detect long and short keys */
static %'ModuleName'%.KeyStorage DBC_ScanValue;
  /*!< value of keys scanned in */

#define DBC_TRIGGER_TICK_TIME  %@Trigger@'ModuleName'%.TICK_PERIOD_MS /* trigger tick time in ms */

  /*!< Time in ms between two trigger events */
#define DBC_DEBOUNCE_TIME        (%DebounceTime/DBC_TRIGGER_TICK_TIME)
  /*!< Time needed for debouncing */

%if (LongKeyDetection='yes')
static unsigned short DBC_LongKeyCount;
  /*!< counting how long we press a key */
#define DBC_LONG_KEY_TIME_MS     %LongKeyTime  /*!< Long key pressing time, in ms units */
#define DBC_LONG_KEY_ITERATIONS  (DBC_LONG_KEY_TIME_MS/DBC_TRIGGER_TICK_TIME)
  /*!< Number of iterations we need to go for a long key detection. */
%endif

/*! \brief Key scan routine which implements the state machine.
\dot
digraph example_api_graph {
    node [shape=box];
    DBC_IDLE    [fillcolor=lightblue,style=filled,label="DBC_KEY_IDLE" ];
    DBC_PRESSED [fillcolor=lightblue,style=filled,label="DBC_KEY_PRESSED" ];
    DBC_WAIT    [fillcolor=lightblue,style=filled,label="DBC_KEY_WAIT_RELEASE"];
    DBC_IDLE -> DBC_PRESSED -> DBC_WAIT -> DBC_IDLE ;
    DBC_PRESSED -> DBC_PRESSED ;
    DBC_IDLE -> DBC_IDLE ;
}
\enddot
*/
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-UNLOCKED
/* Internal method prototypes */
%-INTERNAL_LOC_METHOD_BEG Scan
static void Scan(void);
%-INTERNAL_LOC_METHOD_END Scan
%-

%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-INTERNAL_METHOD_BEG Init
%include Common\GeneralInternal.inc (Init)
void %'ModuleName'%.Init(void)
{
  DBC_KeyState = DBC_KEY_IDLE;
}

%-INTERNAL_METHOD_END Init
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG Scan
%include Common\GeneralInternalGlobal.inc (Scan)
static void Scan(void)
{
  %'ModuleName'%.KeyStorage keys;
  %@CriticalSection@'ModuleName'%.CriticalVariable();

  %@CriticalSection@'ModuleName'%.EnterCritical();
  switch(DBC_KeyState) {
    case DBC_KEY_IDLE: /* Idle, and now getting a key */
      DBC_ScanValue = %'ModuleName'%.GetKeys();                  %>40/* a one bit indicates key pressed */
      %if PollingEnabled='yes'
      if (DBC_ScanValue==0) {                                    %>40/* no keys pressed */
        %@CriticalSection@'ModuleName'%.ExitCritical();
        return;
      }
      %endif
%if (LongKeyDetection='yes')
      DBC_LongKeyCount = 0;
%endif
      DBC_KeyState = DBC_KEY_PRESSED; /* advance to next state */
%if defined(OnKeyPressed)
      %OnKeyPressed(DBC_ScanValue);
%endif
      %@Trigger@'ModuleName'%.AddTrigger(%@Trigger@'ModuleName'%.%'ModuleName'%.PRESS, DBC_DEBOUNCE_TIME, Scan);
      break;

    case DBC_KEY_PRESSED:
      keys = %'ModuleName'%.GetKeys();                           %>40/* a one bit indicates key pressed */
      if (keys == DBC_ScanValue) { /* still pressing the same keys */
%if (LongKeyDetection='yes')
        DBC_LongKeyCount++;
        if (DBC_LongKeyCount >= DBC_LONG_KEY_ITERATIONS) {
          /* yes, long key press detected */
          DBC_LongKeyCount = DBC_LONG_KEY_ITERATIONS; /* avoid overflow */
          DBC_KeyState = DBC_KEY_WAIT_RELEASE_LONG; /* advance to next state */
          %@Trigger@'ModuleName'%.AddTrigger(%@Trigger@'ModuleName'%.%'ModuleName'%.PRESS, 1, Scan);
        } else {
%if (HoldingKeyEvents='yes')
          %if defined(OnKeyHold)
          %OnKeyHold(DBC_ScanValue);
          %endif
%endif
          %@Trigger@'ModuleName'%.AddTrigger(%@Trigger@'ModuleName'%.%'ModuleName'%.PRESS, 1, Scan); /* continue waiting */
        }
%else
        %@Trigger@'ModuleName'%.AddTrigger(%@Trigger@'ModuleName'%.%'ModuleName'%.PRESS, 1, Scan); /* continue waiting */
%endif
%if %NumKeys <> '1'
      } else if ((DBC_ScanValue|keys)==keys) { /* we have here at least one additional key pressed than before */
        DBC_KeyState = DBC_KEY_IDLE;
        %@Trigger@'ModuleName'%.AddTrigger(%@Trigger@'ModuleName'%.%'ModuleName'%.PRESS, 1, Scan); /* restart debouncing */
%endif %- more than one key
      } else { /* we got set of key(s): so it was only for a short time */
        DBC_KeyState = DBC_KEY_WAIT_RELEASE; /* advance to next state */
        %@Trigger@'ModuleName'%.AddTrigger(%@Trigger@'ModuleName'%.%'ModuleName'%.PRESS, 1, Scan);
      }
      break;

    case DBC_KEY_WAIT_RELEASE:
  %if (LongKeyDetection='yes')
    case DBC_KEY_WAIT_RELEASE_LONG:
  %endif
      /* wait until keys are released */
      keys = %'ModuleName'%.GetKeys();                           %>40/* a one bit indicates key pressed */
      if (keys==0) { /* a zero bit means: key(s) released */
%if (LongKeyDetection='yes')
        if (DBC_KeyState == DBC_KEY_WAIT_RELEASE_LONG) {
          %if defined(OnKeyReleasedLong)
          %OnKeyReleasedLong(DBC_ScanValue);
          %endif
          %if defined(OnKeyReleased)
        } else {
          %OnKeyReleased(DBC_ScanValue);
          %endif
        }
%elif defined(OnKeyReleased)
        %if defined(OnKeyReleased)
        %OnKeyReleased(DBC_ScanValue);
        %endif
%endif
        /* All keys released, go back to idle state. */
        DBC_KeyState = DBC_KEY_IDLE; /* go back to idle */
%if InterruptEnabled='yes'
        %@KBI@'ModuleName'%.Enable(); /* need to acknowledge any pending interrupts too */
%endif
%if %NumKeys <> '1'
      } else if (DBC_ScanValue != keys && (DBC_ScanValue|keys)==keys) { /* we have here at least one additional key pressed than before */
        DBC_KeyState = DBC_KEY_IDLE;
        %@Trigger@'ModuleName'%.AddTrigger(%@Trigger@'ModuleName'%.%'ModuleName'%.PRESS, 1, Scan); /* restart debouncing */
%endif %- more than one key
      } else { /* continue waiting */
        %@Trigger@'ModuleName'%.AddTrigger(%@Trigger@'ModuleName'%.%'ModuleName'%.PRESS, 1, Scan);
      }
      break;
  }
  %@CriticalSection@'ModuleName'%.ExitCritical();
}

%-INTERNAL_METHOD_END Scan
%-************************************************************************************************************
%-Unused %-INHERITED_EVENT_BEGIN KBI OnInterrupt
%-Unused %ifdef @KBI@OnInterrupt
%-Unused %include Common\GeneralInternal.inc (OnInterrupt)
%-Unused void %@KBI@OnInterrupt(void)
%-Unused {
%-Unused   %@KBI@'ModuleName'%.Disable(); /* disable keyboard interrrupts. They will be enabled again in the Scan() debouncing routine */
%-Unused   Scan(); /* debounce */
%-Unused }
%-Unused
%-Unused %endif %- @KBI@OnInterrupt
%-Unused %-INHERITED_EVENT_END KBI OnInterrupt
%-************************************************************************************************************
%-Unused %-INHERITED_EVENT_BEGIN KBI OnAutoWakeup
%-Unused %ifdef @KBI@OnAutoWakeup
%-Unused %include Common\GeneralInternal.inc (OnAutoWakeup)
%-Unused void %@KBI@OnAutoWakeup(void)
%-Unused {
%-Unused   /* Write your code here ... */
%-Unused }
%-Unused
%-Unused %endif %- @KBI@OnAutoWakeup
%-Unused %-INHERITED_EVENT_END KBI OnAutoWakeup
%-INHERITED_EVENT_BEGIN KBI OnInterrupt
%ifdef @KBI@OnInterrupt
%include Common\GeneralInternal.inc (OnInterrupt)
void %@KBI@OnInterrupt(void)
{
%if InterruptEnabled='yes'
  %@KBI@'ModuleName'%.Disable(); /* disable keyboard interrupts. They will be enabled again in the Scan() debouncing routine */
  Scan(); /* debounce */
%endif
}

%endif %- @KBI@OnInterrupt
%-INHERITED_EVENT_END KBI OnInterrupt
%-************************************************************************************************************
%-BW_METHOD_BEGIN isIdle
%ifdef isIdle
%define! RetVal
%include Common\KeyisIdle.Inc
bool %'ModuleName'%.%isIdle(void)
{
  return (bool)(DBC_KeyState==DBC_KEY_IDLE);
}

%endif %- isIdle
%-BW_METHOD_END isIdle
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetKeys
%ifdef GetKeys
%define! RetVal
%include Common\KeyGetKeys.Inc
#if 0 /* method is implemented as a macro in the header file %'ModuleName'.h */
byte %'ModuleName'%.%GetKeys(void)
{
%if (OpenIsLogicalOne='yes')
  %if InterruptEnabled='yes'
  return ((byte)((~%@KBI@'ModuleName'%.GetVal())&%'ModuleName'%.KEYS_MASK));
  %endif
%elif defined(OnKeyPressed)
  %if InterruptEnabled='yes'
  return %@KBI@'ModuleName'%.GetVal();
  %endif
%endif
}
#endif

%endif %- GetKeys
%-BW_METHOD_END GetKeys
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScanKeys
%ifdef ScanKeys
%include Common\KeyScanKeys.Inc
void %'ModuleName'%.%ScanKeys(void)
{
  if (DBC_KeyState==DBC_KEY_IDLE) { /* we are not already debouncing/scanning a key */
    Scan();
  }
}

%endif %- ScanKeys
%-BW_METHOD_END ScanKeys
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_METHOD_BEGIN OnKeyPressed
%ifdef OnKeyPressed
%IMPLEMENTATION OnKeyPressed
%define! Parkeys
%include Common\KeyOnKeyPressed.Inc
void %OnKeyPressed(byte keys)
{
  /* Write your code here. A bit in 'keys' indicates key pressed ... */
}

%endif %- OnKeyPressed
%-BW_METHOD_END OnKeyPressed
%-BW_METHOD_BEGIN OnKeyReleased
%ifdef OnKeyReleased
%IMPLEMENTATION OnKeyReleased
%define! Parkeys
%include Common\KeyOnKeyReleased.Inc
void %OnKeyReleased(byte keys)
{
  /* Write your code here. A bit in 'keys' indicates key released ... */
}

%endif %- OnKeyReleased
%-BW_METHOD_END OnKeyReleased
%-BW_METHOD_BEGIN OnKeyReleasedLong
%ifdef OnKeyReleasedLong
%IMPLEMENTATION OnKeyReleasedLong
%define! Parkeys
%include Common\KeyOnKeyReleasedLong.Inc
void %OnKeyReleasedLong(byte keys)
{
  /* Write your code here. A bit in 'keys' indicates key released after a long time ... */
}

%endif %- OnKeyReleasedLong
%-BW_METHOD_END OnKeyReleasedLong
%-BW_METHOD_BEGIN OnKeyHold
%ifdef OnKeyHold
%IMPLEMENTATION OnKeyHold
%define! Parkeys
%include Common\KeyOnKeyHold.Inc
void %OnKeyHold(byte keys)
{
  /* Write your code here ... */
}

%endif %- OnKeyHold
%-BW_METHOD_END OnKeyHold
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
%if InitializeOnInit='yes'
 %if LowPowerEnabled='yes' & %@LowPower@SpecialInit='yes'
  %if %@LowPower@RAMlostAfterRecovery='yes'
  %'ModuleName'%.Init();
  %else
  if (%@LowPower@'ModuleName'%.InitializeRAMinInit()) { /* only initialize driver RAM if needed */
    %'ModuleName'%.Init();
  }
  %endif
 %else
  %'ModuleName'%.Init();
 %endif
%endif
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This bean is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
