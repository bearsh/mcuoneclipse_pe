<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1250">
<title>
Component  documentation - Methods
</title>
<STYLE type="text/css">
body{
  background-color: white;
  margin:0px;
  font: 13px Helvetica Neue, Helvetica, Arial, sans-serif;
}
A:visited {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:link {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:active {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:hover {
	COLOR: #2D8AA7; TEXT-DECORATION: underline
}
.VSP {
	COLOR: #2D8AA7; FONT: bold italic 14px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.reflink {
	FONT: 11px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
 	COLOR: #2D8AA7;
}
.user_text {
	FONT: 12px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
	COLOR: #000000;
}
.bluetext {
  COLOR: #695F52;
}
.versionspec {
  padding:5px; 
  background-color: RGB(243, 242, 230);
  margin-top:5px;
  margin-bottom:5px;  
}
.versionspecdetail {
  padding:5px; 
  background-color: RGB(243, 242, 230);
  margin-top:5px;
  margin-bottom:5px;  
}
.versionspeclabel {
  font-style: italic;
}
LI.DEF {
  list-style-image: url(DefaultLI.gif) ;
}
LI.BAS {
	list-style-image: url(BasicLI.gif) ;
}
LI.ADV {
	list-style-image: url(AdvancedLI.gif) ;
}
LI.EXP {
	list-style-image: url(ExpertLI.gif) ;
}
.titlebox {  
  font: bold 18px Helvetica Neue, Helvetica, Arial, sans-serif;
  color: #51626F;
  margin-bottom: 10px;
}
.lefttitlebox {
  background-color:#C3CFD1;  
}
.lefttitle {
  color:#51626F;
  font: bold 11px Helvetica Neue, Helvetica, Arial, sans-serif;   
}
.beanname {
  font: bold 14px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
  padding-top:6px;
  padding-bottom:5px;
  margin-bottom: 5px;
  border-bottom-style: dotted;
  border-bottom-width: 1;  
}
.descrtext {
  font-style: italic;
  font: 14px/18px Helvetica Neue, Helvetica, Arial, sans-serif;  
  padding-bottom:9px;
}
.footer {
  color: #b0b0b0; 
  font: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
  text-align: center;
  border-top-style: solid;
  border-top-color: #BOBOBO;
  border-top-width: 1px;  
  padding-top: 5px;
  margin-top: 20px;
}
.info_name {
  font: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
  padding: 0px;
  color: black;
}
.info_text {
  font: 11px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.text_title {
  COLOR: #000000; 
  FONT: bold 14px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.descr_line {
  COLOR: gray; 
  FONT: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
}
</STYLE>

</head>

<body>

<table border="0"  cellspacing="0" cellpadding="0">
  <tr>
    <td valign="top" width="150" >
      <table  width="150" height="160" cellpadding="3" cellspacing="0" border="0">
        <tbody>
        <tr class="lefttitlebox">
          <td width="4"></td>
          <td align="center" valign="middle" height="30" width="128">
            <span class="lefttitle">
<b>uCOS_II</b>
            </span>
          </td>
        </tr>
        <tr height="700">
          <td width="4"></td>
          <td width="128" valign="top">
            &nbsp;<br />
            <div class="reflink">
<!---HTMLLISTBEG_SHORT DON'T CHANGE THIS LINE-->
<a href="uCOS_II.html">General Info</a><br />
<a href="uCOS_IIProperties.html">Properties</a><br />
<i>Methods</i><br />
<a href="uCOS_IIEvents.html">Events</a><br />
<a href="uCOS_IITypical Usage.html">Typical Usage</a><br />
<!---HTMLLISTEND DON'T CHANGE THIS LINE-->
<br /><br /><br />
<a href="../../DOCs/PredefSymbols.html">Types &amp; definitions</a><br/>
<a href="../../DOCs/BEANindex.html">Component Index</a><br/>
<a href="../../DOCs/CPUindex.html">CPU Component Index</a><br/>
<a href="../../DOCs/EmbeddedBeans.html">Embedded Components</a><br/>
<a href="../../DOCs/BeanCategories.html">Components Categories</a><br/>

<br /><br /><br />
<center>
<img src="uCOS_II_b.gif" alt="Component icon"/>


</center>
            </div>
          </td>
        </tr>
        </tbody>
      </table>
    </td>
    <td width="1" class="lefttitlebox" valign="top">
      <table class="lefttitlebox" width="1" cellpadding="0" cellspacing="0" height="100%" border="0">
        <tr class="lefttitlebox"><td width="1"></td></tr>
      </table>
    </td>
    <td style="padding-left:15px;padding-right:10px;" valign="top" align="left" width="100%" >

         <div class="titlebox">
            <div class="beanname">
              Component
              
              
              uCOS_II
            </div>
            <div class="descrtext">uCOS-II</div>
            <div class="info_name">Component Level: <span class="info_text"><a href="../../DOCs/BeanCategoriesInfo.html#LevelAbstraction">High</a></span></div>
            <div class="info_name">Category: 
              <span class="info_text">
              <a href="../../DOCs/BeanCategoriesInfo.html">Operating Systems</a>
              
              </span>
            </div>
          </div>

         <div class="text_title">
              Methods:
    		 </div>		 
    		 <div class="descr_line">                  
              (Methods are user-callable functions/subroutines intended for
               the component functions control. Please see the <a href="../../DOCs/EmbeddedBeans.html#Methods">Embedded Components page</a> for more information.)                   
         </div>
                  
         <div class="user_text">
            <ul>
<!---USERBEG DON'T CHANGE THIS LINE-->

<!---USEREND DON'T CHANGE THIS LINE-->
<li><a name="OSInit">
<b>OSInit</b></a>
 - no hint
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void OSInit(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
</ul><br />
</li>
<li><a name="OSTimerInit">
<b>OSTimerInit</b></a>
 - Starts the ticks/timer for the OS. Start this in your first task.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void OSTimerInit(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
</ul><br />
</li>
<li><a name="OSTaskCreate">
<b>OSTaskCreate</b></a>
 - This function is used to have uC/OS-II manage the execution of a task.  Tasks can either be created prior to the start of multitasking or by a running task.  A task cannot be created by an ISR.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> INT8U OSTaskCreate(void (*task)(void *p_arg), void *p_arg, OS_STK *ptos, INT8U prio)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>task:byte</i> - is a pointer to the task's code</li>
<li><i>p_arg: Pointer to char</i> - Pointer to is a pointer to an optional data area which can be used to pass parameters to the task when the task first executes.</li>
<li><i>ptos: Pointer to OS_STK</i> - Pointer to is a pointer to the task's top of stack.  If the configuration constant OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high memory to low memory).  'pstk' will thus point to the highest (valid) memory location of the stack.  If OS_STK_GROWTH is set to 0, 'pstk' will point to the lowest memory location of the stack and the stack will grow with increasing memory locations.</li>
<li><i>prio:INT8U</i> - is the task's priority.  A unique priority MUST be assigned to each task and the lower the number, the higher the priority.</li>
<li><i>Return value:INT8U</i> - OS_ERR_NONE             if the function was successful.<br />    OS_PRIO_EXIT            if the task priority already exist (each task MUST have a unique priority).<br />    OS_ERR_PRIO_INVALID     if the priority you specify is higher that the maximum allowed (i.e. &gt;= OS_LOWEST_PRIO)<br />    OS_ERR_TASK_CREATE_ISR  if you tried to create a task from an ISR.
</li>
</ul><br />
</li>
<li><a name="OSTaskDel">
<b>OSTaskDel</b></a>
 - This function allows you to delete a task.  The calling task can delete itself by its own priority number.  The deleted task is returned to the dormant state and can be re-activated by creating the deleted task again.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> INT8U OSTaskDel(INT8U prio)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>prio:INT8U</i> - is the priority of the task to delete.  Note that you can explicitely delete the current task without knowing its priority level by setting 'prio' to OS_PRIO_SELF.</li>
<li><i>Return value:INT8U</i> - OS_ERR_NONE             if the call is successful<br />OS_ERR_TASK_DEL_IDLE    if you attempted to delete uC/OS-II's idle task<br />OS_ERR_PRIO_INVALID     if the priority you specify is higher that the maximum allowed (i.e. &gt;= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.<br />OS_ERR_TASK_DEL         if the task is assigned to a Mutex PIP.<br />OS_ERR_TASK_NOT_EXIST   if the task you want to delete does not exist.<br />OS_ERR_TASK_DEL_ISR     if you tried to delete a task from an ISR<br />Notes:<br />1) To reduce interrupt latency, OSTaskDel() 'disables' the task:<br />    a) by making it not ready<br />    b) by removing it from any wait lists<br />    c) by preventing OSTimeTick() from making the task ready to run.<br />   The task can then be 'unlinked' from the miscellaneous structures in uC/OS-II.<br />2) The function OS_Dummy() is called after OS_EXIT_CRITICAL() because, on most processors, the next instruction following the enable interrupt instruction is ignored.<br />3) An ISR cannot delete a task.<br />4) The lock nesting counter is incremented because, for a brief instant, if the current task is being deleted, the current task would not be able to be rescheduled because it is removed from the ready list.  Incrementing the nesting counter prevents another task from being schedule.  This means that an ISR would return to the current task which is being deleted.  The rest of the deletion would thus be able to be completed.
</li>
</ul><br />
</li>
<li><a name="OSStart">
<b>OSStart</b></a>
 - This function is used to start the multitasking process which lets uC/OS-II manages the task that you have created. Before you can call OSStart(), you MUST have called OSInit() and you MUST have created at least one task.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void OSStart(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
</ul><br />
</li>
<li><a name="OSTaskSuspend">
<b>OSTaskSuspend</b></a>
 - This function is called to suspend a task.  The task can be the calling task if the priority passed to OSTaskSuspend() is the priority of the calling task or OS_PRIO_SELF.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> INT8U OSTaskSuspend(INT8U prio)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>prio:INT8U</i> - is the priority of the task to suspend.  If you specify OS_PRIO_SELF, the calling task will suspend itself and rescheduling will occur.</li>
<li><i>Return value:INT8U</i> - OS_ERR_NONE               if the requested task is suspended<br />OS_ERR_TASK_SUSPEND_IDLE  if you attempted to suspend the idle task which is not allowed.<br />OS_ERR_PRIO_INVALID       if the priority you specify is higher that the maximum allowed (i.e. &gt;= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.<br />OS_ERR_TASK_SUSPEND_PRIO  if the task to suspend does not exist<br />OS_ERR_TASK_NOT_EXITS     if the task is assigned to a Mutex PIP<br />Note: You should use this function with great care.  If you suspend a task that is waiting for an event (i.e. a message, a semaphore, a queue ...) you will prevent this task from running when the event arrives.
</li>
</ul><br />
</li>
<li><a name="OSTaskResume">
<b>OSTaskResume</b></a>
 - This function is called to resume a previously suspended task.  This is the only call that will remove an explicit task suspension.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> INT8U OSTaskResume(INT8U prio)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>prio:INT8U</i> - is the priority of the task to resume.</li>
<li><i>Return value:INT8U</i> - OS_ERR_NONE                if the requested task is resumed<br />OS_ERR_PRIO_INVALID        if the priority you specify is higher that the maximum allowed (i.e. &gt;= OS_LOWEST_PRIO)<br />OS_ERR_TASK_RESUME_PRIO    if the task to resume does not exist<br />OS_ERR_TASK_NOT_EXIST      if the task is assigned to a Mutex PIP<br />OS_ERR_TASK_NOT_SUSPENDED  if the task to resume has not been suspended
</li>
</ul><br />
</li>
<li><a name="OSTimeDlyHMSM">
<b>OSTimeDlyHMSM</b></a>
 - This function is called to delay execution of the currently running task until some time expires.  This call allows you to specify the delay time in HOURS, MINUTES, SECONDS and MILLISECONDS instead of ticks.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> byte OSTimeDlyHMSM(byte hours, INT8U minutes, INT8U seconds, INT16U milli)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>hours:byte</i> - specifies the number of hours that the task will be delayed (max. is 255)</li>
<li><i>minutes:INT8U</i> - no hint</li>
<li><i>seconds:INT8U</i> - specifies the number of seconds (max. 59)</li>
<li><i>milli:INT16U</i> - specifies the number of milliseconds (max. 999)</li>
<li><i>Return value:byte</i> - OS_ERR_NONE<br />OS_ERR_TIME_INVALID_MINUTES<br />OS_ERR_TIME_INVALID_SECONDS<br />OS_ERR_TIME_INVALID_MS<br />OS_ERR_TIME_ZERO_DLY<br />OS_ERR_TIME_DLY_ISR<br />Note(s)    : The resolution on the milliseconds depends on the tick rate.  For example, you can't do a 10 mS delay if the ticker interrupts every 100 mS.  In this case, the delay would be set to 0.  The actual delay is rounded to the nearest tick.
</li>
</ul><br />
</li>
<li><a name="OSFlagCreate">
<b>OSFlagCreate</b></a>
 - This function is called to create an event flag group.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> OS_FLAG_GRP OSFlagCreate(OS_FLAGS flags, INT8U *perror)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>flags:OS_FLAGS</i> - Contains the initial value to store in the event flag group.</li>
<li><i>perror: Pointer to INT8U</i> - is a pointer to an error code which will be returned to your application.</li>
<li><i>Return value:OS_FLAG_GRP</i> - A pointer to an event flag group or a NULL pointer if no more groups are available.
</li>
</ul><br />
</li>
<li><a name="OSFlagQuery">
<b>OSFlagQuery</b></a>
 - This function is used to check the value of the event flag group.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> OS_FLAGS OSFlagQuery(OS_FLAG_GRP *pgrp, INT8U perr)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>pgrp: Pointer to OS_FLAG_GRP</i> - is a pointer to the desired event flag group.</li>
<li><i>perr:INT8U</i> - is a pointer to an error code returned to the called:</li>
<li><i>Return value:OS_FLAGS</i> - The current value of the event flag group.
</li>
</ul><br />
</li>
<li><a name="OSFlagPost">
<b>OSFlagPost</b></a>
 - This function is called to set or clear some bits in an event flag group.  The bits to set or clear are specified by a 'bit mask'.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> OS_FLAGS OSFlagPost(OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>pgrp: Pointer to OS_FLAG_GRP</i> - Pointer to the desired event flag group.</li>
<li><i>flags:OS_FLAGS</i> - If 'opt' (see below) is OS_FLAG_SET, each bit that is set in 'flags' will  set the corresponding bit in the event flag group.</li>
<li><i>opt:INT8U</i> - indicates whether the flags will be: set (OS_FLAG_SET) or cleared (OS_FLAG_CLR)</li>
<li><i>perr: Pointer to INT8U</i> - Pointer to an error code</li>
<li><i>Return value:OS_FLAGS</i> - the new value of the event flags bits that are still set.
</li>
</ul><br />
</li>
<li><a name="OSMemCreate">
<b>OSMemCreate</b></a>
 - Create a fixed-sized memory partition that will be managed by uC/OS-II.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> OS_MEM OSMemCreate(void *addr, INT32U nblks, INT32U blksize, INT8U *perr)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>addr:byte</i> - is the starting address of the memory partition</li>
<li><i>nblks:INT32U</i> - is the number of memory blocks to create from the partition.</li>
<li><i>blksize:INT32U</i> - is the size (in bytes) of each block in the memory partition.</li>
<li><i>perr: Pointer to INT8U</i> - Pointer to to a variable containing an error message which will be set by this function to either:<br />OS_ERR_NONE              if the memory partition has been created correctly.<br />OS_ERR_MEM_INVALID_ADDR  if you are specifying an invalid address for the memory storage of the partition or, the block does not align on a pointer boundary<br />OS_ERR_MEM_INVALID_PART  no free partitions available<br />OS_ERR_MEM_INVALID_BLKS  user specified an invalid number of blocks (must be &gt;= 2)<br />OS_ERR_MEM_INVALID_SIZE  user specified an invalid block size<br />- must be greater than the size of a pointer<br />- must be able to hold an integral number of pointers</li>
<li><i>Return value:OS_MEM</i> - Returns:<br />!= (OS_MEM *)0  is the partition was created<br />== (OS_MEM *)0  if the partition was not created because of invalid arguments or, no free partition is available.
</li>
</ul><br />
</li>
<li><a name="OSMemGet">
<b>OSMemGet</b></a>
 - Get a memory block from a partition
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> INT8U OSMemGet(OS_MEM *pmem, INT8U *perr)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>pmem: Pointer to OS_MEM</i> - Pointer to the memory partition control block</li>
<li><i>perr: Pointer to INT8U</i> - Pointer to to a variable containing an error message which will be set by this function to either:<br />                      OS_ERR_NONE             if the memory partition has been created correctly.<br />                      OS_ERR_MEM_NO_FREE_BLKS if there are no more free memory blocks to allocate to caller<br />                      OS_ERR_MEM_INVALID_PMEM if you passed a NULL pointer for 'pmem'</li>
<li><i>Return value:INT8U</i> - A pointer to a memory block if no error is detected, a pointer to NULL if an error is detected
</li>
</ul><br />
</li>
<li><a name="OSMemPut">
<b>OSMemPut</b></a>
 - Returns a memory block to a partition
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> INT8U OSMemPut(OS_MEM *pmem, void *pblk)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>pmem: Pointer to OS_MEM</i> - Pointer to to the memory partition control block</li>
<li><i>pblk: Pointer to byte</i> - Pointer to the memory block being released.</li>
<li><i>Return value:INT8U</i> - OS_ERR_NONE: if the memory block was inserted into the partition<br />OS_ERR_MEM_FULL: if you are returning a memory block to an already FULL memory partition (You freed more blocks than you allocated!)<br />OS_ERR_MEM_INVALID_PMEM: if you passed a NULL pointer for 'pmem'<br />OS_ERR_MEM_INVALID_PBLK: if you passed a NULL pointer for the block to release.
</li>
</ul><br />
</li>
<li><a name="OSQCreate">
<b>OSQCreate</b></a>
 - This function creates a message queue if free event control blocks are available.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> OS_EVENT OSQCreate(void **start, INT16U size)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>start:byte</i> - start is a pointer to the base address of the message queue storage area.  The storage area MUST be declared as an array of pointers to 'void' as follows<br />void *MessageStorage[size]</li>
<li><i>size:INT16U</i> - is the number of elements in the storage area</li>
<li><i>Return value:OS_EVENT</i> - Returns:<br />!= (OS_EVENT *)0  is a pointer to the event control clock (OS_EVENT) associated with the created queue<br />== (OS_EVENT *)0  if no event control blocks were available or an error was detected
</li>
</ul><br />
</li>
<li><a name="OSQPost">
<b>OSQPost</b></a>
 - This function sends a message to a queue
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> INT8U OSQPost(OS_EVENT *pevent, void *pmsg)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>pevent: Pointer to OS_EVENT</i> - Pointer to is a pointer to the event control block associated with the desired queue</li>
<li><i>pmsg: Pointer to byte</i> - Pointer to the message to send.</li>
<li><i>Return value:INT8U</i> - OS_ERR_NONE: The call was successful and the message was sent<br />OS_ERR_Q_FULL: If the queue cannot accept any more messages because it is full.<br />OS_ERR_EVENT_TYPE: If you didn't pass a pointer to a queue.<br />OS_ERR_PEVENT_NULL: If 'pevent' is a NULL pointer
</li>
</ul><br />
</li>
<li><a name="OSQPostFront">
<b>OSQPostFront</b></a>
 - This function sends a message to a queue but unlike OSQPost(), the message is posted at the front instead of the end of the queue.  Using OSQPostFront() allows you to send 'priority' messages.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> INT8U OSQPostFront(OS_EVENT *pevent, void *pmsg)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>pevent: Pointer to OS_EVENT</i> - Pointer to is a pointer to the event control block associated with the desired queue</li>
<li><i>pmsg: Pointer to byte</i> - Pointer to the message to send.</li>
<li><i>Return value:INT8U</i> - OS_ERR_NONE: The call was successful and the message was sent<br />OS_ERR_Q_FULL: If the queue cannot accept any more messages because it is full.<br />OS_ERR_EVENT_TYPE: If you didn't pass a pointer to a queue.<br />OS_ERR_PEVENT_NULL: If 'pevent' is a NULL pointer
</li>
</ul><br />
</li>
<li><a name="OSQPend">
<b>OSQPend</b></a>
 - This function waits for a message to be sent to a queue
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void OSQPend(OS_EVENT *pevent, INT16U timeout, INT8U *perr)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>pevent: Pointer to OS_EVENT</i> - Pointer to the event control block associated with the desired queue</li>
<li><i>timeout:INT16U</i> - is an optional timeout period (in clock ticks).  If non-zero, your task will wait for a message to arrive at the queue up to the amount of time specified by this argument.  If you specify 0, however, your task will wait forever at the specified queue or, until a message arrives.</li>
<li><i>perr: Pointer to INT8U</i> - Pointer to where an error message will be deposited.  Possible error messages are:<br />OS_ERR_NONE         The call was successful and your task received a message.<br />OS_ERR_TIMEOUT      A message was not received within the specified 'timeout'.<br />OS_ERR_PEND_ABORT   The wait on the queue was aborted.<br />OS_ERR_EVENT_TYPE   You didn't pass a pointer to a queue<br />OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer<br />OS_ERR_PEND_ISR     If you called this function from an ISR and the result would lead to a suspension.<br />OS_ERR_PEND_LOCKED  If you called this function with the scheduler is locked</li>
</ul><br />
</li>

           </ul>
<!---USERBEG DON'T CHANGE THIS LINE-->

<!---USEREND DON'T CHANGE THIS LINE-->
<p>
<br />
Note: Some methods can be implemented as macros.
</p>
          </div>
          <p class="footer">
            PROCESSOR EXPERT is trademark of Freescale Semiconductor, Inc.
            <br />
            
          </p>
    </td>
  </tr>

</table>

</body>
</html>
