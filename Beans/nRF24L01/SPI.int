<?xml version="1.0" encoding="UTF-8"?>
<Interface>
  <Name>SPI</Name>
  <Description>Interface "nRF24L01\SPI" for component nRF24L01, generated by Component Wizard</Description>
  <Author>Erich Styger</Author>
  <Version>01.002</Version>
  <FileVersion>2</FileVersion>
  <MethodList>
    <Method>
      <TMthdItem>
        <Name>RecvChar</Name>
        <Symbol>RecvChar</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>If any data is received, this method returns one character, otherwise it returns an error code (it does not wait for data).\n
&lt;p&gt;\n
For information about SW overrun behavior please see &lt;a href="SynchroMaster.html#SW_overrun_behavior"&gt;General info page&lt;/a&gt;.\n
&lt;/p&gt;\n
&lt;!---VER_SPEC ~56800~ ^^ || DON'T CHANGE THIS LINE--&gt;\n
&lt;div class="versionspec"&gt;\n
&lt;B CLASS="VSP"&gt;\n
Version specific information for Freescale 56800 derivatives\n
&lt;/B&gt;\n
&lt;br/&gt;\n
DMA mode:&lt;BR /&gt;\n
If DMA controller is available on selected CPU and receiver is configured to use DMA controller then this method only sets the selected DMA channel. Status of the DMA transfer can then be checked using method GetCharsInRxBuf. See typical usage for details about communication using DMA.\n
&lt;/div&gt;\n
&lt;!---VER_SPEC_END  DON'T CHANGE THIS LINE--&gt;</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>true</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code, possible codes:&lt;br /&gt;\n     ERR_OK - OK - The valid data is received.&lt;br /&gt;\n     ERR_SPEED - This device does not work in the active speed mode.&lt;br /&gt;\n     ERR_RXEMPTY - No data in receiver.&lt;br /&gt;\n     ERR_OVERRUN - Overrun error was detected from the last char or block received. In polling mode, this error code is returned only when the hardware supports detection of the overrun error. If interrupt service is enabled, and input buffer allocated by the component is full, the component behaviour depends on &lt;a href="SynchroMasterProperties.html#InpBufferSize"&gt;Input buffer size&lt;/a&gt; property : if property is 0, last received data-word is preserved (and previous is overwritten), if property is greater than 0, new received data-word are ignored.&lt;br /&gt;\n     ERR_FAULT - Fault error was detected from the last char or block received. In the polling mode the ERR_FAULT is return until the user clear the fault flag bit, but in the interrupt mode ERR_FAULT is returned only once after the fault error occured. This error is supported only on the CPUs  supports the faul mode function - where &lt;a href="SynchroMasterProperties.html#FaultMode"&gt;Fault mode&lt;/a&gt; property is available.&lt;br /&gt;</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>Chr</ParName>
          <ParType>TComData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>A pointer to the received character</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(%'ModuleName'_TComData *Chr)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendChar</Name>
        <Symbol>SendChar</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Sends one character to the channel.\n
&lt;!---VER_SPEC ~56800~ ^^ || DON'T CHANGE THIS LINE--&gt;\n
&lt;div class="versionspec"&gt;\n
&lt;B CLASS="VSP"&gt;\n
Version specific information for Freescale 56800 derivatives\n
&lt;/B&gt;\n
&lt;br/&gt;\n
DMA mode:&lt;BR /&gt;\n
If DMA controller is available on the selected CPU and the transmitter is configured to use DMA controller then this method only sets the selected DMA channel. The status of the DMA transfer can then be checked using GetCharsInTxBuf method. See the typical usage for details about communication using DMA.\n
&lt;/div&gt;\n
&lt;!---VER_SPEC_END  DON'T CHANGE THIS LINE--&gt;</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>true</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code, possible codes:\n     ERR_OK - OK\n     ERR_SPEED - This device does not work in the active speed mode\n     ERR_DISABLED - Device is disabled (only if output DMA is supported and enabled)\n     ERR_TXFULL - Transmitter is full</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>Chr</ParName>
          <ParType>TComData</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Character to send</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(%'ModuleName'_TComData Chr)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>RecvBlock</Name>
        <Symbol>RecvBlock</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>If any data received, this method returns the block of the data and its length (and incidental error), otherwise it returns error code (it does not wait for data).&lt;BR /&gt;\n
If less than requested number of characters is received only the available data is copied from the receive buffer to the user specified destination and the ERR_EXEMPTY value is returned.&lt;BR /&gt;\n
This method is available only if non-zero length of input buffer is defined.&lt;BR /&gt;\n
&lt;p&gt;\n
For information about SW overrun behavior please see &lt;a href="SynchroMaster.html#SW_overrun_behavior"&gt;General info page&lt;/a&gt;.\n
&lt;/p&gt;\n
&lt;!---VER_SPEC ~56800~ ^^ || DON'T CHANGE THIS LINE--&gt;\n
&lt;div class="versionspec"&gt;\n
&lt;B CLASS="VSP"&gt;\n
Version specific information for Freescale 56800 derivatives\n
&lt;/B&gt;\n
&lt;br/&gt;DMA mode:&lt;BR /&gt;\n
If DMA controller is available on the selected CPU and the receiver is configured to use DMA controller then this method only sets the selected DMA channel. The status of the DMA transfer can then be checked using GetCharsInRxBuf method. See the typical usage for details about communication using DMA.\n
&lt;/div&gt;\n
&lt;!---VER_SPEC_END  DON'T CHANGE THIS LINE--&gt;</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>true</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code, possible codes:&lt;br /&gt;\n     ERR_OK - OK - The valid data is received.&lt;br /&gt;\n     ERR_SPEED - This device does not work in the active speed mode.&lt;br /&gt;\n     ERR_RXEMPTY - It was not possible to read requested number of bytes from the buffer.&lt;br /&gt;\n     ERR_OVERRUN - Overrun error was detected from the last char or block received. If interrupt service is enabled, and input buffer allocated by the component is full, the component behaviour depends on &lt;a href="SynchroMasterProperties.html#InpBufferSize"&gt;Input buffer size&lt;/a&gt; property : if property is 0, last received data-word is preserved (and previous is overwritten), if property is greater than 0, new received data-word are ignored.&lt;br /&gt;\n     ERR_FAULT - Fault error was detected from the last char or block received. In the polling mode the ERR_FAULT is return until the user clear the fault flag bit, but in the interrupt mode ERR_FAULT is returned only once after the fault error occured. This error is supported only on the CPUs  supports the faul mode function - where &lt;a href="SynchroMasterProperties.html#FaultMode"&gt;Fault mode&lt;/a&gt; property is available.&lt;br /&gt;</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>Ptr</ParName>
          <ParType>TComData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>A pointer to the block of received data</ParHint>
        </Parameter>
        <Parameter>
          <ParName>Size</ParName>
          <ParType>16bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The size of the block</ParHint>
        </Parameter>
        <Parameter>
          <ParName>Rcv</ParName>
          <ParType>16bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to a variable where an actual number of copied characters is stored</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(%'ModuleName'_TComData *Ptr, word Size, word *Rcv)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendBlock</Name>
        <Symbol>SendBlock</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Send a block of characters to the channel. This method is only available if a non-zero length of output buffer is defined.\n
&lt;!---VER_SPEC ~56800~ ^^ || DON'T CHANGE THIS LINE--&gt;\n
&lt;div class="versionspec"&gt;\n
&lt;B CLASS="VSP"&gt;\n
Version specific information for Freescale 56800 derivatives\n
&lt;/B&gt;\n
&lt;br/&gt;\n
DMA mode:&lt;BR /&gt;\n
If DMA controller is available on the selected CPU and transmitter is configured to use DMA controller then this method only sets the selected DMA channel. The status of the DMA transfer can then be checked using GetCharsInTxBuf method. See the typical usage for details about communication using DMA.\n
&lt;/div&gt;\n
&lt;!---VER_SPEC_END  DON'T CHANGE THIS LINE--&gt;</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>true</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code, possible codes:\n     ERR_OK - OK\n     ERR_SPEED - This device does not work in the active speed mode\n     ERR_DISABLED - Device is disabled (only if output DMA is supported and enabled)\n     ERR_TXFULL - It was not possible to send requested number of bytes</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>Ptr</ParName>
          <ParType>TComData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to the block of data to send</ParHint>
        </Parameter>
        <Parameter>
          <ParName>Size</ParName>
          <ParType>16bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Size of the block</ParHint>
        </Parameter>
        <Parameter>
          <ParName>Snd</ParName>
          <ParType>16bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to number of data that are sent (moved to buffer)</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(%'ModuleName'_TComData *Ptr, word Size, word *Snd)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>ClearRxBuf</Name>
        <Symbol>ClearRxBuf</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Clears the receive buffer. This method is available only if a non-zero length of input buffer is defined.\n
&lt;!---VER_SPEC ~56800~ ^^ || DON'T CHANGE THIS LINE--&gt;\n
&lt;div class="versionspec"&gt;\n
&lt;B CLASS="VSP"&gt;\n
Version specific information for Freescale 56800 derivatives\n
&lt;/B&gt;\n
&lt;br/&gt;\n
DMA mode:&lt;BR /&gt;\n
If DMA controller is available on the selected CPU and the receiver is configured to use DMA controller then this method only stops the selected DMA channel.\n
&lt;/div&gt;\n
&lt;!---VER_SPEC_END  DON'T CHANGE THIS LINE--&gt;</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>true</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code, possible codes:\n     ERR_OK - OK\n     ERR_SPEED - This device does not work in the active speed mode</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>ClearTxBuf</Name>
        <Symbol>ClearTxBuf</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Clears the transmit buffer. This method is only available if a non-zero length of output buffer is defined.\n
&lt;!---VER_SPEC ~56800~ ^^ || DON'T CHANGE THIS LINE--&gt;\n
&lt;div class="versionspec"&gt;\n
&lt;B CLASS="VSP"&gt;\n
Version specific information for Freescale 56800 derivatives\n
&lt;/B&gt;\n
&lt;br/&gt;\n
DMA mode:&lt;BR /&gt;\n
If DMA controller is available on the selected CPU and the transmitter is configured to use DMA controller then this method only stops the selected DMA channel.\n
&lt;/div&gt;\n
&lt;!---VER_SPEC_END  DON'T CHANGE THIS LINE--&gt;</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>true</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code, possible codes:\n     ERR_OK - OK\n     ERR_SPEED - This device does not work in the active speed mode</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>CharsInRxBuf</Name>
        <Symbol>CharsInRxBuf</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Returns the number of characters in the input buffer.&lt;BR /&gt;\n
Note: If the Interrupt service is disabled, and the Ignore empty character is set to yes, and a character has been received, then this method returns 1 although it was an empty character.&lt;BR /&gt;\n
(deprecated method - Use the GetCharsInRxBuf method instead!)&lt;BR /&gt;\n
&lt;!---VER_SPEC ~56800~ ^^ || DON'T CHANGE THIS LINE--&gt;\n
&lt;div class="versionspec"&gt;\n
&lt;B CLASS="VSP"&gt;\n
Version specific information for Freescale 56800 derivatives\n
&lt;/B&gt;\n
&lt;br/&gt;\n
DMA mode:&lt;BR /&gt;\n
If DMA controller is available on the selected CPU and the receiver is configured to use DMA controller then this method returns the number of characters in the receive buffer.\n
&lt;/div&gt;\n
&lt;!---VER_SPEC_END  DON'T CHANGE THIS LINE--&gt;</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>true</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code, possible codes:\n     ERR_OK - OK\n     ERR_SPEED - This device does not work in the active speed mode</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>Chr</ParName>
          <ParType>16bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>A pointer to number of characters in the input buffer</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(word *Chr)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>GetCharsInRxBuf</Name>
        <Symbol>GetCharsInRxBuf</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Returns the number of characters in the input buffer.&lt;BR /&gt;\n
Note: If the Interrupt service is disabled, and the Ignore empty character is set to yes, and a character has been received, then this method returns 1 although it was an empty character.\n
&lt;!---VER_SPEC ~56800~ ^^ || DON'T CHANGE THIS LINE--&gt;\n
&lt;div class="versionspec"&gt;\n
&lt;B CLASS="VSP"&gt;\n
Version specific information for Freescale 56800 derivatives\n
&lt;/B&gt;\n
&lt;br/&gt;\n
DMA mode:&lt;BR /&gt;\n
If DMA controller is available on the selected CPU and the receiver is configured to use DMA controller then this method returns the number of characters in the receive buffer.\n
&lt;/div&gt;\n
&lt;!---VER_SPEC_END  DON'T CHANGE THIS LINE--&gt;</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>true</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>16bit unsigned</ReturnType>
        <RetHint>Number of characters in the input buffer.</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>word #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>CharsInTxBuf</Name>
        <Symbol>CharsInTxBuf</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Returns the number of characters in the output buffer.&lt;BR /&gt;\n
(deprecated method - Use the GetCharsInRxBuf method instead!)&lt;BR /&gt;\n
&lt;!---VER_SPEC ~56800~ ^^ || DON'T CHANGE THIS LINE--&gt;\n
&lt;div class="versionspec"&gt;\n
&lt;B CLASS="VSP"&gt;\n
Version specific information for Freescale 56800 derivatives\n
&lt;/B&gt;\n
&lt;br/&gt;\n
DMA mode:&lt;BR /&gt;\n
If DMA controller is available on the selected CPU and the transmitter is configured to use DMA controller then this method returns the number of characters in the transmit buffer.\n
&lt;/div&gt;\n
&lt;!---VER_SPEC_END  DON'T CHANGE THIS LINE--&gt;</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>true</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code, possible codes:\n     ERR_OK - OK\n     ERR_SPEED - This device does not work in the active speed mode</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>Chr</ParName>
          <ParType>16bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>A pointer to the number of characters in the output buffer</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(word *Chr)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>GetCharsInTxBuf</Name>
        <Symbol>GetCharsInTxBuf</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Returns the number of characters in the output buffer.\n
&lt;!---VER_SPEC ~56800~ ^^ || DON'T CHANGE THIS LINE--&gt;\n
&lt;div class="versionspec"&gt;\n
&lt;B CLASS="VSP"&gt;\n
Version specific information for Freescale 56800 derivatives\n
&lt;/B&gt;\n
&lt;br/&gt;\n
DMA mode:&lt;BR /&gt;\n
If DMA controller is available on the selected CPU and the transmitter is configured to use DMA controller then this method returns the number of characters in the transmit buffer.\n
&lt;/div&gt;\n
&lt;!---VER_SPEC_END  DON'T CHANGE THIS LINE--&gt;</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>true</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>16bit unsigned</ReturnType>
        <RetHint>Number of characters in the output buffer.</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>word #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
  </MethodList>
  <EventList>
    <EmptySection_DummyValue/>
  </EventList>
  <Registration>
    <Template>SPI</Template>
    <Template>SynchroMaster</Template>
  </Registration>
  <UserTypes>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>TError</Name>
      <Hint>Error flags. For languages which don't support bit access is byte access only to error flags possible. </Hint>
      <Generate>yes</Generate>
      <Unique>yes</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint>typedef union {\n
  byte err;\n
  struct {\n
    bool OverRun  : 1;   /* OverRun error flag - the data overflow on the input has been detected. Both hardware detection (if supported) and software detection (when the value of Input buffer size property is 0) is used. */\n
    bool RxBufOvf : 1;   /* Rx buffer full error flag - the input circular buffer defined by the Input buffer size property has overrun. */\n
    bool FaultErr : 1;   /* Fault mode error flag - only if supported by hardware */\n
  }errName;\n
} %'ModuleName'_TError; /* Error flags. For languages which don't support bit access is byte access only to error flags possible.  */\n
</PreparedHint>
      <Type>typedef union {\n
  byte err;\n
  struct {\n
    bool OverRun  : 1;   /* OverRun error flag - the data overflow on the input has been detected. Both hardware detection (if supported) and software detection (when the value of Input buffer size property is 0) is used. */\n
    bool RxBufOvf : 1;   /* Rx buffer full error flag - the input circular buffer defined by the Input buffer size property has overrun. */\n
    bool FaultErr : 1;   /* Fault mode error flag - only if supported by hardware */\n
  }errName;\n
} %'ModuleName'_TError;</Type>
      <HWTestType>16bit unsigned</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>TComData</Name>
      <Hint>Unsigned integer type for communication. Size of this type depends on the communication data width. See &lt;a href="SynchroMaster.html"&gt;General Info&lt;/a&gt;.</Hint>
      <Generate>no</Generate>
      <Unique>yes</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint> /* Unsigned integer type for communication. Size of this type depends on the communication data width. See &lt;a href="SynchroMaster.html"&gt;General Info&lt;/a&gt;. */\n
</PreparedHint>
      <Type/>
      <HWTestType>16bit unsigned</HWTestType>
    </Type>
  </UserTypes>
</Interface>
