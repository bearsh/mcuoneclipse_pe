<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1250">
<title>
Component  documentation - Methods
</title>
<STYLE type="text/css">
body{
  background-color: white;
  margin:0px;
  font: 13px Helvetica Neue, Helvetica, Arial, sans-serif;
}
A:visited {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:link {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:active {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:hover {
	COLOR: #2D8AA7; TEXT-DECORATION: underline
}
.VSP {
	COLOR: #2D8AA7; FONT: bold italic 14px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.reflink {
	FONT: 11px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
 	COLOR: #2D8AA7;
}
.user_text {
	FONT: 12px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
	COLOR: #000000;
}
.bluetext {
  COLOR: #695F52;
}
.versionspec {
  padding:5px; 
  background-color: RGB(243, 242, 230);
  margin-top:5px;
  margin-bottom:5px;  
}
.versionspecdetail {
  padding:5px; 
  background-color: RGB(243, 242, 230);
  margin-top:5px;
  margin-bottom:5px;  
}
.versionspeclabel {
  font-style: italic;
}
LI.DEF {
  list-style-image: url(DefaultLI.gif) ;
}
LI.BAS {
	list-style-image: url(BasicLI.gif) ;
}
LI.ADV {
	list-style-image: url(AdvancedLI.gif) ;
}
LI.EXP {
	list-style-image: url(ExpertLI.gif) ;
}
.titlebox {  
  font: bold 18px Helvetica Neue, Helvetica, Arial, sans-serif;
  color: #51626F;
  margin-bottom: 10px;
}
.lefttitlebox {
  background-color:#C3CFD1;  
}
.lefttitle {
  color:#51626F;
  font: bold 11px Helvetica Neue, Helvetica, Arial, sans-serif;   
}
.beanname {
  font: bold 14px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
  padding-top:6px;
  padding-bottom:5px;
  margin-bottom: 5px;
  border-bottom-style: dotted;
  border-bottom-width: 1;  
}
.descrtext {
  font-style: italic;
  font: 14px/18px Helvetica Neue, Helvetica, Arial, sans-serif;  
  padding-bottom:9px;
}
.footer {
  color: #b0b0b0; 
  font: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
  text-align: center;
  border-top-style: solid;
  border-top-color: #BOBOBO;
  border-top-width: 1px;  
  padding-top: 5px;
  margin-top: 20px;
}
.info_name {
  font: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
  padding: 0px;
  color: black;
}
.info_text {
  font: 11px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.text_title {
  COLOR: #000000; 
  FONT: bold 14px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.descr_line {
  COLOR: gray; 
  FONT: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.code {
  background-color: RGB(243, 242, 230);
  padding: 10px;
  white-space: pre;
  font-family: Courier New, Monospace;
}
</STYLE>

</head>

<body>

<table border="0"  cellspacing="0" cellpadding="0">
  <tr>
    <td valign="top" width="150" >
      <table  width="150" height="160" cellpadding="3" cellspacing="0" border="0">
        <tbody>
        <tr class="lefttitlebox">
          <td width="4"></td>
          <td align="center" valign="middle" height="30" width="128">
            <span class="lefttitle">
<b>FreeRTOS</b>
            </span>
          </td>
        </tr>
        <tr height="700">
          <td width="4"></td>
          <td width="128" valign="top">
            &nbsp;<br />
            <div class="reflink">
<!---HTMLLISTBEG_SHORT DON'T CHANGE THIS LINE-->
<a href="FreeRTOS.html">General Info</a><br />
<a href="FreeRTOSProperties.html">Properties</a><br />
<i>Methods</i><br />
<a href="FreeRTOSEvents.html">Events</a><br />
<a href="FreeRTOSTypical Usage.html">Typical Usage</a><br />
<a href="FreeRTOSApplication Notes.html">Application Notes</a><br />
<!---HTMLLISTEND DON'T CHANGE THIS LINE-->
<br /><br /><br />
<a href="../../DOCs/PredefSymbols.html">Types &amp; definitions</a><br/>
<a href="../../DOCs/BEANindex.html">Component Index</a><br/>
<a href="../../DOCs/CPUindex.html">CPU Component Index</a><br/>
<a href="../../DOCs/EmbeddedBeans.html">Embedded Components</a><br/>
<a href="../../DOCs/BeanCategories.html">Component Categories</a><br/>

<br /><br /><br />
<center>
<img src="FreeRTOS_b.gif" alt="Component icon"/>


</center>
            </div>
          </td>
        </tr>
        </tbody>
      </table>
    </td>
    <td width="1" class="lefttitlebox" valign="top">
      <table class="lefttitlebox" width="1" cellpadding="0" cellspacing="0" height="100%" border="0">
        <tr class="lefttitlebox"><td width="1"></td></tr>
      </table>
    </td>
    <td style="padding-left:15px;padding-right:10px;" valign="top" align="left" width="100%" >

         <div class="titlebox">
            <div class="beanname">
              Component
              
              
              FreeRTOS
            </div>
            <div class="descrtext">FreeRTOS</div>
            <div class="info_name">Component Level: <span class="info_text"><a href="../../DOCs/BeanCategoriesInfo.html#LevelAbstraction">High</a></span></div>
            <div class="info_name">Category: 
              <span class="info_text">
              <a href="../../DOCs/BeanCategoriesInfo.html">Operating Systems</a>
              
              </span>
            </div>
          </div>

         <div class="text_title">
              Methods:
    		 </div>		 
    		 <div class="descr_line">                  
              (Methods are user-callable functions/subroutines intended for
               the component functions control. Please see the <a href="../../DOCs/EmbeddedBeans.html#Methods">Embedded Components page</a> for more information.)                   
         </div>
                  
         <div class="user_text">
            <ul>
<!---USERBEG DON'T CHANGE THIS LINE-->

<!---USEREND DON'T CHANGE THIS LINE-->
<li><a name="xTaskCreate">
<b>xTaskCreate</b></a>
 - Create a new task and add it to the list of tasks that are ready to run.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> portBASE_TYPE xTaskCreate(pdTASK_CODE pvTaskCode, const portCHAR * const pcName, unsigned portSHORT usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pvCreatedTask)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>pvTaskCode:byte</i> - Pointer to the task entry function. Tasks must be implemented to never return (i.e. continuous loop).</li>
<li><i>pcName:byte</i> - A descriptive name for the task. This is mainly used to facilitate debugging. Max length defined by configMAX_TASK_NAME_LEN.</li>
<li><i>usStackDepth:byte</i> - The size of the task stack specified as the number of variables the stack can hold - not the number of bytes. For example, if the stack is 16 bits wide and usStackDepth is defined as 100, 200 bytes will be allocated for stack storage. The stack depth multiplied by the stack width must not exceed the maximum value that can be contained in a variable of type size_t.</li>
<li><i>pvParameters:byte</i> - Pointer that will be used as the parameter for the task being created.</li>
<li><i>uxPriority:byte</i> - The priority at which the task should run.</li>
<li><i>pvCreatedTask:byte</i> - Used to pass back a handle by which the created task can be referenced.</li>
<li><i>Return value:portBASE_TYPE</i> - pdPASS if the task was successfully created and added to a ready list, otherwise an error code defined in the file projdefs.h
</li>
</ul><br />
</li>
<li><a name="vTaskDelete">
<b>vTaskDelete</b></a>
 - Remove a task from the RTOS real time kernels management. The task being deleted will be removed from all ready, blocked, suspended and event lists.<br />NOTE: The idle task is responsible for freeing the kernel allocated memory from tasks that have been deleted. It is therefore important that the idle task is not starved of microcontroller processing time if your application makes any calls to vTaskDelete (). Memory allocated by the task code is not automatically freed, and should be freed before the task is deleted.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vTaskDelete(xTaskHandle pxTask)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>pxTask:xTaskHandle</i> - The handle of the task to be deleted. Passing NULL will cause the calling task to be deleted.</li>
</ul><br />
</li>
<li><a name="vTaskStartScheduler">
<b>vTaskStartScheduler</b></a>
 - Starts the real time kernel tick processing. After calling the kernel has control over which tasks are executed and when.<br />The idle task is created automatically when vTaskStartScheduler() is called.<br />If vTaskStartScheduler() is successful the function will not return until an executing task calls vTaskEndScheduler(). The function might fail and return immediately if there is insufficient RAM available for the idle task to be created.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vTaskStartScheduler(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
</ul><br />
</li>
<li><a name="vTaskEndScheduler">
<b>vTaskEndScheduler</b></a>
 - Stops the real time kernel tick. All created tasks will be automatically deleted and multitasking (either preemptive or cooperative) will stop. Execution then resumes from the point where vTaskStartScheduler() was called, as if vTaskStartScheduler() had just returned.<br /><br />See the demo application file main. c in the demo/PC directory for an example that uses vTaskEndScheduler ().<br /><br />vTaskEndScheduler () requires an exit function to be defined within the portable layer (see vPortEndScheduler () in port. c for the PC port). This performs hardware specific operations such as stopping the kernel tick.<br /><br />vTaskEndScheduler () will cause all of the resources allocated by the kernel to be freed - but will not free resources allocated by application tasks.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vTaskEndScheduler(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
</ul><br />
</li>
<li><a name="vTaskSuspend">
<b>vTaskSuspend</b></a>
 - Suspend any task. When suspended a task will never get any microcontroller processing time, no matter what its priority. Calls to vTaskSuspend are not accumulative - i.e. calling vTaskSuspend() twice on the same task still only requires one call to vTaskResume() to ready the suspended task.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vTaskSuspend(xTaskHandle pxTaskToSuspend)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>pxTaskToSuspend:xTaskHandle</i> - Handle to the task being suspended. Passing a NULL handle will cause the calling task to be suspended.</li>
</ul><br />
</li>
<li><a name="vTaskSuspendAll">
<b>vTaskSuspendAll</b></a>
 - Suspends all real time kernel activity while keeping interrupts (including the kernel tick) enabled.<br />After calling vTaskSuspendAll () the calling task will continue to execute without risk of being swapped out until a call to xTaskResumeAll () has been made.<br />API functions that have the potential to cause a context switch (for example, vTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler is suspended.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vTaskSuspendAll(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
</ul><br />
</li>
<li><a name="vTaskResume">
<b>vTaskResume</b></a>
 - Resumes a suspended task. A task that has been suspended by one of more calls to vTaskSuspend() will be made available for running again by a single call to vTaskResume().
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vTaskResume(xTaskHandle pxTaskToResume)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>pxTaskToResume:xTaskHandle</i> - Handle to the task being readied.</li>
</ul><br />
</li>
<li><a name="xTaskResumeAll">
<b>xTaskResumeAll</b></a>
 - Resumes real time kernel activity following a call to vTaskSuspendAll (). After a call to xTaskSuspendAll () the kernel will take control of which task is executing at any time.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> portBASE_TYPE xTaskResumeAll(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>Return value:portBASE_TYPE</i> - If resuming the scheduler caused a context switch then pdTRUE is returned, otherwise pdFALSE is returned.
</li>
</ul><br />
</li>
<li><a name="xTaskResumeFromISR">
<b>xTaskResumeFromISR</b></a>
 - An implementation of vTaskResume() that can be called from within an ISR. A task that has been suspended by one of more calls to vTaskSuspend() will be made available for running again by a single call to xTaskResumeFromISR().
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> portBASE_TYPE xTaskResumeFromISR(xTaskHandle pxTaskToResume)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>pxTaskToResume:xTaskHandle</i> - Handle to the task being readied.</li>
<li><i>Return value:portBASE_TYPE</i> - Error code
</li>
</ul><br />
</li>
<li><a name="taskYIELD">
<b>taskYIELD</b></a>
 - Macro for forcing a context switch.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void taskYIELD(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
</ul><br />
</li>
<li><a name="taskENTER_CRITICAL">
<b>taskENTER_CRITICAL</b></a>
 - Macro to mark the start of a critical code region. Preemptive context switches cannot occur when in a critical region.<br /><br />NOTE: This may alter the stack (depending on the portable implementation) so must be used with care!
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void taskENTER_CRITICAL(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
</ul><br />
</li>
<li><a name="taskEXIT_CRITICAL">
<b>taskEXIT_CRITICAL</b></a>
 - Macro to mark the end of a critical code region. Preemptive context switches cannot occur when in a critical region.<br /><br />NOTE: This may alter the stack (depending on the portable implementation) so must be used with care!
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void taskEXIT_CRITICAL(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
</ul><br />
</li>
<li><a name="taskDISABLE_INTERRUPTS">
<b>taskDISABLE_INTERRUPTS</b></a>
 - Macro to disable all maskable interrupts.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void taskDISABLE_INTERRUPTS(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
</ul><br />
</li>
<li><a name="taskENABLE_INTERRUPTS">
<b>taskENABLE_INTERRUPTS</b></a>
 - Macro to enable microcontroller interrupts.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void taskENABLE_INTERRUPTS(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
</ul><br />
</li>
<li><a name="vTaskDelay">
<b>vTaskDelay</b></a>
 - Delay a task for a given number of ticks. The actual time that the task remains blocked depends on the tick rate. The constant portTICK_RATE_MS can be used to calculate real time from the tick rate - with the resolution of one tick period.<br /><br />vTaskDelay() specifies a time at which the task wishes to unblock relative to the time at which vTaskDelay() is called. For example, specifying a block period of 100 ticks will cause the task to unblock 100 ticks after vTaskDelay() is called. vTaskDelay() does not therefore provide a good method of controlling the frequency of a cyclical task as the path taken through the code, as well as other task and interrupt activity, will effect the frequency at which vTaskDelay() gets called and therefore the time at which the task next executes. See vTaskDelayUntil() for an alternative API function designed to facilitate fixed frequency execution. It does this by specifying an absolute time (rather than a relative time) at which the calling task should unblock. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vTaskDelay(portTickType xTicksToDelay)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xTicksToDelay:byte</i> - The amount of time, in tick periods, that the calling task should block.</li>
</ul><br />
</li>
<li><a name="vTaskDelayUntil">
<b>vTaskDelayUntil</b></a>
 - Delay a task until a specified time. This function can be used by cyclical tasks to ensure a constant execution frequency.<br /><br />This function differs from vTaskDelay() in one important aspect: vTaskDelay() specifies a time at which the task wishes to unblock relative to the time at which vTaskDelay() is called, whereas vTaskDelayUntil() specifies an absolute time at which the task wishes to unblock.<br /><br />vTaskDelay() will cause a task to block for the specified number of ticks from the time vTaskDelay() is called. It is therefore difficult to use vTaskDelay() by itself to generate a fixed execution frequency as the time between a task unblocking following a call to vTaskDelay() and that task next calling vTaskDelay() may not be fixed [the task may take a different path though the code between calls, or may get interrupted or preempted a different number of times each time it executes].<br /><br />Whereas vTaskDelay() specifies a wake time relative to the time at which the function is called, vTaskDelayUntil() specifies the absolute (exact) time at which it wishes to unblock.<br /><br />It should be noted that vTaskDelayUntil() will return immediately (without blocking) if it is used to specify a wake time that is already in the past. Therefore a task using vTaskDelayUntil() to execute periodically will have to re-calculate its required wake time if the periodic execution is halted for any reason (for example, the task is temporarily placed into the Suspended state) causing the task to miss one or more periodic executions. This can be detected by checking the variable passed by reference as the pxPreviousWakeTime parameter against the current tick count. This is however not necessary under most usage scenarios.<br /><br />The constant portTICK_RATE_MS can be used to calculate real time from the tick rate - with the resolution of one tick period.<br /><br />This function must not be called while the scheduler has been suspended by a call to vTaskSuspendAll(). 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vTaskDelayUntil(portTickType *pxPreviousWakeTime, portTickType xTimeIncrement)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>pxPreviousWakeTime:byte</i> - Pointer to a variable that holds the time at which the task was last unblocked. The variable must be initialised with the current time prior to its first use (see the example below). Following this the variable is automatically updated within vTaskDelayUntil(). </li>
<li><i>xTimeIncrement:byte</i> - The cycle time period. The task will be unblocked at time (*pxPreviousWakeTime + xTimeIncrement). Calling vTaskDelayUntil with the same xTimeIncrement parameter value will cause the task to execute with a fixed interval period. </li>
</ul><br />
</li>
<li><a name="uxTaskPriorityGet">
<b>uxTaskPriorityGet</b></a>
 - Obtain the priority of any task.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> unsigned_portBASE_TYPE uxTaskPriorityGet(xTaskHandle pxTask)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>pxTask:byte</i> - Handle of the task to be queried. Passing a NULL handle results in the priority of the calling task being returned.</li>
<li><i>Return value:unsigned_portBASE_TYPE</i> - The priority of pxTask.
</li>
</ul><br />
</li>
<li><a name="vTaskPrioritySet">
<b>vTaskPrioritySet</b></a>
 - Set the priority of any task.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vTaskPrioritySet(xTaskHandle pxTask, unsigned_portBASE_TYPE uxNewPriority)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>pxTask:xTaskHandle</i> - Handle to the task for which the priority is being set. Passing a NULL handle results in the priority of the calling task being set.</li>
<li><i>uxNewPriority:unsigned_portBASE_TYPE</i> - The priority to which the task will be set.</li>
</ul><br />
</li>
<li><a name="xTaskGetTickCount">
<b>xTaskGetTickCount</b></a>
 - Return the count of ticks since vTaskStartScheduler was called.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> portTickType xTaskGetTickCount(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>Return value:portTickType</i> - tick count
</li>
</ul><br />
</li>
<li><a name="xSemaphoreCreateRecursiveMutex">
<b>xSemaphoreCreateRecursiveMutex</b></a>
 - Macro that implements a recursive mutex by using the existing queue mechanism.<br />Mutexes created using this macro can be accessed using the xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros.  The  xSemaphoreTake() and xSemaphoreGive() macros should not be used.<br />A mutex used recursively can be 'taken' repeatedly by the owner. The mutex doesn't become available again until the owner has called xSemaphoreGiveRecursive() for each successful 'take' request.  For example, if a task successfully 'takes' the same mutex 5 times then the mutex will not be available to any other task until it has also  'given' the mutex back exactly five times.<br />This type of semaphore uses a priority inheritance mechanism so a task 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the semaphore it is no longer required. Mutex type semaphores cannot be used from within interrupt service routines.<br />See vSemaphoreCreateBinary() for an alternative implementation that can be used for pure synchronisation (where one task or interrupt always 'gives' the semaphore and another always 'takes' the semaphore) and from within interrupt service routines.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> xSemaphoreHandle xSemaphoreCreateRecursiveMutex(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>Return value:xSemaphoreHandle</i> - Handle to the created mutex semaphore.  Should be of type  xSemaphoreHandle.
</li>
</ul><br />
</li>
<li><a name="xSemaphoreTakeRecursive">
<b>xSemaphoreTakeRecursive</b></a>
 - Macro to recursively obtain, or 'take', a mutex type semaphore. The mutex must have previously been created using a call to xSemaphoreCreateRecursiveMutex();<br />This macro must not be used on mutexes created using xSemaphoreCreateMutex(). A mutex used recursively can be 'taken' repeatedly by the owner. The mutex doesn't become available again until the owner has called xSemaphoreGiveRecursive() for each successful 'take' request.  For example, if a task successfully 'takes' the same mutex 5 times then the mutex will not be available to any other task until it has also  'given' the mutex back exactly five times.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> bool xSemaphoreTakeRecursive(xSemaphoreHandle xMutex, portTickType xBlockTime)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xMutex:xSemaphoreHandle</i> - A handle to the mutex being obtained.  This is the handle returned by xSemaphoreCreateRecursiveMutex();</li>
<li><i>xBlockTime:byte</i> - The time in ticks to wait for the semaphore to become available.  The macro portTICK_RATE_MS can be used to convert this to a real time.  A block time of zero can be used to poll the semaphore.  If the task already owns the semaphore then xSemaphoreTakeRecursive() will return immediately no matter what the value of xBlockTime.</li>
<li><i>Return value:bool</i> - Returns pdTRUE if the semaphore was obtained.  pdFALSE if xBlockTime expired without the semaphore becoming available.
</li>
</ul><br />
</li>
<li><a name="xSemaphoreGiveRecursive">
<b>xSemaphoreGiveRecursive</b></a>
 - Macro to recursively release, or 'give', a mutex type semaphore. The mutex must have previously been created using a call to xSemaphoreCreateRecursiveMutex();<br />This macro must not be used on mutexes created using xSemaphoreCreateMutex(). A mutex used recursively can be 'taken' repeatedly by the owner. The mutex doesn't become available again until the owner has called xSemaphoreGiveRecursive() for each successful 'take' request.  For example, if a task successfully 'takes' the same mutex 5 times then the mutex will not be available to any other task until it has also  'given' the mutex back exactly five times.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> bool xSemaphoreGiveRecursive(xSemaphoreHandle xMutex)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xMutex:xSemaphoreHandle</i> - A handle to the mutex being released, or 'given'.  This is the handle returned by xSemaphoreCreateMutex();</li>
<li><i>Return value:bool</i> - Returns pdTRUE if the semaphore was given.
</li>
</ul><br />
</li>
<li><a name="xSemaphoreCreateMutex">
<b>xSemaphoreCreateMutex</b></a>
 - Macro that creates a mutex semaphore by using the existing queue mechanism.<br /><br />Mutexes created using this macro can be accessed using the xSemaphoreTake() and xSemaphoreGive() macros. The xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros should not be used.<br /><br />Mutexes and binary semaphores are very similar but have some subtle differences: Mutexes include a priority inheritance mechanism, binary semaphores do not. This makes binary semaphores the better choice for implementing synchronisation (between tasks or between tasks and an interrupt), and mutexes the better choice for implementing simple mutual exclusion.<br /><br />The priority of a task that 'takes' a mutex can potentially be raised if another task of higher priority attempts to obtain the same mutex. The task that owns the mutex 'inherits' the priority of the task attempting to 'take' the same mutex. This means the mutex must always be 'given' back - otherwise the higher priority task will never be able to obtain the mutex, and the lower priority task will never 'disinherit' the priority. An example of a mutex being used to implement mutual exclusion is provided on the xSemaphoreTake() documentation page.<br /><br />A binary semaphore need not be given back once obtained, so task synchronisation can be implemented by one task/interrupt continuously 'giving' the semaphore while another continuously 'takes' the semaphore. This is demonstrated by the sample code on the xSemaphoreGiveFromISR() documentation page.<br /><br />Both mutex and binary semaphores are assigned to variables of type xSemaphoreHandle and can be used in any API function that takes a parameter of this type. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> xSemaphoreHandle xSemaphoreCreateMutex(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>Return value:xSemaphoreHandle</i> - Handle to the created mutex semaphore.  Should be of type  xSemaphoreHandle.
</li>
</ul><br />
</li>
<li><a name="xSemaphoreTake">
<b>xSemaphoreTake</b></a>
 - Macro to obtain a semaphore. The semaphore must have previously been created with a call to vSemaphoreCreateBinary(), xSemaphoreCreateMutex() or xSemaphoreCreateCounting().<br /><br />This macro must not be called from an ISR. xQueueReceiveFromISR() can be used to take a semaphore from within an interrupt if required, although this would not be a normal operation. Semaphores use queues as their underlying mechanism, so functions are to some extent interoperable.<br /><br />xSemaphoreTake() is part of the fully featured intertask communications API. xSemaphoreAltTake() is the alternative API equivalent. Both versions require the same parameters and return the same values.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> bool xSemaphoreTake(xSemaphoreHandle xMutex, portTickType xBlockTime)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xMutex:xSemaphoreHandle</i> - A handle to the mutex being obtained.  This is the handle returned by xSemaphoreCreateMutex();</li>
<li><i>xBlockTime:byte</i> - The time in ticks to wait for the semaphore to become available.  The macro portTICK_RATE_MS can be used to convert this to a real time.  A block time of zero can be used to poll the semaphore.  If the task already owns the semaphore then xSemaphoreTakeRecursive() will return immediately no matter what the value of xBlockTime. Specifying the block time as portMAX_DELAY will cause the task to block indefinitely (without a timeout).</li>
<li><i>Return value:bool</i> - Returns pdTRUE if the semaphore was obtained.  pdFALSE if xBlockTime expired without the semaphore becoming available.
</li>
</ul><br />
</li>
<li><a name="xSemaphoreGive">
<b>xSemaphoreGive</b></a>
 - Macro to release a semaphore. The semaphore must have previously been created with a call to vSemaphoreCreateBinary(), xSemaphoreCreateMutex() or xSemaphoreCreateCounting(), and obtained using sSemaphoreTake().<br /><br />This must not be used from an ISR. See xSemaphoreGiveFromISR() for an alternative which can be used from an ISR.<br /><br />This macro must also not be used on semaphores created using xSemaphoreCreateRecursiveMutex().<br /><br />xSemaphoreGive() is part of the fully featured intertask communications API. xSemaphoreAltGive() is the alternative API equivalent. Both versions require the same parameters and return the same values. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> bool xSemaphoreGive(xSemaphoreHandle xMutex)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xMutex:xSemaphoreHandle</i> - A handle to the mutex being released, or 'given'.  This is the handle returned by xSemaphoreCreateMutex();</li>
<li><i>Return value:bool</i> - Returns pdTRUE if the semaphore was given.
</li>
</ul><br />
</li>
<li><a name="vSemaphoreCreateBinary">
<b>vSemaphoreCreateBinary</b></a>
 - Macro that creates a semaphore by using the existing queue mechanism. The queue length is 1 as this is a binary semaphore. The data size is 0 as we don't want to actually store any data - we just want to know if the queue is empty or full.<br /><br />Binary semaphores and mutexes are very similar but have some subtle differences: Mutexes include a priority inheritance mechanism, binary semaphores do not. This makes binary semaphores the better choice for implementing synchronisation (between tasks or between tasks and an interrupt), and mutexes the better choice for implementing simple mutual exclusion.<br /><br />A binary semaphore need not be given back once obtained, so task synchronisation can be implemented by one task/interrupt continuously 'giving' the semaphore while another continuously 'takes' the semaphore. This is demonstrated by the sample code on the xSemaphoreGiveFromISR() documentation page.<br /><br />The priority of a task that 'takes' a mutex can potentially be raised if another task of higher priority attempts to obtain the same mutex. The task that owns the mutex 'inherits' the priority of the task attempting to 'take' the same mutex. This means the mutex must always be 'given' back - otherwise the higher priority task will never be able to obtain the mutex, and the lower priority task will never 'disinherit' the priority. An example of a mutex being used to implement mutual exclusion is provided on the xSemaphoreTake() documentation page.<br /><br />Both mutex and binary semaphores are assigned to variables of type xSemaphoreHandle and can be used in any API function that takes a parameter of this type. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vSemaphoreCreateBinary(xSemaphoreHandle xSemaphore)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xSemaphore:xSemaphoreHandle</i> - Handle to the created semaphore. Should be of type xSemaphoreHandle.</li>
</ul><br />
</li>
<li><a name="xSemaphoreCreateCounting">
<b>xSemaphoreCreateCounting</b></a>
 - Macro that creates a counting semaphore by using the existing queue mechanism.<br /><br />Counting semaphores are typically used for two things:<br /><br />1. Counting events.<br />In this usage scenario an event handler will 'give' a semaphore each time an event occurs (incrementing the semaphore count value), and a handler task will 'take' a semaphore each time it processes an event (decrementing the semaphore count value). The count value is therefore the difference between the number of events that have occurred and the number that have been processed. In this case it is desirable for the initial count value to be zero.<br /><br />2. Resource management.<br />In this usage scenario the count value indicates the number of resources available. To obtain control of a resource a task must first obtain a semaphore - decrementing the semaphore count value. When the count value reaches zero there are no free resources. When a task finishes with the resource it 'gives' the semaphore back - incrementing the semaphore count value. In this case it is desirable for the initial count value to be equal to the maximum count value, indicating that all resources are free.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> xSemaphoreHandle xSemaphoreCreateCounting(unsigned_portBASE_TYPE uxMaxCount, unsigned_portBASE_TYPE uxInitialCount)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>uxMaxCount:unsigned_portBASE_TYPE</i> - The maximum count value that can be reached. When the semaphore reaches this value it can no longer be 'given'.</li>
<li><i>uxInitialCount:unsigned_portBASE_TYPE</i> - The count value assigned to the semaphore when it is created.</li>
<li><i>Return value:xSemaphoreHandle</i> - xSemaphoreHandle handle
</li>
</ul><br />
</li>
<li><a name="xSemaphoreGiveFromISR">
<b>xSemaphoreGiveFromISR</b></a>
 - Macro to release a semaphore. The semaphore must have previously been created with a call to vSemaphoreCreateBinary() or xSemaphoreCreateCounting().<br /><br />Mutex type semaphores (those created using a call to xSemaphoreCreateMutex()) must not be used with this macro.<br /><br />This macro can be used from an ISR.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> bool xSemaphoreGiveFromISR(xSemaphoreHandle xSemaphore, signed_portBASE_TYPE *pxHigherPriorityTaskWoken)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xSemaphore:xSemaphoreHandle</i> - A handle to the semaphore being released. This is the handle returned when the semaphore was created.</li>
<li><i>pxHigherPriorityTaskWoken: Pointer to signed_portBASE_TYPE</i> - xSemaphoreGiveFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if giving the semaphoree caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xSemaphoreGiveFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.</li>
<li><i>Return value:bool</i> - Returns pdTRUE if the semaphore was given.
</li>
</ul><br />
</li>
<li><a name="xSemaphoreTakeFromISR">
<b>xSemaphoreTakeFromISR</b></a>
 - Macro to take a semaphore from an ISR. The semaphore must have previously been created with a call to vSemaphoreCreateBinary() or xSemaphoreCreateCounting().<br /><br />Mutex type semaphores (those created using a call to xSemaphoreCreateMutex()) must not be used with this macro.<br /><br />This macro can be used from an ISR, however taking a semaphore from an ISR is not a common operation.  It is likely to only be useful when taking a counting semaphore when an interrupt is obtaining an object from a resource pool (when the semaphore count indicates the number of resources available).
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> bool xSemaphoreTakeFromISR(xSemaphoreHandle xSemaphore, signed_portBASE_TYPE *pxHigherPriorityTaskWoken)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xSemaphore:xSemaphoreHandle</i> - A handle to the semaphore being taken. This is the handle returned when the semaphore was created.</li>
<li><i>pxHigherPriorityTaskWoken: Pointer to signed_portBASE_TYPE</i> - xSemaphoreTakeFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if taking the semaphore caused a task to unblock, and the unblocked task has a priority higher than the currently running task.  If xSemaphoreTakeFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.</li>
<li><i>Return value:bool</i> - Returns pdTRUE if the semaphore was given.
</li>
</ul><br />
</li>
<li><a name="vSemaphoreDelete">
<b>vSemaphoreDelete</b></a>
 - Delete a semaphore.  This function must be used with care.  For example, do not delete a mutex type semaphore if the mutex is held by a task.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vSemaphoreDelete(xSemaphoreHandle xSemaphore)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xSemaphore:xSemaphoreHandle</i> - A handle to the semaphore to be deleted.</li>
</ul><br />
</li>
<li><a name="xSemaphoreGetMutexHolder">
<b>xSemaphoreGetMutexHolder</b></a>
 - Returns the holder of a mutex or semaphore. If xMutex is indeed a mutex type semaphore, return the current mutex holder. If xMutex is not a mutex type semaphore, or the mutex is available (not held by a task), return NULL. Note: This Is is a good way of determining if the calling task is the mutex holder, but not a good way of determining the identity of the mutex holder as the holder may change between the function exiting and the returned value being tested.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void* xSemaphoreGetMutexHolder(xSemaphoreHandle xSemaphore)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xSemaphore:xSemaphoreHandle</i> - A handle to the semaphore.</li>
<li><i>Return value:void*</i> - Not NULL if the calling task is the holder of the mutex, NULL otherwise.
</li>
</ul><br />
</li>
<li><a name="vTaskList">
<b>vTaskList</b></a>
 - configUSE_TRACE_FACILITY, INCLUDE_vTaskDelete and INCLUDE_vTaskSuspend must all be defined as 1 for this function to be available. See the configuration section for more information.<br />NOTE: This function will disable interrupts for its duration.  It is not intended for normal application runtime use but as a debug aid. Lists all the current tasks, along with their current state and stack usage high water mark.<br />Tasks are reported as blocked ('B'), ready ('R'), deleted ('D') or suspended ('S').
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vTaskList(signed portCHAR *pcWriteBuffer, size_t bufSize)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>pcWriteBuffer: Pointer to signed char</i> - Pointer to buffer. A buffer into which the above mentioned details will be written, in ascii form.  This buffer is assumed to be large enough to contain the generated report.  Approximately 40 bytes per task should be sufficient.</li>
<li><i>bufSize:uint16_t</i> - size of buffer</li>
</ul><br />
</li>
<li><a name="pvPortMalloc">
<b>pvPortMalloc</b></a>
 - Allocates a memory block using the port pvPortMalloc() function
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> pVoid pvPortMalloc(size_t xWantedSize)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xWantedSize:byte</i> - size of memory block requested</li>
<li><i>Return value:pVoid</i> - memory block or NULL if failed
</li>
</ul><br />
</li>
<li><a name="vPortFree">
<b>vPortFree</b></a>
 - Frees a memory block previously allocated with pvPortMalloc()
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vPortFree(void *pv)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>pv: Pointer to bool</i> - Pointer to data</li>
</ul><br />
</li>
<li><a name="xTaskGetSchedulerState">
<b>xTaskGetSchedulerState</b></a>
 - Returns the state of the scheduler
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> portBASE_TYPE xTaskGetSchedulerState(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>Return value:portBASE_TYPE</i> - One of the following constants (defined within task.h): taskSCHEDULER_NOT_STARTED, taskSCHEDULER_RUNNING, taskSCHEDULER_SUSPENDED.
</li>
</ul><br />
</li>
<li><a name="uxTaskGetStackHighWaterMark">
<b>uxTaskGetStackHighWaterMark</b></a>
 - The stack used by a task will grow and shrink as the task executes and interrupts are processed. uxTaskGetStackHighWaterMark() returns the minimum amount of remaining stack space that was available to the task since the task started executing - that is the amount of stack that remained unused when the task stack was at its greatest (deepest) value. This is what is referred to as the stack 'high water mark'.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> unsigned_portBASE_TYPE uxTaskGetStackHighWaterMark(xTaskHandle xTask)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xTask:xTaskHandle</i> - The handle of the task being queried. A task may query its own high water mark by passing NULL as the xTask parameter.</li>
<li><i>Return value:unsigned_portBASE_TYPE</i> - Error code
</li>
</ul><br />
</li>
<li><a name="uxTaskGetNumberOfTasks">
<b>uxTaskGetNumberOfTasks</b></a>
 - Returns the number of tasks
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> unsigned_portBASE_TYPE uxTaskGetNumberOfTasks(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>Return value:unsigned_portBASE_TYPE</i> - number of tasks
</li>
</ul><br />
</li>
<li><a name="vTaskGetRunTimeStats">
<b>vTaskGetRunTimeStats</b></a>
 - configGENERATE_RUN_TIME_STATS must be defined as 1 for this function to be available. The application must also then provide definitions for portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE to configure a peripheral timer/counter and return the timers current count value respectively. The counter should be at least 10 times the frequency of the tick count.<br />NOTE: This function will disable interrupts for its duration. It is not intended for normal application runtime use but as a debug aid.<br />Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total accumulated execution time being stored for each task. The resolution of the accumulated time value depends on the frequency of the timer configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro. Calling vTaskGetRunTimeStats() writes the total execution time of each task into a buffer, both as an absolute count value and as a percentage of the total system execution time. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vTaskGetRunTimeStats(portCHAR *pcWriteBuffer, size_t bufSize)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>pcWriteBuffer:byte</i> - A buffer into which the execution times will be written, in ascii form. This buffer is assumed to be large enough to contain the generated report. Approximately 40 bytes per task should be sufficient. </li>
<li><i>bufSize:word</i> - size of buffer</li>
</ul><br />
</li>
<li><a name="xPortGetFreeHeapSize">
<b>xPortGetFreeHeapSize</b></a>
 - Returns the actual free size of the heap
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> Tsize_t xPortGetFreeHeapSize(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>Return value:Tsize_t</i> - Error code
</li>
</ul><br />
</li>
<li><a name="xQueueCreate">
<b>xQueueCreate</b></a>
 - Creates a queue.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> xQueueHandle xQueueCreate(unsigned_portBASE_TYPE uxQueueLength, unsigned_portBASE_TYPE uxItemSize)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>uxQueueLength:unsigned_portBASE_TYPE</i> - The maximum number of items the queue can hold at any time.</li>
<li><i>uxItemSize:unsigned_portBASE_TYPE</i> - The size in bytes of each item the queue will hold.</li>
<li><i>Return value:xQueueHandle</i> - A handle to the created queue is returned provided the queue was created successfully. NULL is returned if the queue cannot be created because there is too little heap RAM available.
</li>
</ul><br />
</li>
<li><a name="vQueueDelete">
<b>vQueueDelete</b></a>
 - Deletes a queue that was previously created using a call to xQueueCreate(). vQueueDelete() can also be used to delete a semaphore.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vQueueDelete(xQueueHandle pxQueueToDelete)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>pxQueueToDelete:xQueueHandle</i> - The handle of the queue being deleted. Semaphore handles can also be used. Queues are used to pass data between tasks and between tasks and interrupts. A queue/semaphore must not be deleted if there are any tasks that are blocked on the queue/semaphore waiting for events (sends or receives).</li>
</ul><br />
</li>
<li><a name="xQueueSendToFront">
<b>xQueueSendToFront</b></a>
 - Sends an item to the front of a queue.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> portBASE_TYPE xQueueSendToFront(xQueueHandle xQueue, const void *pvItemToQueue, portTickType xTicksToWait)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xQueue:xQueueHandle</i> - The handle of the queue to which the data is to be sent.</li>
<li><i>pvItemToQueue:byte</i> - A pointer to the data to be sent to the queue. The size of the data that can be sent to a queue was defined when the queue was created.</li>
<li><i>xTicksToWait:portTickType</i> - The number of ticks for which the calling task should be held in the Blocked state to wait for space to become available on the queue should the queue already be full.<br />A value of zero will prevent the calling task from entering the Blocked state.<br />If INCLUDE_vTaskSuspend is set to 1 then a value of portMAX_DELAY will hold the task in the Blocked state indefinitely to wait for space to become available on the queue.</li>
<li><i>Return value:portBASE_TYPE</i> - pdPASS: Data was successfully sent to the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for space to become available and space did become available before the block time expired.<br />errQUEUE_FULL: The queue is already full so no data could be sent to the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for space to become available, but no space became available before the block time expired.
</li>
</ul><br />
</li>
<li><a name="xQueueSendToFrontFromISR">
<b>xQueueSendToFrontFromISR</b></a>
 - Versions of xQueueSendToFront() API functions that can be called from an ISR. Unlike xQueueSendToFront() these functions do not permit a block time to be specified.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> portBASE_TYPE xQueueSendToFrontFromISR(xQueueHandle xQueue, const void *pvItemToQueue, portBASE_TYPE *pxHigherPriorityTaskWoken)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xQueue:xQueueHandle</i> - The handle of the queue to which the data is to be sent.</li>
<li><i>pvItemToQueue:byte</i> - A pointer to the data to be sent to the queue. The size of the data that can be sent to a queue was defined when the queue was created.</li>
<li><i>pxHigherPriorityTaskWoken: Pointer to portBASE_TYPE</i> - xQueueSendFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xQueueSendFromISR() sets this value to pdTRUE then a context switch should be performed before the interrupt is exited.</li>
<li><i>Return value:portBASE_TYPE</i> - pdTRUE Data was successfully sent to the queue.<br />errQUEUE_FULL Data could not be sent to the queue because the queue was already full.
</li>
</ul><br />
</li>
<li><a name="xQueueSendToBack">
<b>xQueueSendToBack</b></a>
 - Sends an item to the back of a queue.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> portBASE_TYPE xQueueSendToBack(xQueueHandle xQueue, const void *pvItemToQueue, portTickType xTicksToWait)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xQueue:xQueueHandle</i> - The handle of the queue to which the data is to be sent.</li>
<li><i>pvItemToQueue:byte</i> - A pointer to the data to be sent to the queue. The size of the data that can be sent to a queue was defined when the queue was created.</li>
<li><i>xTicksToWait:portTickType</i> - The number of ticks for which the calling task should be held in the Blocked state to wait for space to become available on the queue should the queue already be full.<br />A value of zero will prevent the calling task from entering the Blocked state.<br />If INCLUDE_vTaskSuspend is set to 1 then a value of portMAX_DELAY will hold the task in the Blocked state indefinitely to wait for space to become available on the queue.</li>
<li><i>Return value:portBASE_TYPE</i> - pdPASS: Data was successfully sent to the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for space to become available and space did become available before the block time expired.<br />errQUEUE_FULL: The queue is already full so no data could be sent to the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for space to become available, but no space became available before the block time expired.
</li>
</ul><br />
</li>
<li><a name="xQueueSendToBackFromISR">
<b>xQueueSendToBackFromISR</b></a>
 - Versions of xQueueSendToBack() API functions that can be called from an ISR. Unlike xQueueSendToBack() these functions do not permit a block time to be specified.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> portBASE_TYPE xQueueSendToBackFromISR(xQueueHandle xQueue, const void *pvItemToQueue, portBASE_TYPE *pxHigherPriorityTaskWoken)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xQueue:xQueueHandle</i> - The handle of the queue to which the data is to be sent.</li>
<li><i>pvItemToQueue:byte</i> - A pointer to the data to be sent to the queue. The size of the data that can be sent to a queue was defined when the queue was created.</li>
<li><i>pxHigherPriorityTaskWoken: Pointer to portBASE_TYPE</i> - xQueueSendFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xQueueSendFromISR() sets this value to pdTRUE then a context switch should be performed before the interrupt is exited.</li>
<li><i>Return value:portBASE_TYPE</i> - pdTRUE Data was successfully sent to the queue.<br />errQUEUE_FULL Data could not be sent to the queue because the queue was already full.
</li>
</ul><br />
</li>
<li><a name="xQueueReceive">
<b>xQueueReceive</b></a>
 - Receives an item from a queue.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> portBASE_TYPE xQueueReceive(xQueueHandle xQueue, void *pvBuffer, portTickType xTicksToWait)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xQueue:xQueueHandle</i> - The handle of the queue from which the data is to be received.</li>
<li><i>pvBuffer:byte</i> - A pointer to the memory into which the data received from the queue will be copied.<br />The length of the buffer must be at least equal to the queue item size (set when the queue was created).</li>
<li><i>xTicksToWait:portTickType</i> - The number of ticks for which the calling task should be held in the Blocked state to wait for data to become available from the queue should the queue already be empty.<br />A value of zero will prevent the calling task from entering the Blocked state.<br />If INCLUDE_vTaskSuspend is set to 1 then a value of portMAX_DELAY will hold the task in the Blocked state indefinitely to wait for data.</li>
<li><i>Return value:portBASE_TYPE</i> - pdPASS: Data was successfully read from the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for data to become available and data did become available before the block time expired.<br />errQUEUE_EMPTY: The queue was empty so no date could be read form the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for data to become available, but no data became available before the block time expired.
</li>
</ul><br />
</li>
<li><a name="xQueueReceivefromISR">
<b>xQueueReceivefromISR</b></a>
 - A version of xQueueReceive() that can be called from an ISR. Unlike xQueueReceive(), xQueueReceiveFromISR() does not permit a block time to be specified.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> portBASE_TYPE xQueueReceivefromISR(xQueueHandle xQueue, void *pvBuffer, portBASE_TYPE *pxHigherPriorityTaskWoken)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xQueue:xQueueHandle</i> - The handle of the queue from which the data is to be received.</li>
<li><i>pvBuffer:byte</i> - A pointer to the memory into which the data received from the queue will be copied.The length of the buffer must be at least equal to the queue item size (set when the queue was created).</li>
<li><i>pxHigherPriorityTaskWoken: Pointer to portBASE_TYPE</i> - Pointer to A task may be blocked waiting for space to become available on the queue. If xQueueReceiveFromISR() causes such a task to unblock then *pxHigherPriorityTaskWoken will get set to pdTRUE, otherwise *pxHigherPriorityTaskWoken will remain unchanged.</li>
<li><i>Return value:portBASE_TYPE</i> - pdPASS: Data was successfully read from the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for data to become available and data did become available before the block time expired.<br />errQUEUE_EMPTY: The queue was empty so no date could be read form the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for data to become available, but no data became available before the block time expired.
</li>
</ul><br />
</li>
<li><a name="xQueuePeek">
<b>xQueuePeek</b></a>
 - Reads an item from a queue, but does not remove the item from the queue. Therefore the same item would be returned the next time xQueueReceive() or xQueuePeek() was called on the same queue.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> portBASE_TYPE xQueuePeek(xQueueHandle xQueue, void *pvBuffer, portTickType xTicksToWait)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xQueue:xQueueHandle</i> - The handle of the queue from which the data is to be read.</li>
<li><i>pvBuffer:byte</i> - A pointer to the memory into which the data read from the queue will be copied. The length of the buffer must be at least equal to the queue item size (set when the queue was created).</li>
<li><i>xTicksToWait:portTickType</i> - The number of ticks for which the calling task should be held in the Blocked state to wait for data to become available from the queue should the queue already be empty.<br />A value of zero will prevent the calling task from entering the Blocked state.<br />If INCLUDE_vTaskSuspend is set to 1 then a value of portMAX_DELAY will hold the task in the Blocked state indefinitely to wait for data.</li>
<li><i>Return value:portBASE_TYPE</i> - pdPASS: Data was successfully read from the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for data to become available and data did become available before the block time expired.<br />errQUEUE_EMPTY: The queue was empty so no date could be read form the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for data to become available, but no data became available before the block time expired.
</li>
</ul><br />
</li>
<li><a name="uxQueueMessagesWaiting">
<b>uxQueueMessagesWaiting</b></a>
 - Queries the number of items that are currently held within a queue.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> unsigned_portBASE_TYPE uxQueueMessagesWaiting(xQueueHandle xQueue)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xQueue:xQueueHandle</i> - The handle of the queue being queried.</li>
<li><i>Return value:unsigned_portBASE_TYPE</i> - The number of items that are held within the queue being queried.
</li>
</ul><br />
</li>
<li><a name="uxQueueMessagesWaitingfromISR">
<b>uxQueueMessagesWaitingfromISR</b></a>
 - A version of uxQueueMessagesWaiting() that can be used from inside an interrupt service routine.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> unsigned_portBASE_TYPE uxQueueMessagesWaitingfromISR(xQueueHandle xQueue)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xQueue:xQueueHandle</i> - The handle of the queue being queried.</li>
<li><i>Return value:unsigned_portBASE_TYPE</i> - The number of items that are held within the queue being queried.
</li>
</ul><br />
</li>
<li><a name="xQueueReset">
<b>xQueueReset</b></a>
 - Reset a queue back to its original empty state.  pdPASS is returned if the queue is successfully reset.  pdFAIL is returned if the queue could not be reset because there are tasks blocked on the queue waiting to either receive from the queue or send to the queue.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> portBASE_TYPE xQueueReset(xQueueHandle xQueue)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xQueue:xQueueHandle</i> - The handle of the queue to reset.</li>
<li><i>Return value:portBASE_TYPE</i> - pdPASS is returned if the queue is successfully reset. pdFAIL is returned if the queue could not be reset because there are tasks blocked on the queue waiting to either receive from the queue or send to the queue.
</li>
</ul><br />
</li>
<li><a name="ParseCommand">
<b>ParseCommand</b></a>
 - Shell Command Line Parser
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> byte ParseCommand(const unsigned char *cmd, bool *handled, const %@Shell@'ModuleName'%.StdIOType *io)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>cmd: Pointer to byte</i> - Pointer to command string</li>
<li><i>handled: Pointer to bool</i> - Pointer to variable which tells if the command has been handled or not</li>
<li><i>io: Pointer to byte</i> - Pointer to I/O structure</li>
<li><i>Return value:byte</i> - Error code
</li>
</ul><br />
</li>
<li><a name="Init">
<b>Init</b></a>
 - Low level initialization routine called from startup code. This method ensures that the tick timer is  not enabled.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void Init(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
</ul><br />
</li>

           </ul>
<!---USERBEG DON'T CHANGE THIS LINE-->

<!---USEREND DON'T CHANGE THIS LINE-->
<p>
<br />
Note: Some methods can be implemented as macros.
</p>
          </div>
          <p class="footer">
            PROCESSOR EXPERT is trademark of Freescale Semiconductor, Inc.
            <br />
            
          </p>
    </td>
  </tr>

</table>

</body>
</html>
