<?xml version="1.0" encoding="UTF-8"?>
<Bean>
  <Header>
    <Name>PercepioTrace</Name>
    <Description>Percepio FreeRTOS Trace</Description>
    <Author>Erich Styger</Author>
    <Version>01.021</Version>
    <Icon>irc</Icon>
    <TypesFiles>PE,PercepioTrace\PercepioTrace</TypesFiles>
    <FileVersion>6</FileVersion>
  </Header>
  <Options>
    <BW_HelpType>Basic</BW_HelpType>
    <BW_HelpFiles>,Properties,Methods,Events</BW_HelpFiles>
    <BW_AutoSaveHelp>yes</BW_AutoSaveHelp>
    <BW_AutoSaveDriver>yes</BW_AutoSaveDriver>
    <BW_DetailedHelp>yes</BW_DetailedHelp>
    <BW_NeedTps>yes</BW_NeedTps>
    <BW_NeedUst>1</BW_NeedUst>
    <BW_NeedCns>0</BW_NeedCns>
    <BeanStatus>PROPOSAL</BeanStatus>
    <Copyright>(c) Copyright Percepio AB, 2013-2014\nhttp      : www.percepio.se\nmail      : info@percepio.com\nProcessor Expert port: Erich Styger, 2013-2014</Copyright>
    <Category>Operating Systems</Category>
    <DemoDriver>no</DemoDriver>
    <Shortcut>PTRC</Shortcut>
    <BeanLevel>High</BeanLevel>
    <OnlyForInheritanceSharing>true</OnlyForInheritanceSharing>
  </Options>
  <PropertyList>
    <Property>
      <TCompNameItem>
        <Name>Component name</Name>
        <Symbol>DeviceName</Symbol>
        <Hint>Name of the component.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue/>
      </TCompNameItem>
    </Property>
    <Property>
      <TStrgItem>
        <Name>RTOS+Trace Version</Name>
        <Symbol>RTOSplusTraceVersion</Symbol>
        <Hint>Identifies the RTOS+Trace version used from Percepio AB</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue/>
        <StrDefine>nothing</StrDefine>
        <MinLength>0</MinLength>
        <MaxLength>-1</MaxLength>
      </TStrgItem>
    </Property>
    <Property>
      <TInhrLinkItem>
        <Name>Utility</Name>
        <Symbol>Utility</Symbol>
        <TypeSpec>Utility_I</TypeSpec>
        <Hint>Interface to utility functions</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <DefaultValue/>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <SortStyle/>
      </TInhrLinkItem>
    </Property>
    <Property>
      <TStrgItem>
        <Name>Description string</Name>
        <Symbol>TraceDescriptionString</Symbol>
        <Hint>This sets TRACE_DESCRIPTION in trcConfig.h\n
This string is stored in the trace and displayed in FreeRTOS+Trace. Can be used to store, e.g., system version or build date.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>FreeRTOS+Trace</DefaultValue>
        <StrDefine>nothing</StrDefine>
        <MinLength>0</MinLength>
        <MaxLength>63</MaxLength>
      </TStrgItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Description max length</Name>
        <Symbol>TraceDescriptionMaxLength</Symbol>
        <Hint>Sets the TRACE_DESCRIPTION_MAX_LENGTH macro. Generic system information string, presented in the tool. Note that this is also used for storing any internal error messages from the recorder, so do not make TRACE_DESCRIPTION_MAX_LENGTH too small. 80 is recommended.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>80</DefaultValue>
        <MinValue>8</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TBoolItem>
        <Name>Include user events</Name>
        <Symbol>IncludeUserEvents</Symbol>
        <TypeSpec>typeYesNo</TypeSpec>
        <Hint>This sets INCLUDE_USER_EVENTS in trcConfig.h\n
If this is zero (0) the code for creating User Events is excluded to reduce code size. User Events are application-generated events, like "printf" but for the trace log instead of console output. User Events are much faster than a printf and can therefore be used in timing critical code. See vTraceUserEvent() and vTracePrintF() in trcUser.h.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
      </TBoolItem>
    </Property>
    <Property>
      <TBoolItem>
        <Name>Include ISR tracing</Name>
        <Symbol>IncludeISRTracing</Symbol>
        <TypeSpec>typeYesNo</TypeSpec>
        <Hint>This sets INCLUDE_ISR_TRACING in trcConfig.h\n
If this is zero (0), the code for recording Interrupt Service Routines is excluded to reduce code size. Note, recording ISRs require that you insert calls to vTraceStoreISRBegin and vTraceStoreISREnd in your interrupt handlers. There is no automatic recording of ISRs like for task scheduling, since FreeRTOS does not have a central interrupt dispatcher.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
      </TBoolItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Max ISR Nesting</Name>
        <Symbol>TraceMaxISRNesting</Symbol>
        <Hint>Defines the maxium level of ISR nesting</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>16</DefaultValue>
        <MinValue>1</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TBoolItem>
        <Name>Include object delete events</Name>
        <Symbol>IncludeObjectDelete</Symbol>
        <TypeSpec>typeYesNo</TypeSpec>
        <Hint>This sets INCLUDE_OBJECT_DELETE in trcConfig.h\n
This must be enabled (1) if tasks, queues or other traced kernel objects are deleted at runtime, e.g., using vTaskDelete or vQueueDelete. If no deletes are made, this can be set to 0 in order to exclude the delete-handling code. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
      </TBoolItem>
    </Property>
    <Property>
      <TBoolItem>
        <Name>Include new time events</Name>
        <Symbol>IncludeNewTimeEvents</Symbol>
        <TypeSpec>typeYesNo</TypeSpec>
        <Hint>This sets INCLUDE_NEW_TIME_EVENTS in trcConfig.h\n
This must be enabled (1) if it shall be recorded whenever the os clock is increased.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
      </TBoolItem>
    </Property>
    <Property>
      <TBoolItem>
        <Name>Include memory manager events</Name>
        <Symbol>IncludeMemManageEvents</Symbol>
        <TypeSpec>typeYesNo</TypeSpec>
        <Hint>This sets INCLUDE_MEMMANG_EVENTS in trcConfig.h\n
This must be enabled (1) if memory allocation and deallocatinon have to be traced.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
      </TBoolItem>
    </Property>
    <Property>
      <TEnumItem>
        <Name>Trace Data Allocation</Name>
        <Symbol>TraceDataAllocation</Symbol>
        <TypeSpec>typeTraceDataAllocation</TypeSpec>
        <Hint>This defines the macro TRACE_DATA_ALLOCATION. This defines how to allocate the recorder data structure, i.e., using a  static declaration or using a dynamic allocation in runtime (malloc). Should be one of these two options:\n
 - TRACE_DATA_ALLOCATION_STATIC (default)\n
 - TRACE_DATA_ALLOCATION_DYNAMIC\n
Using static allocation has the benefits of compile-time errors if the buffer is too large (too large constants in trcConfig.h) and no need to call the initialization routine (xTraceInitTraceData). Using dynamic allocation may give more flexibility in some cases.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
      </TEnumItem>
    </Property>
    <Property>
      <TEnumItem>
        <Name>Recorder store mode</Name>
        <Symbol>RecorderStoreMode</Symbol>
        <TypeSpec>typeRecorderStoreMode</TypeSpec>
        <Hint>This sets RECORDER_STORE_MODE in trcConfig.h\n
With RECORDER_STORE_MODE set to STORE_MODE_RING_BUFFER, the events are stored in a ring buffer, i.e., where the oldest events are overwritten when the buffer becomes full. This allows you to get the last events leading up to an interesting state, e.g., an error, without having a large trace buffer for string the whole run since startup. In this mode, the recorder can run "forever" as the buffer never gets full, i.e., in the sense that it always has room for more events.\n
\n
To fetch the trace in mode STORE_MODE_RING_BUFFER, you need to first halt the system using your debugger and then do a RAM dump, or to explicitly stop the recorder using vTraceStop() and then store/upload the trace data using a FreeRTOS task that you need to provide yourself. The trace data is found in the struct RecorderData, initialized in trcBase.c.\n
\n
Note that, if you upload the trace using a RAM dump, i.e., when the system is halted on a breakpoint or by a debugger command, there is no need to stop the recorder first.\n
\n
When RECORDER_STORE_MODE is STORE_MODE_STOP_WHEN_FULL, the recording is stopped when the buffer becomes full. When the recorder stops itself this way vTracePortEnd() is called which allows for custom actions, such as triggering a task that stores the trace buffer, i.e., in case taking a RAM dump using an on-chip debugger is not possible. In the Windows port, vTracePortEnd saves the trace to file directly, but this is not recommended in a real-time system since the scheduler is blocked during the processing of vTracePortEnd.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
      </TEnumItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Stop after N events</Name>
        <Symbol>StopAfterNevents</Symbol>
        <Hint>This sets STOP_AFTER_N_EVENTS in trcConfig.h\n
\n
STOP_AFTER_N_EVENTS is intended for tests of the ring buffer mode (when RECORDER_STORE_MODE is STORE_MODE_RING_BUFFER). It stops the recording when the specified number of events has been observed. This value can be larger than the buffer size, to allow for test of the "wrapping around" that occurs in ring buffer mode . A negative value (or no definition of this macro) disables this feature.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>-1</DefaultValue>
        <MinValue>-1</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TBoolItem>
        <Name>Use implicit IFE rules</Name>
        <Symbol>UseImplicitIFErules</Symbol>
        <TypeSpec>typeYesNo</TypeSpec>
        <Hint>This sets USE_IMPLICIT_IFE_RULES in trcConfig.h\n
### Instance Finish Events (IFE) ###\n
\n
For tasks with "infinite" main loops (non-terminating tasks), the concept of a task instance has no clear definition, it is an application-specific thing. FreeRTOS+Trace allows you to define Instance Finish Events (IFEs), which marks the point when a task instance ends. The IFE is a blocking kernel call, typically in the main loop of a task which typically reads a message queue, waits for a semaphore or performs an explicit delay.\n
\n
If USE_IMPLICIT_IFE_RULES is one (1), the following FreeRTOS kernel calls are considered by default to be IFEs (Implicit IFEs):\n
 - vTaskDelay\n
 - vTaskDelayUntil\n
 - vTaskSuspend\n
 - xQueueReceive\n
 - xSemaphoreTake\n
\n
However, Implicit IFEs only applies to blocking kernel calls. If an xQueueReceive reads a message without blocking, it does not create a new instance since no blocking occurred.\n
\n
Moreover, the actual IFE might sometimes be another blocking call such as xQueueSend or xSemaphoreGive. We therefore allow for user-defined explicit IFEs by calling\n
       vTraceTaskInstanceIsFinished()\n
right before the kernel call considered as IFE. This does not create an additional event but instead stores the service code and object handle of the IFE call as properties of the task.\n
\n
If using Explicit IFEs and the task also calls an Implicit IFE like vTaskDelay, this may result in additional incorrect task instances. This is solved by disabling the Implicit IFEs for the task, by adding a call to\n
       vTraceTaskSkipDefaultInstanceFinishedEvents()\n
in the very beginning of that task. This allows you to combine Explicit IFEs for some tasks with Implicit IFEs for the rest of the tasks, if USE_IMPLICIT_IFE_RULES is 1.\n
\n
By setting USE_IMPLICIT_IFE_RULES to zero (0), the implicit IFEs are disabled for all tasks. Tasks will then be considered to have a single instance only, covering all execution fragments, unless you define an explicit IFE in the task.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
      </TBoolItem>
    </Property>
    <Property>
      <TBoolItem>
        <Name>Include event stats</Name>
        <Symbol>IncludeEventStats</Symbol>
        <TypeSpec>typeYesNo</TypeSpec>
        <Hint>This sets INCLUDE_EVENT_STATS in trcConfig.h\n
If enabled (1), the recorder will count each type of event, in order to give an immediate picture (in a console print), regarding what events that is using significant buffer space. In the Windows emulation port, vTracePortEnd() will print this info when the recorder is stopped. This is not recommended in a real-time system, as vTracePortEnd is called from the kernel and blocks it until vTracePortEnd returns.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
      </TBoolItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Event Count Size</Name>
        <Symbol>EventCountSize</Symbol>
        <Hint>If 'Include event stats' is enabled, then this defines the size of the gloabal event count array. This setting defines the EVENT_COUNT_SIZE macro.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>256</DefaultValue>
        <MinValue>1</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TBoolItem>
        <Name>Float support</Name>
        <Symbol>floatingPointForvTracePrintF</Symbol>
        <TypeSpec>typeYesNo</TypeSpec>
        <Hint>If floating point is supported for vTracePrintF()</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
      </TBoolItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Event buffer size</Name>
        <Symbol>EventBufferSize</Symbol>
        <Hint>This sets EVENT_BUFFER_SIZE in trcConfig.h\n
Macro which should be defined as an integer value.\n
This defines the capacity of the event buffer, i.e., the number of records it may store. An event typically use one record (4 byte), but there are exceptions:\n
In some cases, an XTS event is added if the time since the last event is longer that allowed by the current event's timestamp field. Such events thus use two records. vTracePrintF use a variable number of data records following the event, holding the data arguments. \n
If RECORDER_STORE_MODE is STORE_MODE_RING_BUFFER, the recorder will wrap around to index 0 when reached EVENT_BUFFER_SIZE. If RECORDER_STORE_MODE is STORE_MODE_STOP_WHEN_FULL, the recorder is instead stopped (see RECORDER_STORE_MODE).</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>1200</DefaultValue>
        <MinValue>1</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Symbol table size</Name>
        <Symbol>SymbolTableSize</Symbol>
        <Hint>This sets SYMBOL_TABLE_SIZE in trcConfig.h\n
Macro which should be defined as an integer value.\n
This defines the capacity of the symbol table, in bytes. This symbol table stores User Events labels and names of deleted tasks, queues, or other kernel objects. Note that the names of active objects not stored here but in the Object Table. Thus, if you don't use User Events or delete any kernel objects you set this to zero (0) to minimize RAM usage.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>400</DefaultValue>
        <MinValue>0</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Number of tasks</Name>
        <Symbol>NTask</Symbol>
        <Hint>This sets NTask in trcConfig.h\n
A group of Macros which should be defined as an integer value of zero (0) or larger.\n
This defines the capacity of the Object Table, in number of objects, of each object class. The Object Table holds information about the currently active kernel objects (i.e., the ones that have been created but not terminated), such as name and Tracelayzer ID, for Tasks, Queues, Semaphores, Mutexes and user-registered ISRs.\n
This does not limit the total amount of objects created, if objects are deleted during runtime. The object table size however limits the number of objects active at any given time, since the slots in the Object Table are reused when objects are deleted.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>10</DefaultValue>
        <MinValue>0</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Number of ISR</Name>
        <Symbol>NISR</Symbol>
        <Hint>This sets NISR in trcConfig.h\n
A group of Macros which should be defined as an integer value of zero (0) or larger.\n
This defines the capacity of the Object Table, in number of objects, of each object class. The Object Table holds information about the currently active kernel objects (i.e., the ones that have been created but not terminated), such as name and Tracelayzer ID, for Tasks, Queues, Semaphores, Mutexes and user-registered ISRs.\n
This does not limit the total amount of objects created, if objects are deleted during runtime. The object table size however limits the number of objects active at any given time, since the slots in the Object Table are reused when objects are deleted.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>4</DefaultValue>
        <MinValue>0</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Number of queue</Name>
        <Symbol>NQueue</Symbol>
        <Hint>This sets NQueue in trcConfig.h\n
A group of Macros which should be defined as an integer value of zero (0) or larger.\n
This defines the capacity of the Object Table, in number of objects, of each object class. The Object Table holds information about the currently active kernel objects (i.e., the ones that have been created but not terminated), such as name and Tracelayzer ID, for Tasks, Queues, Semaphores, Mutexes and user-registered ISRs.\n
This does not limit the total amount of objects created, if objects are deleted during runtime. The object table size however limits the number of objects active at any given time, since the slots in the Object Table are reused when objects are deleted.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>3</DefaultValue>
        <MinValue>0</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Number of semaphore</Name>
        <Symbol>NSemaphore</Symbol>
        <Hint>This sets NSemaphore in trcConfig.h\n
A group of Macros which should be defined as an integer value of zero (0) or larger.\n
This defines the capacity of the Object Table, in number of objects, of each object class. The Object Table holds information about the currently active kernel objects (i.e., the ones that have been created but not terminated), such as name and Tracelayzer ID, for Tasks, Queues, Semaphores, Mutexes and user-registered ISRs.\n
This does not limit the total amount of objects created, if objects are deleted during runtime. The object table size however limits the number of objects active at any given time, since the slots in the Object Table are reused when objects are deleted.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>4</DefaultValue>
        <MinValue>0</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Number of mutex</Name>
        <Symbol>NMutex</Symbol>
        <Hint>This sets NMutex in trcConfig.h\n
A group of Macros which should be defined as an integer value of zero (0) or larger.\n
This defines the capacity of the Object Table, in number of objects, of each object class. The Object Table holds information about the currently active kernel objects (i.e., the ones that have been created but not terminated), such as name and Tracelayzer ID, for Tasks, Queues, Semaphores, Mutexes and user-registered ISRs.\n
This does not limit the total amount of objects created, if objects are deleted during runtime. The object table size however limits the number of objects active at any given time, since the slots in the Object Table are reused when objects are deleted.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>4</DefaultValue>
        <MinValue>0</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Number of Timer</Name>
        <Symbol>NTimer</Symbol>
        <Hint>This sets the NTimer define.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>2</DefaultValue>
        <MinValue>0</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Number of Event Groups</Name>
        <Symbol>NEventGroup</Symbol>
        <Hint>This sets the NEventGroup macro.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>2</DefaultValue>
        <MinValue>0</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TStrgItem>
        <Name>Name length for task</Name>
        <Symbol>NameLenTaskStr</Symbol>
        <Hint>This sets NameLenTask in trcConfig.h\n
A group of Macros which should be defined as an integer value of zero (0) or larger.\n
This defines the capacity of the Object Table, in number of objects, of each object class. The Object Table holds information about the currently active kernel objects (i.e., the ones that have been created but not terminated), such as name and Tracelayzer ID, for Tasks, Queues, Semaphores, Mutexes and user-registered ISRs.\n
This does not limit the total amount of objects created, if objects are deleted during runtime. The object table size however limits the number of objects active at any given time, since the slots in the Object Table are reused when objects are deleted.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>configMAX_TASK_NAME_LEN</DefaultValue>
        <StrDefine>nothing</StrDefine>
        <MinLength>0</MinLength>
        <MaxLength>-1</MaxLength>
      </TStrgItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Name length for ISR</Name>
        <Symbol>NameLenISR</Symbol>
        <Hint>This sets NameLenISR in trcConfig.h\n
A group of Macros which should be defined as an integer value of zero (0) or larger.\n
This defines the capacity of the Object Table, in number of objects, of each object class. The Object Table holds information about the currently active kernel objects (i.e., the ones that have been created but not terminated), such as name and Tracelayzer ID, for Tasks, Queues, Semaphores, Mutexes and user-registered ISRs.\n
This does not limit the total amount of objects created, if objects are deleted during runtime. The object table size however limits the number of objects active at any given time, since the slots in the Object Table are reused when objects are deleted.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>10</DefaultValue>
        <MinValue>0</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Name length for queue</Name>
        <Symbol>NameLenQueue</Symbol>
        <Hint>This sets NameLenQueue in trcConfig.h\n
A group of Macros which should be defined as an integer value of zero (0) or larger.\n
This defines the capacity of the Object Table, in number of objects, of each object class. The Object Table holds information about the currently active kernel objects (i.e., the ones that have been created but not terminated), such as name and Tracelayzer ID, for Tasks, Queues, Semaphores, Mutexes and user-registered ISRs.\n
This does not limit the total amount of objects created, if objects are deleted during runtime. The object table size however limits the number of objects active at any given time, since the slots in the Object Table are reused when objects are deleted.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>15</DefaultValue>
        <MinValue>0</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Name length for semaphore</Name>
        <Symbol>NameLenSemaphore</Symbol>
        <Hint>This sets NameLenSemaphore in trcConfig.h\n
A group of Macros which should be defined as an integer value of zero (0) or larger.\n
This defines the capacity of the Object Table, in number of objects, of each object class. The Object Table holds information about the currently active kernel objects (i.e., the ones that have been created but not terminated), such as name and Tracelayzer ID, for Tasks, Queues, Semaphores, Mutexes and user-registered ISRs.\n
This does not limit the total amount of objects created, if objects are deleted during runtime. The object table size however limits the number of objects active at any given time, since the slots in the Object Table are reused when objects are deleted.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>15</DefaultValue>
        <MinValue>0</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Name length for mutex</Name>
        <Symbol>NameLenMutex</Symbol>
        <Hint>This sets NameLenMutex in trcConfig.h\n
A group of Macros which should be defined as an integer value of zero (0) or larger.\n
This defines the capacity of the Object Table, in number of objects, of each object class. The Object Table holds information about the currently active kernel objects (i.e., the ones that have been created but not terminated), such as name and Tracelayzer ID, for Tasks, Queues, Semaphores, Mutexes and user-registered ISRs.\n
This does not limit the total amount of objects created, if objects are deleted during runtime. The object table size however limits the number of objects active at any given time, since the slots in the Object Table are reused when objects are deleted.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>15</DefaultValue>
        <MinValue>0</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Name length for timer</Name>
        <Symbol>NameLenTimer</Symbol>
        <Hint>Sets NameLenTimer define.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>15</DefaultValue>
        <MinValue>0</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Name length for event group</Name>
        <Symbol>NameLenEventGroup</Symbol>
        <Hint>Sets NameLenEventGroup define.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>15</DefaultValue>
        <MinValue>0</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
  </PropertyList>
  <MethodList>
    <Method>
      <TMthdItem>
        <Name>uiTraceStart</Name>
        <Symbol>uiTraceStart</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Starts the trace.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>32bit unsigned</ReturnType>
        <RetHint>returns 1 if trace has been started, 0 otherwise.</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>dword #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTraceStop</Name>
        <Symbol>vTraceStop</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Stops the trace.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTraceClear</Name>
        <Symbol>vTraceClear</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Clears the trace.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>uiTraceGetTraceBufferSize</Name>
        <Symbol>uiTraceGetTraceBufferSize</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Gets the size of the recorder data structure. For use together with vTraceGetTraceBuffer if you wish to implement an own store/upload solution, e.g., in case a debugger connection is not available for uploading the data.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>32bit unsigned</ReturnType>
        <RetHint>Size of the trace buffer</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>dword #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTraceGetTraceBuffer</Name>
        <Symbol>vTraceGetTraceBuffer</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Return a pointer to the recorder data structure. Use this together with uiTraceGetTraceBufferSize if you wish to implement an own store/upload solution, e.g., in case a debugger connection is not available for uploading the data.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>pointer</ReturnType>
        <RetHint>Pointer to the trace buffer</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void* #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTraceSetTimerFrequency</Name>
        <Symbol>vTraceSetTimerFrequency</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Use this to define the frequency of the timer/counter used for timestamping (in Hz)</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>frequency</ParName>
          <ParType>32bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>frequency</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(dword frequency)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTraceOpenLabel</Name>
        <Symbol>xTraceOpenLabel</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Open/create symbol to use as user event handle for related user events (conceptually like a file handle)</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>traceLabel</ReturnType>
        <RetHint>trace label</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>label</ParName>
          <ParType>char</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to label</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>traceLabel #M#_#C#(char *label)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTraceUserEvent</Name>
        <Symbol>vTraceUserEvent</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Simple user event - store a label, created using xTraceOpenLabel</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>eventLabel</ParName>
          <ParType>traceLabel</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>trace label for the user event</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(traceLabel eventLabel)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTracePrintF</Name>
        <Symbol>vTracePrintF</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Advanced user event - like printf (but limited formatting support - will improve)</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>eventLabel</ParName>
          <ParType>traceLabel</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>trace label</ParHint>
        </Parameter>
        <Parameter>
          <ParName>formatStr</ParName>
          <ParType>char</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to format string</ParHint>
        </Parameter>
        <Parameter>
          <ParName>Variable_1</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>open parameter list</ParHint>
          <ParUserDeclaration>...</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(traceLabel eventLabel, char *formatStr, ...)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTraceStartStatusMonitor</Name>
        <Symbol>vTraceStartStatusMonitor</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>This starts a task to monitor the state of the recorder. This task periodically prints a line to the console window, which shows the number of events recorded and the latest timestamp. This task calls vTracePortEnd when the recorder has been stopped, where custom actions can be added, e.g., to store the trace to a file if a file system is available on the device.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTraceSetQueueName</Name>
        <Symbol>vTraceSetQueueName</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Assigns a name to a FreeRTOS Queue, Semaphore or Mutex. This function should  be called right after creation of the queue/mutex/semaphore. If not using this function, the queues/mutexes/semaphores will be presented by their numeric handle only.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>queue</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to the queue</ParHint>
          <ParUserDeclaration>void *queue</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>name</ParName>
          <ParType>char</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to name</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void *queue, char *name)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTraceSetISRProperties</Name>
        <Symbol>vTraceSetISRProperties</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Registers an Interrupt Service Routine in the recorder library, This must be called before using vTraceStoreISRBegin to store ISR events. This is typically called in the startup of the system, before the scheduler is started. Method is always enabled if 'Include ISR tracing' is set to 'yes' in the properties.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>handle</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>handle to be used</ParHint>
          <ParUserDeclaration>objectHandleType handle</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>name</ParName>
          <ParType>char</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to name</ParHint>
        </Parameter>
        <Parameter>
          <ParName>prioritiy</ParName>
          <ParType>char</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>priority</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(objectHandleType handle, char *name, char prioritiy)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTraceStoreISRBegin</Name>
        <Symbol>vTraceStoreISRBegin</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Registers the beginning of an Interrupt Service Routine. This must not be interrupted by another ISR containing recorder library calls, so if allowing nested ISRs this must be called with interrupts disabled.  Method is always enabled if 'Include ISR tracing' is set to 'yes' in the properties.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>id</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>ID of the ISR</ParHint>
          <ParUserDeclaration>objectHandleType id</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(objectHandleType id)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTraceStoreISREnd</Name>
        <Symbol>vTraceStoreISREnd</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Registers the end of an Interrupt Service Routine. This must not be interrupted by another ISR containing recorder library calls, so if allowing nested ISRs this must be called with interrupts disabled.  Method is always enabled if 'Include ISR tracing' is set to 'yes' in the properties.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTraceTaskSkipDefaultInstanceFinishedEvents</Name>
        <Symbol>vTraceTaskSkipDefaultInstanceFinishedEvents</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>This is useful if there are implicit Instance Finish Events, such as vTaskDelayUntil or xQueueReceive, in a task where an explicit Instance Finish Event has been defined. This function tells the recorder that only the explicitly defined functions, using vTraceTaskInstanceIsFinished, should be treated as Instance Finish Events for this task. The implicit Instance Finish Events are thus disregarded for this task.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTraceTaskInstanceIsFinished</Name>
        <Symbol>vTraceTaskInstanceIsFinished</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>This defines an explicit Instance Finish Event for the current task. It tells the recorder that the current instance of this task is finished at the next kernel call of the task, e.g., a taskDelay or a queue receive. This function should be called right before the api function call considered to be the end of the task instance, i.e., the Instance Finish Event.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTraceExcludeTaskFromSchedulingTrace</Name>
        <Symbol>vTraceExcludeTaskFromSchedulingTrace</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Excludes a task from the recording using a flag in the Object Property Table. This can be useful if some irrelevant task is very frequent and is "eating up the buffer". This should be called the task has been created, but  before starting the FreeRTOS scheduler.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>name</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>name of the task</ParHint>
          <ParUserDeclaration>const char* name</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(const char* name)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTraceInitTraceData</Name>
        <Symbol>vTraceInitTraceData</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Allocates, if necessary, and initializes the recorder data structure, based on the settings.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>pointer</ReturnType>
        <RetHint>Pointer to trace data (RecorderDataType*)</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void* #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
  </MethodList>
  <EventList>
    <Event>
      <TStrgItem>
        <Name>Event module name</Name>
        <Symbol>EventModule</Symbol>
        <Hint>Name of the user module (without extension), where the events from this component are placed.</Hint>
        <ItemLevel>ADVANCED</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>Events</DefaultValue>
        <StrDefine>nothing</StrDefine>
        <MinLength>0</MinLength>
        <MaxLength>-1</MaxLength>
      </TStrgItem>
    </Event>
    <Event>
      <TEvntItem>
        <Name>OnTraceStop</Name>
        <Symbol>OnTraceStop</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Called if the library calls vTraceStop(). Useful to dump the trace if 'stop when recorder is full' mode is selected.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>don't generate code</Description>
        <Expanded>No</Expanded>
        <DefaultValue>false</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <IsAssembler>false</IsAssembler>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #C#(void)</ANSIC>
        </Declarations>
        <Children>
          <GrupItem>
            <TEvntName>
              <Name>Event procedure name</Name>
              <Symbol>Name</Symbol>
              <Hint>OnTraceStop procedure name</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue/>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
              <ErrorIfNotSet>true</ErrorIfNotSet>
              <IdentType>EVNT</IdentType>
            </TEvntName>
          </GrupItem>
        </Children>
      </TEvntItem>
    </Event>
    <Event>
      <TEvntItem>
        <Name>OnTraceStart</Name>
        <Symbol>OnTraceStart</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Called when vTraceStart() gets called.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>don't generate code</Description>
        <Expanded>No</Expanded>
        <DefaultValue>false</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <IsAssembler>false</IsAssembler>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #C#(void)</ANSIC>
        </Declarations>
        <Children>
          <GrupItem>
            <TEvntName>
              <Name>Event procedure name</Name>
              <Symbol>Name</Symbol>
              <Hint>OnTraceStart procedure name</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue/>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
              <ErrorIfNotSet>true</ErrorIfNotSet>
              <IdentType>EVNT</IdentType>
            </TEvntName>
          </GrupItem>
        </Children>
      </TEvntItem>
    </Event>
    <Event>
      <TEvntItem>
        <Name>OnTraceWrap</Name>
        <Symbol>OnTraceWrap</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Called for trace ring buffer wrap around. This gives the application a chance to dump the trace buffer.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>generate code</Description>
        <Expanded>Yes</Expanded>
        <DefaultValue>true</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <IsAssembler>false</IsAssembler>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #C#(void)</ANSIC>
        </Declarations>
        <Children>
          <GrupItem>
            <TEvntName>
              <Name>Event procedure name</Name>
              <Symbol>Name</Symbol>
              <Hint>OnTraceWrap procedure name</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue/>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
              <ErrorIfNotSet>true</ErrorIfNotSet>
              <IdentType>EVNT</IdentType>
            </TEvntName>
          </GrupItem>
        </Children>
      </TEvntItem>
    </Event>
  </EventList>
  <Links>
    <EmptySection_DummyValue/>
  </Links>
  <Revisions>
    <RevisionVersion>2</RevisionVersion>
  </Revisions>
</Bean>
