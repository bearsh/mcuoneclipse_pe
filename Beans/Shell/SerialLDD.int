<?xml version="1.0" encoding="UTF-8"?>
<Interface>
  <Name>SerialLDD</Name>
  <Description>Interface "FSShell\SerialLDD" for component FSShell, generated by Component Wizard</Description>
  <Author>Erich Styger</Author>
  <Version>01.006</Version>
  <FileVersion>2</FileVersion>
  <MethodList>
    <Method>
      <TMthdItem>
        <Name>Init</Name>
        <Symbol>Init</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Initializes the device. Allocates memory for the device data structure, allocates interrupt vectors and sets interrupt priority, sets pin routing, sets timing, etc. If the "Enable in init. code" is set to "yes" value then the device is also enabled(see the description of the Enable() method). In this case the Enable() method is not necessary and needn't to be generated. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>true</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>LDD_TDeviceData*</ReturnType>
        <RetHint>Device data structure pointer.</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>UserDataPtr</ParName>
          <ParType>LDD_TUserData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to the user or RTOS specific data. This pointer will be passed as an event or callback parameter.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>LDD_TDeviceData* #M#_#C#(LDD_TUserData *UserDataPtr)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendBlock</Name>
        <Symbol>SendBlock</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Sends a block of characters. The method returns ERR_BUSY when the previous block transmission is not completed. Method &lt;a href="#CancelBlockTransmission"&gt;CancelBlockTransmission&lt;/a&gt; can be used to cancel a transmit operation. This method is available only if the transmitter property is enabled.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>true</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>LDD_TError</ReturnType>
        <RetHint>Error code, possible codes:\n     ERR_OK - OK\n     ERR_SPEED - The component does not work in the active clock configuration.\n     ERR_DISABLED - The component or device is disabled.\n     ERR_BUSY - The previous transmit request is pending.</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>DeviceDataPtr</ParName>
          <ParType>LDD_TDeviceData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Device data structure pointer returned by &lt;a href="#Init"&gt;Init&lt;/a&gt; method.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>BufferPtr</ParName>
          <ParType>LDD_TData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to a buffer from where data will be sent.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>Size</ParName>
          <ParType>uint16_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Number of characters in the buffer.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>LDD_TError #M#_#C#(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, uint16_t Size)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>ReceiveBlock</Name>
        <Symbol>ReceiveBlock</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Specifies the number of data to receive. The method returns ERR_BUSY until the specified number of characters is received. Method &lt;a href="#CancelBlockReception"&gt;CancelBlockReception&lt;/a&gt; can be used to cancel a running receive operation.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>true</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>LDD_TError</ReturnType>
        <RetHint>Error code, possible codes:\n     ERR_OK - OK\n     ERR_SPEED - The component does not work in the active clock configuration.\n     ERR_DISABLED - The component or device is disabled.\n     ERR_BUSY - The previous receive request is pending.</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>DeviceDataPtr</ParName>
          <ParType>LDD_TDeviceData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Device data structure pointer returned by &lt;a href="#Init"&gt;Init&lt;/a&gt; method.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>BufferPtr</ParName>
          <ParType>LDD_TData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to a buffer where received characters will be stored.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>Size</ParName>
          <ParType>uint16_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Number of characters to receive</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>LDD_TError #M#_#C#(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, uint16_t Size)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>GetReceivedDataNum</Name>
        <Symbol>GetReceivedDataNum</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Returns the number of received characters in the receive buffer. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>true</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>uint16_t</ReturnType>
        <RetHint>Number of received characters in the receive buffer.</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>DeviceDataPtr</ParName>
          <ParType>LDD_TDeviceData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Device data structure pointer returned by &lt;a href="#Init"&gt;Init&lt;/a&gt; method.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>uint16_t #M#_#C#(LDD_TDeviceData *DeviceDataPtr)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
  </MethodList>
  <EventList>
    <Event>
      <TEvntItem>
        <Name>OnBlockReceived</Name>
        <Symbol>OnBlockReceived</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>This event is called when the requested number of data is moved to the input buffer.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <IsInSimulink>true</IsInSimulink>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>generate code</Description>
        <Expanded>Yes</Expanded>
        <DefaultValue>true</DefaultValue>
        <DefineSymbol>DEF_UNDEF</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <IsAssembler>true</IsAssembler>
        <Mode>meiAsOwnr_!Exist</Mode>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>UserDataPtr</ParName>
          <ParType>LDD_TUserData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to the user or RTOS specific data. This pointer is passed as the parameter of Init method.</ParHint>
        </Parameter>
        <Scope>OVERRIDE</Scope>
        <Declarations>
          <ANSIC>void #C#(LDD_TUserData *UserDataPtr)</ANSIC>
        </Declarations>
        <Children>
          <GrupItem>
            <TEvntName>
              <Name>Event procedure name</Name>
              <Symbol>Name</Symbol>
              <Hint>OnBlockReceived procedure name</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue/>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
              <ErrorIfNotSet>true</ErrorIfNotSet>
              <IdentType>EVNT</IdentType>
            </TEvntName>
          </GrupItem>
        </Children>
      </TEvntItem>
    </Event>
    <Event>
      <TEvntItem>
        <Name>OnBlockSent</Name>
        <Symbol>OnBlockSent</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>This event is called after the last character from the output buffer is moved to the transmitter. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <IsInSimulink>true</IsInSimulink>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>generate code</Description>
        <Expanded>Yes</Expanded>
        <DefaultValue>true</DefaultValue>
        <DefineSymbol>DEF_UNDEF</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <IsAssembler>true</IsAssembler>
        <Mode>meiAlwReq_!Exist</Mode>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>UserDataPtr</ParName>
          <ParType>LDD_TUserData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to the user or RTOS specific data. This pointer is passed as the parameter of Init method.</ParHint>
        </Parameter>
        <Scope>OVERRIDE</Scope>
        <Declarations>
          <ANSIC>void #C#(LDD_TUserData *UserDataPtr)</ANSIC>
        </Declarations>
        <Children>
          <GrupItem>
            <TEvntName>
              <Name>Event procedure name</Name>
              <Symbol>Name</Symbol>
              <Hint>OnBlockSent procedure name</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue/>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
              <ErrorIfNotSet>true</ErrorIfNotSet>
              <IdentType>EVNT</IdentType>
            </TEvntName>
          </GrupItem>
        </Children>
      </TEvntItem>
    </Event>
  </EventList>
  <Registration>
    <Template>Serial_LDD</Template>
  </Registration>
  <UserTypes>
    <Type>
      <UsrType>TRetypeType</UsrType>
      <Name>TComData</Name>
      <Hint>User type for communication. Size of this type depends on the communication data witdh.</Hint>
      <Generate>no</Generate>
      <Unique>yes</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint>  typedef word %'ModuleName'_TComData ;/* User type for communication. Size of this type depends on the communication data witdh. */\n
</PreparedHint>
      <Type>16bit unsigned</Type>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_SERIAL_TError</Name>
      <Hint>Error flags.</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint> /* Error flags. */\n
</PreparedHint>
      <Type/>
      <HWTestType>32bit unsigned</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_TError</Name>
      <Hint>Error identifier type</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint> /* Error identifier type */\n
</PreparedHint>
      <Type/>
      <HWTestType>16bit unsigned</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_TPinMask</Name>
      <Hint>Bit mask of pins that need to be connected</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint> /* Bit mask of pins that need to be connected */\n
</PreparedHint>
      <Type/>
      <HWTestType>16bit unsigned</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_TUserData</Name>
      <Hint>Pointer to this type specifying the user or RTOS specific data will be passed as an event or callback parameter.</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint> /* Pointer to this type specifying the user or RTOS specific data will be passed as an event or callback parameter. */\n
</PreparedHint>
      <Type/>
      <HWTestType>pointer</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_SERIAL_TSize</Name>
      <Hint>Buffer size or data length</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint> /* Buffer size or data length */\n
</PreparedHint>
      <Type/>
      <HWTestType>16bit signed</HWTestType>
    </Type>
    <Type>
      <UsrType>TEnumType</UsrType>
      <Name>LDD_SERIAL_TParity</Name>
      <Hint>Parity type&lt;br/&gt;&lt;dl&gt;&lt;dt&gt;PARITY_UNDEF&lt;/dt&gt;&lt;dd&gt;Undefined parity type&lt;/dd&gt;&lt;dt&gt;PARITY_NONE&lt;/dt&gt;&lt;dd&gt;No parity&lt;/dd&gt;&lt;dt&gt;PARITY_ODD&lt;/dt&gt;&lt;dd&gt;Odd parity&lt;/dd&gt;&lt;dt&gt;PARITY_EVEN&lt;/dt&gt;&lt;dd&gt;Even parity&lt;/dd&gt;&lt;dt&gt;PARITY_MARK&lt;/dt&gt;&lt;dd&gt;Force parity to high&lt;/dd&gt;&lt;dt&gt;PARITY_SPACE&lt;/dt&gt;&lt;dd&gt;Force parity to low&lt;/dd&gt;&lt;/dl&gt;</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint>  typedef enum { /* Parity type&lt;br/&gt;&lt;dl&gt;&lt;dt&gt;PARITY_UNDEF&lt;/dt&gt;&lt;dd&gt;Undefined parity type&lt;/dd&gt;&lt;dt&gt;PARITY_NONE&lt;/dt&gt;&lt;dd&gt;No parity&lt;/dd&gt;&lt;dt&gt;PARITY_ODD&lt;/dt&gt;&lt;dd&gt;Odd parity&lt;/dd&gt;&lt;dt&gt;PARITY_EVEN&lt;/dt&gt;&lt;dd&gt;Even parity&lt;/dd&gt;&lt;dt&gt;PARITY_MARK&lt;/dt&gt;&lt;dd&gt;Force parity to high&lt;/dd&gt;&lt;dt&gt;PARITY_SPACE&lt;/dt&gt;&lt;dd&gt;Force parity to low&lt;/dd&gt;&lt;/dl&gt; */\n
    PARITY_UNDEF,\n
    PARITY_NONE,\n
    PARITY_ODD,\n
    PARITY_EVEN,\n
    PARITY_MARK,\n
    PARITY_SPACE\n
  } LDD_SERIAL_TParity;\n
</PreparedHint>
      <EnumCount>6</EnumCount>
      <Enum>PARITY_UNDEF</Enum>
      <Enum>PARITY_NONE</Enum>
      <Enum>PARITY_ODD</Enum>
      <Enum>PARITY_EVEN</Enum>
      <Enum>PARITY_MARK</Enum>
      <Enum>PARITY_SPACE</Enum>
    </Type>
    <Type>
      <UsrType>TRetypeType</UsrType>
      <Name>LDD_SERIAL_TDataWidth</Name>
      <Hint>Bit length</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint>  typedef word LDD_SERIAL_TDataWidth ;/* Bit length */\n
</PreparedHint>
      <Type>16bit unsigned</Type>
    </Type>
    <Type>
      <UsrType>TEnumType</UsrType>
      <Name>LDD_SERIAL_TStopBitLen</Name>
      <Hint>Stop-bit length&lt;br/&gt;&lt;dl&gt;&lt;dt&gt;STOP_BIT_LEN_UNDEF&lt;/dt&gt;&lt;dd&gt;Undefined stop-bit length&lt;/dd&gt;&lt;dt&gt;STOP_BIT_LEN_1&lt;/dt&gt;&lt;dd&gt;Stop-bit length is equal to 1 bit&lt;/dd&gt;&lt;dt&gt;STOP_BIT_LEN_1_5&lt;/dt&gt;&lt;dd&gt;Stop-bit length is equal to 1.5 bit&lt;/dd&gt;&lt;dt&gt;STOP_BIT_LEN_2&lt;/dt&gt;&lt;dd&gt;Stop-bit length is equal to 2 bit&lt;/dd&gt;&lt;/dl&gt;</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint>  typedef enum { /* Stop-bit length&lt;br/&gt;&lt;dl&gt;&lt;dt&gt;STOP_BIT_LEN_UNDEF&lt;/dt&gt;&lt;dd&gt;Undefined stop-bit length&lt;/dd&gt;&lt;dt&gt;STOP_BIT_LEN_1&lt;/dt&gt;&lt;dd&gt;Stop-bit length is equal to 1 bit&lt;/dd&gt;&lt;dt&gt;STOP_BIT_LEN_1_5&lt;/dt&gt;&lt;dd&gt;Stop-bit length is equal to 1.5 bit&lt;/dd&gt;&lt;dt&gt;STOP_BIT_LEN_2&lt;/dt&gt;&lt;dd&gt;Stop-bit length is equal to 2 bit&lt;/dd&gt;&lt;/dl&gt; */\n
    STOP_BIT_LEN_UNDEF,\n
    STOP_BIT_LEN_1,\n
    STOP_BIT_LEN_1_5,\n
    STOP_BIT_LEN_2\n
  } LDD_SERIAL_TStopBitLen;\n
</PreparedHint>
      <EnumCount>4</EnumCount>
      <Enum>STOP_BIT_LEN_UNDEF</Enum>
      <Enum>STOP_BIT_LEN_1</Enum>
      <Enum>STOP_BIT_LEN_1_5</Enum>
      <Enum>STOP_BIT_LEN_2</Enum>
    </Type>
    <Type>
      <UsrType>TRetypeType</UsrType>
      <Name>LDD_SERIAL_TBaudMode</Name>
      <Hint>Baud rate mode identifier</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint>  typedef byte LDD_SERIAL_TBaudMode ;/* Baud rate mode identifier */\n
</PreparedHint>
      <Type>8bit unsigned</Type>
    </Type>
    <Type>
      <UsrType>TRecordType</UsrType>
      <Name>LDD_SERIAL_TStats</Name>
      <Hint>Communication statistics</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint>  typedef struct { /* Communication statistics */\n
    dword ReceivedChars; /* Number of received characters */\n
    dword SentChars; /* Number of transmitted characters */\n
    dword ReceivedBreaks; /* Number of received break characters */\n
    dword ParityErrors; /* Number of receiver parity errors */\n
    dword FramingErrors; /* Number of receiver framing errors */\n
    dword OverrunErrors; /* Number of receiver overrun errors */\n
    dword NoiseErrors; /* Number of receiver noise errors */\n
  } LDD_SERIAL_TStats;\n
</PreparedHint>
      <RecordItem>
        <ItemName>ReceivedChars</ItemName>
        <ItemType>32bit unsigned</ItemType>
        <ItemHint>Number of received characters</ItemHint>
        <ItemPointer>no</ItemPointer>
      </RecordItem>
      <RecordItem>
        <ItemName>SentChars</ItemName>
        <ItemType>32bit unsigned</ItemType>
        <ItemHint>Number of transmitted characters</ItemHint>
        <ItemPointer>no</ItemPointer>
      </RecordItem>
      <RecordItem>
        <ItemName>ReceivedBreaks</ItemName>
        <ItemType>32bit unsigned</ItemType>
        <ItemHint>Number of received break characters</ItemHint>
        <ItemPointer>no</ItemPointer>
      </RecordItem>
      <RecordItem>
        <ItemName>ParityErrors</ItemName>
        <ItemType>32bit unsigned</ItemType>
        <ItemHint>Number of receiver parity errors</ItemHint>
        <ItemPointer>no</ItemPointer>
      </RecordItem>
      <RecordItem>
        <ItemName>FramingErrors</ItemName>
        <ItemType>32bit unsigned</ItemType>
        <ItemHint>Number of receiver framing errors</ItemHint>
        <ItemPointer>no</ItemPointer>
      </RecordItem>
      <RecordItem>
        <ItemName>OverrunErrors</ItemName>
        <ItemType>32bit unsigned</ItemType>
        <ItemHint>Number of receiver overrun errors</ItemHint>
        <ItemPointer>no</ItemPointer>
      </RecordItem>
      <RecordItem>
        <ItemName>NoiseErrors</ItemName>
        <ItemType>32bit unsigned</ItemType>
        <ItemHint>Number of receiver noise errors</ItemHint>
        <ItemPointer>no</ItemPointer>
      </RecordItem>
    </Type>
    <Type>
      <UsrType>TEnumType</UsrType>
      <Name>LDD_SERIAL_TLoopMode</Name>
      <Hint>Looping modes&lt;br/&gt;&lt;dl&gt;&lt;dt&gt;LOOPMODE_UNDEF&lt;/dt&gt;&lt;dd&gt;Undefined looping mode&lt;/dd&gt;&lt;dt&gt;LOOPMODE_NORMAL&lt;/dt&gt;&lt;dd&gt;Normal mode (without looping)&lt;/dd&gt;&lt;dt&gt;LOOPMODE_AUTO_ECHO&lt;/dt&gt;&lt;dd&gt;Automatic echo mode. Automatically resends received data bit by bit. Transmitter is disabled.&lt;/dd&gt;&lt;dt&gt;LOOPMODE_LOCAL_LOOPBACK&lt;/dt&gt;&lt;dd&gt;Local loopback mode. Transmitter output is internally connected to receiver input.&lt;/dd&gt;&lt;dt&gt;LOOPMODE_REMOTE_LOOPBACK&lt;/dt&gt;&lt;dd&gt;Remote loopback mode. Receiver automatically resends data bit by bit. Receiver and transmitter are disabled.&lt;/dd&gt;&lt;/dl&gt;</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint>  typedef enum { /* Looping modes&lt;br/&gt;&lt;dl&gt;&lt;dt&gt;LOOPMODE_UNDEF&lt;/dt&gt;&lt;dd&gt;Undefined looping mode&lt;/dd&gt;&lt;dt&gt;LOOPMODE_NORMAL&lt;/dt&gt;&lt;dd&gt;Normal mode (without looping)&lt;/dd&gt;&lt;dt&gt;LOOPMODE_AUTO_ECHO&lt;/dt&gt;&lt;dd&gt;Automatic echo mode. Automatically resends received data bit by bit. Transmitter is disabled.&lt;/dd&gt;&lt;dt&gt;LOOPMODE_LOCAL_LOOPBACK&lt;/dt&gt;&lt;dd&gt;Local loopback mode. Transmitter output is internally connected to receiver input.&lt;/dd&gt;&lt;dt&gt;LOOPMODE_REMOTE_LOOPBACK&lt;/dt&gt;&lt;dd&gt;Remote loopback mode. Receiver automatically resends data bit by bit. Receiver and transmitter are disabled.&lt;/dd&gt;&lt;/dl&gt; */\n
    LOOPMODE_UNDEF,\n
    LOOPMODE_NORMAL,\n
    LOOPMODE_AUTO_ECHO,\n
    LOOPMODE_LOCAL_LOOPBACK,\n
    LOOPMODE_REMOTE_LOOPBACK\n
  } LDD_SERIAL_TLoopMode;\n
</PreparedHint>
      <EnumCount>5</EnumCount>
      <Enum>LOOPMODE_UNDEF</Enum>
      <Enum>LOOPMODE_NORMAL</Enum>
      <Enum>LOOPMODE_AUTO_ECHO</Enum>
      <Enum>LOOPMODE_LOCAL_LOOPBACK</Enum>
      <Enum>LOOPMODE_REMOTE_LOOPBACK</Enum>
    </Type>
    <Type>
      <UsrType>TRetypeType</UsrType>
      <Name>uint8_t</Name>
      <Hint/>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>  typedef byte uint8_t ;\n
</PreparedHint>
      <Type>8bit unsigned</Type>
    </Type>
    <Type>
      <UsrType>TRetypeType</UsrType>
      <Name>uint16_t</Name>
      <Hint/>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>  typedef word uint16_t ;\n
</PreparedHint>
      <Type>16bit unsigned</Type>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_TEventMask</Name>
      <Hint>Event mask type.</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint> /* Event mask type. */\n
</PreparedHint>
      <Type/>
      <HWTestType>uint32_t</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_TData</Name>
      <Hint/>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>void\n
</PreparedHint>
      <Type>void</Type>
      <HWTestType>pointer</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_TDeviceData</Name>
      <Hint>Pointer to this type, specifying the private component state information and data, has to be passed as a parameter to every component's method.</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint> /* Pointer to this type, specifying the private component state information and data, has to be passed as a parameter to every component's method. */\n
</PreparedHint>
      <Type/>
      <HWTestType>pointer</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_TDeviceData*</Name>
      <Hint>Init method of the component creates the private state structure and returns the pointer to it. This pointer needs to be passed to every component method.</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint> /* Init method of the component creates the private state structure and returns the pointer to it. This pointer needs to be passed to every component method. */\n
</PreparedHint>
      <Type/>
      <HWTestType>pointer</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_TClockConfiguration</Name>
      <Hint>CPU clock configuration type. Index of the pre-configured clock configuration in the CPU component.</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint> /* CPU clock configuration type. Index of the pre-configured clock configuration in the CPU component. */\n
</PreparedHint>
      <Type/>
      <HWTestType>8bit unsigned</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_TDriverOperationMode</Name>
      <Hint>Driver operation mode type.</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint> /* Driver operation mode type. */\n
</PreparedHint>
      <Type/>
      <HWTestType>8bit unsigned</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_TCallback</Name>
      <Hint>Callback type used for definition of callback functions. </Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint> /* Callback type used for definition of callback functions.  */\n
</PreparedHint>
      <Type/>
      <HWTestType>pointer</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_TDriverState</Name>
      <Hint>Driver state type.  </Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint> /* Driver state type.   */\n
</PreparedHint>
      <Type/>
      <HWTestType>16bit unsigned</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_TCallbackParam</Name>
      <Hint>Callback parameter type used for callback functions. </Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint> /* Callback parameter type used for callback functions.  */\n
</PreparedHint>
      <Type/>
      <HWTestType>pointer</HWTestType>
    </Type>
    <Type>
      <UsrType>TRetypeType</UsrType>
      <Name>uint32_t</Name>
      <Hint/>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>  typedef dword uint32_t ;\n
</PreparedHint>
      <Type>32bit unsigned</Type>
    </Type>
  </UserTypes>
</Interface>
