<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1250">
<title>
Component  documentation - Methods
</title>
<STYLE type="text/css">
body{
  background-color: white;
  margin:0px;
  font: 13px Helvetica Neue, Helvetica, Arial, sans-serif;
}
A:visited {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:link {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:active {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:hover {
	COLOR: #2D8AA7; TEXT-DECORATION: underline
}
.VSP {
	COLOR: #2D8AA7; FONT: bold italic 14px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.reflink {
	FONT: 11px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
 	COLOR: #2D8AA7;
}
.user_text {
	FONT: 12px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
	COLOR: #000000;
}
.bluetext {
  COLOR: #695F52;
}
.versionspec {
  padding:5px; 
  background-color: RGB(243, 242, 230);
  margin-top:5px;
  margin-bottom:5px;  
}
.versionspecdetail {
  padding:5px; 
  background-color: RGB(243, 242, 230);
  margin-top:5px;
  margin-bottom:5px;  
}
.versionspeclabel {
  font-style: italic;
}
LI.DEF {
  list-style-image: url(DefaultLI.gif) ;
}
LI.BAS {
	list-style-image: url(BasicLI.gif) ;
}
LI.ADV {
	list-style-image: url(AdvancedLI.gif) ;
}
LI.EXP {
	list-style-image: url(ExpertLI.gif) ;
}
.titlebox {  
  font: bold 18px Helvetica Neue, Helvetica, Arial, sans-serif;
  color: #51626F;
  margin-bottom: 10px;
}
.lefttitlebox {
  background-color:#C3CFD1;  
}
.lefttitle {
  color:#51626F;
  font: bold 11px Helvetica Neue, Helvetica, Arial, sans-serif;   
}
.beanname {
  font: bold 14px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
  padding-top:6px;
  padding-bottom:5px;
  margin-bottom: 5px;
  border-bottom-style: dotted;
  border-bottom-width: 1;  
}
.descrtext {
  font-style: italic;
  font: 14px/18px Helvetica Neue, Helvetica, Arial, sans-serif;  
  padding-bottom:9px;
}
.footer {
  color: #b0b0b0; 
  font: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
  text-align: center;
  border-top-style: solid;
  border-top-color: #BOBOBO;
  border-top-width: 1px;  
  padding-top: 5px;
  margin-top: 20px;
}
.info_name {
  font: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
  padding: 0px;
  color: black;
}
.info_text {
  font: 11px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.text_title {
  COLOR: #000000; 
  FONT: bold 14px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.descr_line {
  COLOR: gray; 
  FONT: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.code {
  background-color: RGB(243, 242, 230);
  padding: 10px;
  white-space: pre;
  font-family: Courier New, Monospace;
}
</STYLE>

</head>

<body>

<table border="0"  cellspacing="0" cellpadding="0">
  <tr>
    <td valign="top" width="150" >
      <table  width="150" height="160" cellpadding="3" cellspacing="0" border="0">
        <tbody>
        <tr class="lefttitlebox">
          <td width="4"></td>
          <td align="center" valign="middle" height="30" width="128">
            <span class="lefttitle">
<b>MAG3110</b>
            </span>
          </td>
        </tr>
        <tr height="700">
          <td width="4"></td>
          <td width="128" valign="top">
            &nbsp;<br />
            <div class="reflink">
<!---HTMLLISTBEG_SHORT DON'T CHANGE THIS LINE-->
<a href="MAG3110.html">General Info</a><br />
<a href="MAG3110Properties.html">Properties</a><br />
<i>Methods</i><br />
<a href="MAG3110Events.html">Events</a><br />
<a href="MAG3110User Types.html">Types and constants</a><br />
<!---HTMLLISTEND DON'T CHANGE THIS LINE-->
<br /><br /><br />
<a href="../../DOCs/PredefSymbols.html">Types &amp; definitions</a><br/>
<a href="../../DOCs/BEANindex.html">Component Index</a><br/>
<a href="../../DOCs/CPUindex.html">CPU Component Index</a><br/>
<a href="../../DOCs/EmbeddedBeans.html">Embedded Components</a><br/>
<a href="../../DOCs/BeanCategories.html">Components Categories</a><br/>

<br /><br /><br />
<center>
<img src="MAG3110_b.gif" alt="Component icon"/>


</center>
            </div>
          </td>
        </tr>
        </tbody>
      </table>
    </td>
    <td width="1" class="lefttitlebox" valign="top">
      <table class="lefttitlebox" width="1" cellpadding="0" cellspacing="0" height="100%" border="0">
        <tr class="lefttitlebox"><td width="1"></td></tr>
      </table>
    </td>
    <td style="padding-left:15px;padding-right:10px;" valign="top" align="left" width="100%" >

         <div class="titlebox">
            <div class="beanname">
              Component
              
              
              MAG3110
            </div>
            <div class="descrtext">Driver for the Freescale MAG3110 digital magnetometer</div>
            <div class="info_name">Component Level: <span class="info_text"><a href="../../DOCs/BeanCategoriesInfo.html#LevelAbstraction">Low</a></span></div>
            <div class="info_name">Category: 
              <span class="info_text">
              <a href="../../DOCs/BeanCategoriesInfo.html">CPU External Devices-Sensor</a>
              
              </span>
            </div>
          </div>

         <div class="text_title">
              Methods:
    		 </div>		 
    		 <div class="descr_line">                  
              (Methods are user-callable functions/subroutines intended for
               the component functions control. Please see the <a href="../../DOCs/EmbeddedBeans.html#Methods">Embedded Components page</a> for more information.)                   
         </div>
                  
         <div class="user_text">
            <ul>
<!---USERBEG DON'T CHANGE THIS LINE-->

<!---USEREND DON'T CHANGE THIS LINE-->
<li><a name="Enable">
<b>Enable</b></a>
 - Enables the device with setting the ACTIVE bit in the CTRL register 1
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> byte Enable(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>Return value:byte</i> - Error code
</li>
</ul><br />
</li>
<li><a name="Disable">
<b>Disable</b></a>
 - Disables the device with clearing the ACTIVE bit in the CTRL register 1
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> byte Disable(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>Return value:byte</i> - Error code
</li>
</ul><br />
</li>
<li><a name="GetXYZ8">
<b>GetXYZ8</b></a>
 - Returns in an array the x, y and z sensor values as 8bit values. Note that for this method the FAST_READ flag *shall* be set.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> uint8_t GetXYZ8(signed char *xyz)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xyz: Pointer to signed char</i> - Pointer to an array of three signed 8bit values which are used to return the accelerometer values.</li>
<li><i>Return value:uint8_t</i> - Error code, ERR_OK for no error.
</li>
</ul><br />
</li>
<li><a name="GetXYZ16">
<b>GetXYZ16</b></a>
 - Returns in an array the x, y and z sensor values as 16bit values. Note that for this method the FAST_READ flag shall not be set.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> uint8_t GetXYZ16(int16_t *xyz)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xyz: Pointer to int16_t</i> - Pointer to an array of three signed 16bit values which are used to return the accelerometer values.</li>
<li><i>Return value:uint8_t</i> - Error code, ERR_OK for no error.
</li>
</ul><br />
</li>
<li><a name="GetX">
<b>GetX</b></a>
 - Returns the X magnetometer value.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> word GetX(int16_t *value)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>value: Pointer to int16_t</i> - Pointer to where to store the value</li>
<li><i>Return value:word</i> - Error code
</li>
</ul><br />
</li>
<li><a name="GetY">
<b>GetY</b></a>
 - Returns the Y magnetometer value.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> word GetY(int16_t *value)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>value: Pointer to int16_t</i> - Pointer to where to store the value</li>
<li><i>Return value:word</i> - Error code
</li>
</ul><br />
</li>
<li><a name="GetZ">
<b>GetZ</b></a>
 - Returns the Z magnetometer value.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> word GetZ(int16_t *value)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>value: Pointer to int16_t</i> - Pointer to where to store the value</li>
<li><i>Return value:word</i> - Error code
</li>
</ul><br />
</li>
<li><a name="SetFastReadMode">
<b>SetFastReadMode</b></a>
 - Turns the FR (Fast Read Mode) bit in CTRL_REG_1 on or off
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> byte SetFastReadMode(bool on)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>on:bool</i> - if to turn the FR mode on or off</li>
<li><i>Return value:byte</i> - Error code
</li>
</ul><br />
</li>
<li><a name="GetFastReadMode">
<b>GetFastReadMode</b></a>
 - Returns the FR (Fast Read Mode) status in the CTRL_REG_1 register
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> byte GetFastReadMode(bool *isOn)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>isOn: Pointer to bool</i> - Pointer to where to store the status of the FR bit</li>
<li><i>Return value:byte</i> - Error code
</li>
</ul><br />
</li>
<li><a name="SetTriggerImmediateMode">
<b>SetTriggerImmediateMode</b></a>
 - Turns the TM (Trigger Immediate Measurement) bit in CTRL_REG_1 on or off
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> byte SetTriggerImmediateMode(bool on)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>on:bool</i> - if to turn the TM mode on or off</li>
<li><i>Return value:byte</i> - Error code
</li>
</ul><br />
</li>
<li><a name="GetTriggerImmediateMode">
<b>GetTriggerImmediateMode</b></a>
 - Returns if TM (Trigger Immediate Mode) in the CTRL_REG_1 register is on or off
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> byte GetTriggerImmediateMode(bool *isOn)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>isOn: Pointer to bool</i> - Pointer to where to store the status</li>
<li><i>Return value:byte</i> - Error code
</li>
</ul><br />
</li>
<li><a name="SetOversamplingMode">
<b>SetOversamplingMode</b></a>
 - Sets the OS (oversampling selection) bits in the CTRL_REG_1 register.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> byte SetOversamplingMode(byte bits)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>bits:byte</i> - Oversampling mode, one of CTRL_REG_1_OS_xxxHZ_BIT_MASK</li>
<li><i>Return value:byte</i> - Error code
</li>
</ul><br />
</li>
<li><a name="GetOversamplingMode">
<b>GetOversamplingMode</b></a>
 - Returns the OS (oversampling selection) bits in the CTRL_REG_1 register.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> byte GetOversamplingMode(byte *bits)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>bits: Pointer to byte</i> - Pointer to where to store the oversampling mode bits, one of CTRL_REG_1_OS_xxxHZ_BIT_MASK</li>
<li><i>Return value:byte</i> - Error code
</li>
</ul><br />
</li>
<li><a name="SetDataRateMode">
<b>SetDataRateMode</b></a>
 - Sets the DR (data rate) bits in the CTRL_REG_1 register.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> byte SetDataRateMode(byte bits)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>bits:byte</i> - Oversampling mode, one of CTRL_REG_1_DR_xxxHZ_BIT_MASK</li>
<li><i>Return value:byte</i> - Error code
</li>
</ul><br />
</li>
<li><a name="GetDataRateMode">
<b>GetDataRateMode</b></a>
 - Returns the DR (data rate) bits in the CTRL_REG_1 register.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> byte GetDataRateMode(byte *bits)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>bits: Pointer to byte</i> - Pointer to where to store the oversampling mode bits, one of CTRL_REG_1_DR_xxxHZ_BIT_MASK</li>
<li><i>Return value:byte</i> - Error code
</li>
</ul><br />
</li>
<li><a name="SetRawMode">
<b>SetRawMode</b></a>
 - Turns the RAW (Raw or data output correction) bit in CTRL_REG_2 on or off
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> byte SetRawMode(bool on)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>on:bool</i> - if to turn the RAW mode on or off</li>
<li><i>Return value:byte</i> - Error code
</li>
</ul><br />
</li>
<li><a name="GetRawMode">
<b>GetRawMode</b></a>
 - Returns the RAW (raw or data output correction) status in the CTRL_REG_2 register
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> byte GetRawMode(bool *isOn)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>isOn: Pointer to bool</i> - Pointer to where to store the status of the RAW bit</li>
<li><i>Return value:byte</i> - Error code
</li>
</ul><br />
</li>
<li><a name="GetTemperature">
<b>GetTemperature</b></a>
 - Returns the temperature of the die as signed 8bit values in degree Celsius
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> byte GetTemperature(signed char *temperature)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>temperature: Pointer to signed char</i> - Pointer to variable where to store the temperature</li>
<li><i>Return value:byte</i> - Error code
</li>
</ul><br />
</li>
<li><a name="WhoAmI">
<b>WhoAmI</b></a>
 - Returns the value of the WHO_AM_I (0x07) register
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> byte WhoAmI(byte *value)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>value: Pointer to byte</i> - Pointer to where to store the value</li>
<li><i>Return value:byte</i> - Error code
</li>
</ul><br />
</li>
<li><a name="GetSysMode">
<b>GetSysMode</b></a>
 - Returns the SYSMOD (0x08) status
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> byte GetSysMode(byte *mode)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>mode: Pointer to byte</i> - Pointer to where to store the value. Returns 0x00 (STANDBY), 0x01 (ACTIVE, raw data) or 0x02 (ACTIVE, non-RAW data)</li>
<li><i>Return value:byte</i> - Error code
</li>
</ul><br />
</li>
<li><a name="SetSysMode">
<b>SetSysMode</b></a>
 - Sets the SYSMOD (0x08) status register
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> byte SetSysMode(byte mode)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>mode:byte</i> - Set the system mode. 0x00 (SYSMOD_STANDBY_BIT_MASK), 0x01 (SYSMOD_ACTIVE_RAW_BIT_MASK) or 0x02 (SYSMOD_ACTIVE_BIT_MASK)</li>
<li><i>Return value:byte</i> - Error code
</li>
</ul><br />
</li>
<li><a name="GetUserOffsetCorrection">
<b>GetUserOffsetCorrection</b></a>
 - Returns the user offset correction values from the device
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> byte GetUserOffsetCorrection(int16_t *x, int16_t *y, int16_t *z)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>x: Pointer to int16_t</i> - Pointer to where to store the x offset</li>
<li><i>y: Pointer to int16_t</i> - Pointer to where to store the y offset</li>
<li><i>z: Pointer to int16_t</i> - Pointer to where to store the z offset</li>
<li><i>Return value:byte</i> - Error code
</li>
</ul><br />
</li>
<li><a name="SetUserOffsetCorrection">
<b>SetUserOffsetCorrection</b></a>
 - Sets the user offset correction values
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> byte SetUserOffsetCorrection(int16_t x, int16_t y, int16_t z)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>x:int16_t</i> - x offset</li>
<li><i>y:int16_t</i> - y offset</li>
<li><i>z:int16_t</i> - z offset</li>
<li><i>Return value:byte</i> - Error code
</li>
</ul><br />
</li>
<li><a name="WriteReg">
<b>WriteReg</b></a>
 - Writes to a device register address
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> byte WriteReg(byte reg, byte val)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>reg:byte</i> - register address</li>
<li><i>val:byte</i> - Value to write</li>
<li><i>Return value:byte</i> - Error code
</li>
</ul><br />
</li>
<li><a name="ParseCommand">
<b>ParseCommand</b></a>
 - Shell Command Line parser. This method is enabled/disabled depending on if you have the Shell enabled/disabled in the properties.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> byte ParseCommand(const unsigned char *cmd, bool *handled, const %@Shell@'ModuleName'%.StdIOType *io)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>cmd: Pointer to byte</i> - Pointer to command string</li>
<li><i>handled: Pointer to bool</i> - Pointer to variable which tells if the command has been handled or not</li>
<li><i>io: Pointer to byte</i> - Pointer to I/O structure</li>
<li><i>Return value:byte</i> - Error code
</li>
</ul><br />
</li>
<li><a name="ReadReg">
<b>ReadReg</b></a>
 - Reads from a device register address
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> byte ReadReg(byte addr, byte *val)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>addr:byte</i> - Device register address</li>
<li><i>val: Pointer to byte</i> - Pointer to where to store the value</li>
<li><i>Return value:byte</i> - Error code
</li>
</ul><br />
</li>
<li><a name="Init">
<b>Init</b></a>
 - Initializes the device driver
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> uint8_t Init(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>Return value:uint8_t</i> - Error code, ERR_OK if everything is ok.
</li>
</ul><br />
</li>
<li><a name="Deinit">
<b>Deinit</b></a>
 - Counterpart to Init() method.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> uint8_t Deinit(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>Return value:uint8_t</i> - Error code, ERR_OK if everything is ok.
</li>
</ul><br />
</li>
<li><a name="MagneticSensorReset">
<b>MagneticSensorReset</b></a>
 - initiates a magnetic sensor reset cycle that will restore correct operation after exposure to an excessive magnetic field which exceeds the Full Scale Range but is less than the Maximum Applied Magnetic Field.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> byte MagneticSensorReset(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>Return value:byte</i> - Error code
</li>
</ul><br />
</li>

           </ul>
<!---USERBEG DON'T CHANGE THIS LINE-->

<!---USEREND DON'T CHANGE THIS LINE-->
<p>
<br />
Note: Some methods can be implemented as macros.
</p>
          </div>
          <p class="footer">
            PROCESSOR EXPERT is trademark of Freescale Semiconductor, Inc.
            <br />
            
          </p>
    </td>
  </tr>

</table>

</body>
</html>
