<?xml version="1.0" encoding="UTF-8"?>
<Interface>
  <Name>HWSPI</Name>
  <Description>Interface "SD_Card\HWSPI" for component SD_Card, generated by Component Wizard</Description>
  <Author>Erich Styger</Author>
  <Version>01.006</Version>
  <FileVersion>2</FileVersion>
  <MethodList>
    <Method>
      <TMthdItem>
        <Name>RecvChar</Name>
        <Symbol>RecvChar</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>If any data is received, this method returns one character, otherwise it returns an error code (it does not wait for data).\n
&lt;!---VER_SPEC ~56800~ ^^ || DON'T CHANGE THIS LINE--&gt;\n
&lt;div class="versionspec"&gt;\n
&lt;B CLASS="VSP"&gt;\n
Version specific information for Freescale 56800 derivatives\n
&lt;/B&gt;\n
&lt;br/&gt;\n
DMA mode:&lt;BR /&gt;\n
If DMA controller is available on selected CPU and receiver is configured to use DMA controller then this method only sets the selected DMA channel. Status of the DMA transfer can then be checked using method GetCharsInRxBuf. See typical usage for details about communication using DMA.\n
&lt;/div&gt;\n
&lt;!---VER_SPEC_END  DON'T CHANGE THIS LINE--&gt;</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>true</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code, possible codes:\n     ERR_OK - OK - The valid data is received.\n     ERR_SPEED - This device does not work in the active speed mode\n     ERR_RXEMPTY - No data in receiver\n     ERR_OVERRUN - Overrun error was detected from the last char or block received. In polling mode, this error code is returned only when the hardware supports detection of the overrun error. The valid data is also received.\n     ERR_FAULT - Fault error was detected from the last char or block received. This error may not be supported on some CPUs (see generated code).</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>Chr</ParName>
          <ParType>TComData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>A pointer to the received character</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(%'ModuleName'_TComData *Chr)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendChar</Name>
        <Symbol>SendChar</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Sends one character to the channel.\n
&lt;!---VER_SPEC ~56800~ ^^ || DON'T CHANGE THIS LINE--&gt;\n
&lt;div class="versionspec"&gt;\n
&lt;B CLASS="VSP"&gt;\n
Version specific information for Freescale 56800 derivatives\n
&lt;/B&gt;\n
&lt;br/&gt;\n
DMA mode:&lt;BR /&gt;\n
If DMA controller is available on the selected CPU and the transmitter is configured to use DMA controller then this method only sets the selected DMA channel. The status of the DMA transfer can then be checked using GetCharsInTxBuf method. See the typical usage for details about communication using DMA.\n
&lt;/div&gt;\n
&lt;!---VER_SPEC_END  DON'T CHANGE THIS LINE--&gt;</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>true</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code, possible codes:\n     ERR_OK - OK\n     ERR_SPEED - This device does not work in the active speed mode\n     ERR_DISABLED - Device is disabled (only if output DMA is supported and enabled)\n     ERR_TXFULL - Transmitter is full</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>Chr</ParName>
          <ParType>TComData</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Character to send</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(%'ModuleName'_TComData Chr)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SetBaudRateMode</Name>
        <Symbol>SetBaudRateMode</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>This method changes the channel communication speed (baud rate).\n
This method is available only if you specify a list of possible period settings at design time (see &lt;a href="../../DOCs/beantiming.html"&gt;Timing dialog box&lt;/a&gt;&amp;nbsp;-&amp;nbsp;Runtime setting&amp;nbsp;-&amp;nbsp;from a list of values). Each of these settings constitutes a &lt;i&gt;mode&lt;/i&gt; and Processor Expert assigns them a &lt;i&gt;mode identifier&lt;/i&gt;. The prescaler and compare values corresponding to each mode are calculated at design time.  You may switch modes at runtime by referring only to a mode identifier. No run-time calculations are performed, all the calculations are performed at design time.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>true</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code, possible codes:\n     ERR_OK - OK\n     ERR_SPEED - This device does not work in the active speed mode\n     ERR_VALUE - Invalid ID of the baud rate mode.</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>Mod</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Timing mode to set&lt;BR/&gt;\nNote: Special constant is generated in the components header file for each mode from the list of values.&lt;BR/&gt;\nThis constant can be directly passed to the parameter. Format of the constant is:&lt;BR/&gt;\n&amp;lt;BeanName&amp;gt;_BM_&amp;lt;Timing&amp;gt; e.g. "sm1_BM_31_250KHZ" for shift clock rate set to 31.250 kHz and component name "sm1". See beans header file for details.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(byte Mod)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SetShiftClockPolarity</Name>
        <Symbol>SetShiftClockPolarity</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Sets the shift clock polarity at runtime. Output data will be shifted on the selected edge polarity. The method will disable communication (if enabled), change the shift clock polarity end re-enable the communication (if it was enabled before).</Hint>
        <ItemLevel>EXPERT</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code, possible codes:\n     ERR_OK - OK\n     ERR_SPEED - This device does not work in the active speed mode\n     ERR_DISABLED - Device is disabled\n     ERR_RANGE - Parameter out of range</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>Edge</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Edge polarity.\n  0-falling edge\n  1-rising edge</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(byte Edge)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SetIdleClockPolarity</Name>
        <Symbol>SetIdleClockPolarity</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Sets the idle clock polarity at runtime. If the communication does not run, the clock signal will have required level. The method will disable communication (if enabled), change the idle clock polarity end re-enable the communication (if it was enabled before).</Hint>
        <ItemLevel>EXPERT</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_?Exist</Mode>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code, possible codes:\n     ERR_OK - OK\n     ERR_SPEED - This device does not work in the active speed mode\n     ERR_DISABLED - Device is disabled\n     ERR_RANGE - Parameter out of range</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>Level</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Idle clock polarity:\n  0-low\n  1-high</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(byte Level)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
  </MethodList>
  <EventList>
    <EmptySection_DummyValue/>
  </EventList>
  <Registration>
    <Template>HWSPI</Template>
    <Template>SynchroMaster</Template>
  </Registration>
  <UserTypes>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>TError</Name>
      <Hint>Error flags. For languages which don't support bit access is byte access only to error flags possible. </Hint>
      <Generate>yes</Generate>
      <Unique>yes</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint>typedef union {\n
  byte err;\n
  struct {\n
    bool OverRun  : 1;   /* OverRun error flag - the data overflow on the input has been detected. Both hardware detection (if supported) and software detection (when the value of Input buffer size property is 0) is used. */\n
    bool RxBufOvf : 1;   /* Rx buffer full error flag - the input circular buffer defined by the Input buffer size property has overrun. */\n
    bool FaultErr : 1;   /* Fault mode error flag - only if supported by hardware */\n
  }errName;\n
} %'ModuleName'_TError; /* Error flags. For languages which don't support bit access is byte access only to error flags possible.  */\n
</PreparedHint>
      <Type>typedef union {\n
  byte err;\n
  struct {\n
    bool OverRun  : 1;   /* OverRun error flag - the data overflow on the input has been detected. Both hardware detection (if supported) and software detection (when the value of Input buffer size property is 0) is used. */\n
    bool RxBufOvf : 1;   /* Rx buffer full error flag - the input circular buffer defined by the Input buffer size property has overrun. */\n
    bool FaultErr : 1;   /* Fault mode error flag - only if supported by hardware */\n
  }errName;\n
} %'ModuleName'_TError;</Type>
      <HWTestType>16bit unsigned</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>TComData</Name>
      <Hint>User type for communication. Size of this type depends on the communication data width. See &lt;a href="SynchroMaster.html"&gt;General Info&lt;/a&gt;.</Hint>
      <Generate>no</Generate>
      <Unique>yes</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint> /* User type for communication. Size of this type depends on the communication data width. See &lt;a href="SynchroMaster.html"&gt;General Info&lt;/a&gt;. */\n
</PreparedHint>
      <Type/>
      <HWTestType>16bit unsigned</HWTestType>
    </Type>
  </UserTypes>
</Interface>
